This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
assets/data/environmentData.js
assets/data/introCutscene.json
assets/data/level2.json
assets/data/raptor_architecture.md
babel.config.cjs
css/style.css
docs/CONTRIBUTING.md
docs/PROJECT_RAPTOR_BIBLE.md
docs/PROJECT_ROADMAP.md
docs/TECHNICAL_REFERENCE.md
editor/editor.html
editor/Level Editor Test Results.md
editor/Project Raptor Level Editor - User Guide.md
generate-placeholders.cjs
index.html
jest.config.js
js/data/shopItems.js
js/engine/assets.js
js/engine/audio.js
js/engine/collision.js
js/engine/effectManager.js
js/engine/entity.js
js/engine/game.js
js/engine/input.js
js/engine/ObjectPool.js
js/engine/saveManager.js
js/entities/boss1.js
js/entities/collectible.js
js/entities/destructibleObject.js
js/entities/enemy.js
js/entities/enemyBehaviors.js
js/entities/enemyFactory.js
js/entities/environment.js
js/entities/environmentFactory.js
js/entities/explosion.js
js/entities/homingProjectile.js
js/entities/impactEffect.js
js/entities/missile.js
js/entities/player.js
js/entities/projectile.js
js/entities/smokeParticle.js
js/environment/BackgroundManager.js
js/environment/scrolling-background.js
js/environment/tilemap.js
js/environment/tileset.js
js/levels/level1.js
js/levels/level1.json
js/levels/level2.js
js/main.js
js/states/boot.js
js/states/characterSelect.js
js/states/gameover.js
js/states/gameState.js
js/states/hangar.js
js/states/introCutscene.js
js/states/LoadingState.js
js/states/menu.js
js/states/pause.js
js/states/shop.js
js/states/supply.js
js/ui/hud.js
js/utils/generatePlaceholders.js
js/utils/logger.js
js/utils/math.js
package.json
test-impact-effect.html
tests/assetManager.test.js
tests/collision.test.js
tests/enemyFactory.test.js
tests/jest-setup.js
tests/math.test.js
tests/mocks/mock-game.js
tests/player.test.js
tests/projectile.test.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/assetManager.test.js">
import { AssetManager } from '../js/engine/assets.js';

// Mock the logger to avoid console output during tests
jest.mock('../js/utils/logger.js', () => ({
  logger: {
    debug: jest.fn(),
    info: jest.fn(),
    error: jest.fn(),
  },
}));

// Mock Image constructor
global.Image = jest.fn().mockImplementation(() => ({
  crossOrigin: '',
  onload: null,
  onerror: null,
  src: '',
  width: 100,
  height: 100,
}));

// Mock fetch for JSON loading
global.fetch = jest.fn();

describe('AssetManager', () => {
  let assetManager;

  beforeEach(() => {
    assetManager = new AssetManager();
    jest.clearAllMocks();
  });

  describe('Constructor and Initial State', () => {
    test('should initialize with empty asset collections', () => {
      expect(assetManager.images).toEqual({});
      expect(assetManager.audio).toEqual({});
      expect(assetManager.data).toEqual({});
    });

    test('should initialize with zero loading counters', () => {
      expect(assetManager.totalAssets).toBe(0);
      expect(assetManager.loadedAssets).toBe(0);
    });

    test('should initialize with null callbacks', () => {
      expect(assetManager.onProgress).toBeNull();
      expect(assetManager.onComplete).toBeNull();
      expect(assetManager.onGameplayAssetsLoaded).toBeNull();
    });

    test('should initialize with gameplay assets not loaded', () => {
      expect(assetManager.gameplayAssetsLoaded).toBe(false);
    });
  });

  describe('Image Loading', () => {
    test('should load image successfully and store it', async () => {
      const mockImage = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      };
      
      global.Image.mockImplementation(() => mockImage);

      const loadPromise = assetManager.loadImage('testImage', 'test.png');
      
      // Simulate successful image load
      mockImage.onload();

      const result = await loadPromise;

      expect(assetManager.images.testImage).toBe(mockImage);
      expect(assetManager.totalAssets).toBe(1);
      expect(assetManager.loadedAssets).toBe(1);
      expect(result).toBe(mockImage);
    });

    test('should handle image loading errors', async () => {
      const mockImage = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
      };
      
      global.Image.mockImplementation(() => mockImage);

      const loadPromise = assetManager.loadImage('testImage', 'invalid.png');
      
      // Simulate image load error
      const error = new Error('Image load failed');
      mockImage.onerror(error);

      await expect(loadPromise).rejects.toThrow('Failed to load image: invalid.png');
      expect(assetManager.totalAssets).toBe(1);
      expect(assetManager.loadedAssets).toBe(0); // Should not increment on error
    });

    test('should skip loading if image already exists', async () => {
      const existingImage = { width: 50, height: 50 };
      assetManager.images.existingImage = existingImage;

      const result = await assetManager.loadImage('existingImage', 'test.png');

      expect(result).toBe(existingImage);
      expect(assetManager.totalAssets).toBe(0); // Should not increment
      expect(assetManager.loadedAssets).toBe(0); // Should not increment
    });
  });

  describe('JSON Loading', () => {
    test('should load JSON data successfully', async () => {
      const mockData = { level: 1, enemies: ['fighter', 'bomber'] };
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockData),
      });

      const result = await assetManager.loadJSON('levelData', 'level1.json');

      expect(assetManager.data.levelData).toEqual(mockData);
      expect(assetManager.totalAssets).toBe(1);
      expect(assetManager.loadedAssets).toBe(1);
      expect(result).toEqual(mockData);
    });

    test('should handle JSON loading errors', async () => {
      global.fetch.mockResolvedValueOnce({
        ok: false,
      });

      await expect(assetManager.loadJSON('levelData', 'invalid.json'))
        .rejects.toThrow('Failed to load JSON: invalid.json');
      
      expect(assetManager.totalAssets).toBe(1);
      expect(assetManager.loadedAssets).toBe(0); // Should not increment on error
    });

    test('should handle network errors during JSON loading', async () => {
      global.fetch.mockRejectedValueOnce(new Error('Network error'));

      await expect(assetManager.loadJSON('levelData', 'level1.json'))
        .rejects.toThrow('Network error');
    });
  });

  describe('Asset Retrieval', () => {
    test('should retrieve stored images', () => {
      const testImage = { width: 100, height: 100 };
      assetManager.images.testImage = testImage;

      const result = assetManager.getImage('testImage');
      expect(result).toBe(testImage);
    });

    test('should return undefined for non-existent images', () => {
      const result = assetManager.getImage('nonExistent');
      expect(result).toBeUndefined();
    });

    test('should retrieve stored data', () => {
      const testData = { score: 1000 };
      assetManager.data.testData = testData;

      const result = assetManager.getData('testData');
      expect(result).toEqual(testData);
    });

    test('should return undefined for non-existent data', () => {
      const result = assetManager.getData('nonExistent');
      expect(result).toBeUndefined();
    });
  });

  describe('Loading Progress and Completion', () => {
    test('should calculate loading progress correctly', () => {
      assetManager.totalAssets = 4;
      assetManager.loadedAssets = 2;

      const progress = assetManager.getLoadingProgress();
      expect(progress).toBe(50);
    });

    test('should return 0 progress when no assets are queued', () => {
      const progress = assetManager.getLoadingProgress();
      expect(progress).toBe(0);
    });

    test('should return 100 progress when all assets are loaded', () => {
      assetManager.totalAssets = 3;
      assetManager.loadedAssets = 3;

      const progress = assetManager.getLoadingProgress();
      expect(progress).toBe(100);
    });

    test('should correctly identify when loading is complete', () => {
      assetManager.totalAssets = 2;
      assetManager.loadedAssets = 2;

      expect(assetManager.isLoadingComplete()).toBe(true);
    });

    test('should return false when loading is not complete', () => {
      assetManager.totalAssets = 3;
      assetManager.loadedAssets = 1;

      expect(assetManager.isLoadingComplete()).toBe(false);
    });

    test('should return false when no assets are queued', () => {
      expect(assetManager.isLoadingComplete()).toBe(false);
    });
  });

  describe('Callback Management', () => {
    test('should set progress callback', () => {
      const mockCallback = jest.fn();
      assetManager.setProgressCallback(mockCallback);

      expect(assetManager.onProgress).toBe(mockCallback);
    });

    test('should set complete callback', () => {
      const mockCallback = jest.fn();
      assetManager.setCompleteCallback(mockCallback);

      expect(assetManager.onComplete).toBe(mockCallback);
    });

    test('should set gameplay assets loaded callback', () => {
      const mockCallback = jest.fn();
      assetManager.setGameplayAssetsLoadedCallback(mockCallback);

      expect(assetManager.onGameplayAssetsLoaded).toBe(mockCallback);
    });

    test('should call progress callback when assets load', async () => {
      const mockProgressCallback = jest.fn();
      assetManager.setProgressCallback(mockProgressCallback);

      const mockImage = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      };
      
      global.Image.mockImplementation(() => mockImage);

      const loadPromise = assetManager.loadImage('testImage', 'test.png');
      mockImage.onload();
      await loadPromise;

      expect(mockProgressCallback).toHaveBeenCalledWith(100);
    });

    test('should call complete callback when all assets are loaded', async () => {
      const mockCompleteCallback = jest.fn();
      assetManager.setCompleteCallback(mockCompleteCallback);

      const mockImage = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      };
      
      global.Image.mockImplementation(() => mockImage);

      const loadPromise = assetManager.loadImage('testImage', 'test.png');
      mockImage.onload();
      await loadPromise;

      expect(mockCompleteCallback).toHaveBeenCalled();
    });
  });

  describe('Bulk Asset Loading', () => {
    test('should load multiple assets simultaneously', async () => {
      const mockImage1 = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      };
      const mockImage2 = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 200,
        height: 200,
      };
      
      global.Image
        .mockImplementationOnce(() => mockImage1)
        .mockImplementationOnce(() => mockImage2);

      const mockData = { level: 1 };
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockData),
      });

      const assets = {
        images: {
          image1: 'image1.png',
          image2: 'image2.png',
        },
        data: {
          levelData: 'level1.json',
        },
      };

      const loadPromise = assetManager.loadAssets(assets);
      
      // Simulate image loads
      mockImage1.onload();
      mockImage2.onload();

      await loadPromise;

      expect(assetManager.images.image1).toBe(mockImage1);
      expect(assetManager.images.image2).toBe(mockImage2);
      expect(assetManager.data.levelData).toEqual(mockData);
      expect(assetManager.totalAssets).toBe(3);
      expect(assetManager.loadedAssets).toBe(3);
    });

    test('should store asset list when loading assets', async () => {
      const assets = {
        images: { testImage: 'test.png' },
        data: { testData: 'test.json' },
      };

      const mockImage = {
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      };

      global.Image.mockImplementation(() => mockImage);

      global.fetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({}),
      });

      const loadPromise = assetManager.loadAssets(assets);
      
      // Simulate image load
      mockImage.onload();

      await loadPromise;

      expect(assetManager.assetList).toEqual(assets);
    });
  });

  describe('Gameplay Assets Loading', () => {
    test('should load gameplay assets successfully', async () => {
      const mockCallback = jest.fn();
      assetManager.setGameplayAssetsLoadedCallback(mockCallback);

      // Mock all the image loads
      const mockImages = Array(30).fill(null).map(() => ({
        crossOrigin: '',
        onload: null,
        onerror: null,
        src: '',
        width: 100,
        height: 100,
      }));

      global.Image.mockImplementation(() => {
        const image = mockImages.shift();
        // Simulate immediate load
        if (image && image.onload) {
          setTimeout(() => image.onload(), 0);
        }
        return image;
      });

      const loadPromise = assetManager.loadGameplayAssets();
      await loadPromise;

      expect(assetManager.gameplayAssetsLoaded).toBe(true);
      expect(mockCallback).toHaveBeenCalled();
    }, 10000); // Increase timeout for this test

    test('should handle gameplay assets loading errors gracefully', async () => {
      global.Image.mockImplementation(() => {
        const image = {
          crossOrigin: '',
          onload: null,
          onerror: null,
          src: '',
        };
        // Simulate immediate error
        setTimeout(() => image.onerror(new Error('Load failed')), 0);
        return image;
      });

      // Should not throw error
      await expect(assetManager.loadGameplayAssets()).resolves.toBeUndefined();
      
      // Should not mark as loaded
      expect(assetManager.gameplayAssetsLoaded).toBe(false);
    });
  });
});
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
node_modules
</file>

<file path="assets/data/environmentData.js">
/**
 * Environment Data - Database of destructible environmental objects
 * Defines properties for all destructible ground-based objects in the game
 */

export const environmentData = {
    'FUEL_TANK': {
        id: 'FUEL_TANK',
        name: 'Fuel Tank',
        spriteAsset: 'fuelTank',
        width: 48,
        height: 48,
        health: 25,
        explosionSize: 'large', // 'small', 'medium', 'large'
        scoreValue: 50,
        description: 'Volatile fuel storage tank - explodes dramatically when destroyed'
    },
    
    'RADAR_DISH': {
        id: 'RADAR_DISH',
        name: 'Radar Dish',
        spriteAsset: 'radarDish',
        width: 64,
        height: 64,
        health: 75,
        explosionSize: 'medium',
        scoreValue: 150,
        description: 'Communications radar array - high value target'
    },
    
    'BUNKER': {
        id: 'BUNKER',
        name: 'Concrete Bunker',
        spriteAsset: 'bunker',
        width: 80,
        height: 60,
        health: 150,
        explosionSize: 'large',
        scoreValue: 200,
        description: 'Heavily fortified bunker - requires sustained fire to destroy'
    },
    
    'SILO': {
        id: 'SILO',
        name: 'Missile Silo',
        spriteAsset: 'silo_sprite',
        width: 56,
        height: 72,
        health: 100,
        explosionSize: 'large',
        scoreValue: 300,
        description: 'Strategic missile launch facility - extremely valuable target'
    },
    
    'TURRET_BASE': {
        id: 'TURRET_BASE',
        name: 'Anti-Aircraft Turret',
        spriteAsset: 'turret_base_sprite',
        width: 40,
        height: 40,
        health: 60,
        explosionSize: 'medium',
        scoreValue: 100,
        description: 'Automated defense turret - destroy before it targets you'
    },
    
    'POWER_STATION': {
        id: 'POWER_STATION',
        name: 'Power Generator',
        spriteAsset: 'power_station_sprite',
        width: 72,
        height: 48,
        health: 80,
        explosionSize: 'large',
        scoreValue: 175,
        description: 'Critical power infrastructure - causes chain explosions'
    },
    
    'WAREHOUSE': {
        id: 'WAREHOUSE',
        name: 'Supply Warehouse',
        spriteAsset: 'warehouse_sprite',
        width: 96,
        height: 64,
        health: 120,
        explosionSize: 'medium',
        scoreValue: 125,
        description: 'Large storage facility - may contain valuable supplies'
    },
    
    'COMM_TOWER': {
        id: 'COMM_TOWER',
        name: 'Communication Tower',
        spriteAsset: 'comm_tower_sprite',
        width: 32,
        height: 80,
        health: 40,
        explosionSize: 'small',
        scoreValue: 75,
        description: 'Tall communication antenna - easy target but low health'
    },
    
    'HANGAR': {
        id: 'HANGAR',
        name: 'Aircraft Hangar',
        spriteAsset: 'hangar_sprite',
        width: 120,
        height: 80,
        health: 200,
        explosionSize: 'large',
        scoreValue: 250,
        description: 'Large aircraft storage facility - heavily armored'
    },
    
    'SMALL_BUILDING': {
        id: 'SMALL_BUILDING',
        name: 'Small Building',
        spriteAsset: 'small_building_sprite',
        width: 40,
        height: 32,
        health: 30,
        explosionSize: 'small',
        scoreValue: 25,
        description: 'Basic structure - quick to destroy'
    }
};

/**
 * Helper function to get environment object data by ID
 * @param {string} id - The environment object ID
 * @returns {Object|null} Environment object data or null if not found
 */
export function getEnvironmentData(id) {
    return environmentData[id] || null;
}

/**
 * Helper function to get all environment object IDs
 * @returns {Array<string>} Array of all environment object IDs
 */
export function getAllEnvironmentIds() {
    return Object.keys(environmentData);
}

/**
 * Helper function to get environment objects by explosion size
 * @param {string} size - Explosion size ('small', 'medium', 'large')
 * @returns {Array<Object>} Array of environment objects with matching explosion size
 */
export function getEnvironmentsByExplosionSize(size) {
    return Object.values(environmentData).filter(env => env.explosionSize === size);
}

/**
 * Helper function to get environment objects by health range
 * @param {number} minHealth - Minimum health value
 * @param {number} maxHealth - Maximum health value
 * @returns {Array<Object>} Array of environment objects within health range
 */
export function getEnvironmentsByHealthRange(minHealth, maxHealth) {
    return Object.values(environmentData).filter(env => 
        env.health >= minHealth && env.health <= maxHealth
    );
}
</file>

<file path="assets/data/introCutscene.json">
{
  "events": [
    {
      "type": "show_image_with_text",
      "asset": "cutscenePanel1",
      "text": "A.D. 2248. The Outer Rim colonies teeter on the brink of war.",
      "duration": 5000
    },
    {
      "type": "fade_to_black",
      "duration": 1000
    },
    {
      "type": "show_image_with_text",
      "asset": "cutscenePanel2",
      "text": "Only one pilot was daring enough to take the contract.",
      "duration": 5000
    },
    {
      "type": "fade_to_black",
      "duration": 1000
    },
    {
      "type": "end_scene"
    }
  ]
}
</file>

<file path="assets/data/level2.json">
{
  "level": 2,
  "name": "Bravo Sector - Wave 2",
  "background": "backgroundLevel2",
  "music": "gameMusic2",
  "waves": [
    {
      "id": 1,
      "name": "More Fighters",
      "duration": 10000,
      "enemies": [
        { "type": "fighter", "x": 100, "y": -50, "delay": 0 },
        { "type": "fighter", "x": 200, "y": -100, "delay": 300 },
        { "type": "fighter", "x": 300, "y": -50, "delay": 600 },
        { "type": "fighter", "x": 400, "y": -100, "delay": 900 },
        { "type": "fighter", "x": 500, "y": -50, "delay": 1200 },
        { "type": "fighter", "x": 600, "y": -100, "delay": 1500 },
        { "type": "fighter", "x": 700, "y": -50, "delay": 1800 }
      ]
    },
    {
      "id": 2,
      "name": "Turrets and Bombers",
      "duration": 15000,
      "enemies": [
        { "type": "turret", "x": 150, "y": -50, "delay": 0 },
        { "type": "turret", "x": 650, "y": -50, "delay": 0 },
        { "type": "bomber", "x": 300, "y": -100, "delay": 2000 },
        { "type": "bomber", "x": 500, "y": -100, "delay": 2000 },
        { "type": "turret", "x": 400, "y": -50, "delay": 4000 }
      ]
    },
    {
      "id": 3,
      "name": "Mixed Enemies",
      "duration": 20000,
      "enemies": [
        { "type": "fighter", "x": 100, "y": -50, "delay": 0 },
        { "type": "bomber", "x": 300, "y": -100, "delay": 1000 },
        { "type": "turret", "x": 500, "y": -50, "delay": 2000 },
        { "type": "fighter", "x": 700, "y": -50, "delay": 3000 },
        { "type": "bomber", "x": 200, "y": -100, "delay": 4000 },
        { "type": "turret", "x": 600, "y": -50, "delay": 5000 }
      ]
    },
    {
      "id": 4,
      "name": "Boss Wave",
      "duration": 30000,
      "enemies": [
        { "type": "boss1", "x": 336, "y": -150, "delay": 2000 }
      ]
    }
  ],
  "collectibles": [
    { "type": "health", "x": 200, "y": -200, "delay": 5000 },
    { "type": "shield", "x": 600, "y": -300, "delay": 10000 },
    { "type": "megabomb", "x": 400, "y": -400, "delay": 15000 },
    { "type": "health", "x": 300, "y": -500, "delay": 20000 },
    { "type": "shield", "x": 500, "y": -600, "delay": 25000 }
  ]
}
</file>

<file path="babel.config.cjs">
// babel.config.cjs
module.exports = {
  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],
};
</file>

<file path="docs/CONTRIBUTING.md">
# Contributing to Project Raptor

This guide provides instructions for setting up the development environment, running the game, and contributing to the codebase. Following these guidelines helps maintain consistency and ensures a smooth development workflow.

## 1. Prerequisites

Before you begin, ensure you have the following software installed on your system:

- **Node.js:** (v18.x or later recommended) - The JavaScript runtime environment.
- **npm:** (v9.x or later) - The Node.js package manager, which is included with Node.js.

## 2. Setup & Installation

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/scooberz/Raptor_ManusAI_V1.git
    cd Raptor_ManusAI_V1
    ```

2.  **Install dependencies:**
    Install the project'''s dependencies, such as Jest for testing, using npm.
    ```bash
    npm install
    ```

## 3. Running the Game

This project is a client-side application and needs to be served by a local web server to handle ES6 module loading correctly.

1.  **Start a local server:**
    A simple way to do this is using the `http-server` package, which you can run directly with `npx`. In the root directory of the project, run:
    ```bash
    npx http-server
    ```

2.  **Open the game:**
    Once the server is running, open your web browser and navigate to the local address it provides (e.g., `http://127.0.0.1:8080`). The `index.html` file will be served as the main page.

    **Note:** For the best development experience, open your browser'''s developer tools (F12) and disable the cache in the "Network" tab to prevent issues with stale scripts.

## 4. Running Tests

The project uses Jest for unit testing. To run the test suite, execute the following command from the project root:

```bash
npm test
```

This will run all test files located in the `tests/` directory.

## 5. Code Style & Conventions

- **Language:** The project uses modern JavaScript (ES6+), including ES6 Modules (`import`/`export`).
- **Formatting:** Please match the formatting, naming conventions, and architectural patterns of the existing code. Consistency is key.
- **Comments:** Add comments only when necessary to explain the *why* behind complex logic, not the *what*.

## 6. Project Structure

The project follows a clear, modular structure. When adding new files, please adhere to the existing organization:

- `js/engine/`: Core systems like the game loop, state machine, and asset managers.
- `js/entities/`: Game objects such as the Player, enemies, and projectiles.
- `js/states/`: Different game states (e.g., Menu, GameState, Shop).
- `js/ui/`: UI components like the HUD.
- `assets/`: All game assets (images, data, etc.).
- `docs/`: Project documentation.
- `tests/`: Unit tests.

For a more detailed breakdown, refer to the **Game Architecture** section in `docs/PROJECT_RAPTOR_BIBLE.md`.

## 7. Generating Placeholders

The project includes a utility for generating placeholder assets if needed. This can be run with:
```bash
npm run generate-placeholders
```
</file>

<file path="docs/PROJECT_RAPTOR_BIBLE.md">
# PROJECT RAPTOR BIBLE

## 1. High-Level Project Overview
- **Project Name:** Project Raptor
- **Concept:** A modern re-imagining of the classic 1994 DOS game *Raptor: Call of the Shadows*, built with a data-driven, modular JavaScript engine.
- **Current Goal:** Begin development of the "Raptor Forge" visual level editor while maintaining the stability of the core game engine.

## 2. Game Architecture
- **Technology Stack:** HTML5, CSS3, JavaScript (ES6 Modules), Web Audio API, Node.js, Git.
- **State Machine (`game.js`, `/states`):** Manages the overall game flow (Loading, Menu, Game, Hangar, Shop, etc.), ensuring clean setup (`enter`) and teardown (`exit`) of game states.
- **Data-Driven Design (`levelX.json`, `...Data.js`):** Level layouts, enemy waves, and object properties are defined in external .json files, allowing for rapid iteration without changing engine code. The format is specified in `TECHNICAL_REFERENCE.md`.
- **Behavior Library (`enemyBehaviors.js`):** A palette of reusable movement and firing pattern functions that can be assigned to any enemy via the level data, enabling complex and varied encounters.
- **Layered Canvas Rendering:** Utilizes multiple stacked `<canvas>` elements (background, environment, enemy, projectile, player, explosion, ui) to separate rendering concerns and improve performance.
- **Asynchronous Asset Loading:** A dedicated `LoadingState` and `AssetManager` handle the asynchronous loading of all game assets (images, audio, data) at startup.
- **Project Directory Structure:**
  ```
  raptor-game/
  ├── assets/         # Contains all game assets
  │   ├── data/         # JSON files for levels, etc.
  │   ├── images/       # All sprite and image files
  │   └── audio/        # Audio files are planned but not yet present
  ├── css/            # Contains all stylesheets
  │   └── style.css
  ├── docs/           # Project documentation
  ├── editor/         # Files for the level editor
  ├── js/             # All JavaScript source code
  │   ├── engine/       # Core systems (Game, AssetManager, Collision, etc.)
  │   ├── entities/     # Game objects (Player, Enemy, Projectile, etc.)
  │   ├── environment/  # Background and environment managers
  │   ├── states/       # All game states (Menu, Game, Shop, etc.)
  │   ├── ui/           # Heads-Up Display and other UI elements
  │   ├── utils/        # Utility functions
  │   └── main.js       # Main entry point for the application
  ├── tests/          # Jest test files
  ├── .gitignore      # Specifies files for Git to ignore
  ├── babel.config.cjs  # Babel configuration
  ├── index.html      # Main HTML file
  └── package.json    # Project dependencies and scripts
  ```

## 3. Visual Style Guide
- **Core Aesthetic:** Modern Retro - a modern interpretation of the 1994 classic with higher fidelity, cleaner lines, and modern effects. Gritty & Industrial military setting. High-contrast for readability.
- **Color Palette:**
    - **Core Aesthetic:** Modern Retro - a modern interpretation of the 1994 classic with higher fidelity, cleaner lines, and modern effects. Gritty & Industrial military setting. High-contrast for readability.
    - **Primary Colors:**
        - **Deep Space Blue**: `#0A1128` - For backgrounds and dark elements
        - **Military Green**: `#3E5622` - For ground-based enemies and terrain
        - **Steel Gray**: `#7D8491` - For metallic elements and UI frames
        - **Warning Red**: `#D62828` - For enemy highlights and warning indicators
        - **Energy Blue**: `#4CC9F0` - For player weapons and shields
    - **Secondary Colors:**
        - **Accent Orange**: `#F77F00` - For explosions and special effects
        - **Highlight Yellow**: `#FCBF49` - For collectibles and power-ups
        - **Tech Cyan**: `#06D6A0` - For special weapons and energy indicators
        - **Ground Brown**: `#774936` - For terrain and ground installations
        - **Water Teal**: `#118AB2` - For water areas
- **Typography:**
    - **UI Font**: "Exo 2" - A modern, slightly futuristic sans-serif font for menus and HUD
    - **Title Font**: "Orbitron" - Bold, tech-inspired font for game title and headings
    - **In-Game Text**: "Rajdhani" - Clean, readable font for in-game messages
- **Sprite & Asset Design:** Clean, defined look paying homage to the 16-bit era. Clear silhouettes. Simple, impactful animations. Consistent scale.
- **Environment Design:** Parallax scrolling for depth. Destructible elements. Distinct visual themes per level.
- **UI & HUD:** Minimalist, readable, clear feedback.
- **Reference & Inspiration:** *Raptor: Call of the Shadows*, *Ikaruga*, *Jamestown*, *Sky Force Reloaded*, *Advance Wars*, *Starcraft*.

## 4. Game Mechanics & Flow
- **Gameplay:** Vertical scrolling shoot '''em up. Player controls a fighter jet, battling enemies on ground, air, and sea. Levels end with a boss.
- **Difficulty Levels:** Rookie, Veteran, Elite.
- **Core Systems:**
    - **Money System:** Destroying enemies earns money for upgrades.
    - **Weapon System:** Players can collect and purchase different primary and special weapons.
    - **Collectibles:** Money, weapon bonuses, energy modules, megabombs.
- **Game Flow:**
  1. Main Menu → Select Difficulty
  2. Hangar (Interface) → Select New Mission
  3. Flight Computer → Select Mission (Wave)
  4. Play Mission
  5. After Mission → Supply Room (buy/sell weapons)
  6. Return to Hangar → Select next Mission

## 5. Controls
- **Keyboard/Mouse:** Arrow keys for movement, Ctrl to fire, Alt to cycle weapons, Space for megabomb.
- **Touch Controls:**
    - **Detection:** Automatically detects touch-capable devices.
    - **Movement:** Ship follows finger position with a vertical offset to prevent obstruction.
    - **Auto-Fire:** Weapons fire automatically while touching the screen.
    - **Boundary Clamping:** Ship stays within game boundaries.

## 6. AI Collaboration Framework (User Workflow)
This section outlines the workflow between the human "Director" (the user) and an AI "Architect" (Gemini).
- **The Golden Rule:** Trust, but verify. Every significant code change must be confirmed before testing.
- **The Workflow Loop:**
  1. **The Briefing:** The Director states a goal or reports a bug.
  2. **The Plan:** The Architect proposes a solution.
  3. **The Prompt:** The Architect provides a comprehensive, copy-paste-ready prompt for the chosen AI tool.
  4. **The Execution:** The Director gives the prompt to the AI tool.
  5. **THE VERIFICATION (CRITICAL STEP):** The Director pastes the entire contents of the changed file(s) back to the Architect.
  6. **The Review:** The Architect performs a quick code review to confirm the changes.
  7. **The Test:** Once confirmed, the Director tests the game.
- **Tiers of Execution:**
  - **Tier 1: Manual Edit (The Scalpel):** For small, single-file changes.
  - **Tier 2: Cursor AI (The Power Move):** For medium-to-large, well-defined tasks.
  - **Tier 3: ManusAI (The Architect'''s Gambit):** For massive, creative tasks.
</file>

<file path="docs/PROJECT_ROADMAP.md">
# PROJECT ROADMAP

## Completed Milestones (Phase 1-6)
- **Research & Planning:** Compeleted comprehensive research of the original *Raptor: Call of the Shadows* to define game mechanics, visual style, and overall architecture.
- **Core Engine Development:** Implemented the foundational game engine, including the game loop, state machine, layered canvas renderer, asset manager, and collision detection.
- **Asset Creation:** Created all necessary sprites and assets for the player, initial enemy types, projectiles, and UI elements for the first two levels.
- **Gameplay Implementation:** Developed player controls (keyboard/mouse and touch), weapon systems, and basic enemy AI.
- **Level Implementation:** Built and populated the first two levels with enemies, obstacles, and environmental objects using the data-driven level format.

## Current Focus (Phase 7)
- **Testing & Optimization:**
  - Test game functionality across different browsers.
  - Optimize rendering performance.
  - Debug and fix outstanding issues.
  - Balance gameplay difficulty.
  - Implement sound effects and music.

## Future Goals (Phase 8-9)
- **Packaging & Delivery:**
  - Package game files for easy deployment.
  - Create user documentation and instructions.
- **Architectural Enhancements:**
  - Refactor to a generic, reusable `Level` class.
  - Implement a robust `AudioManager` with volume controls.
  - Implement a full tilemap-based environment system.
- **Feature Development:**
  - Design and build the Hangar/Shop system for persistent upgrades.
  - Design and build the "Raptor Forge" visual level editor.
  - Design and build a comprehensive power-up and collectibles system.

## Assets Still Needed

### Player Assets
- Additional weapon upgrade visuals
- Damage state sprites

### Enemy Assets
- Enemy bomber sprite
- Additional enemy types
- Level 2 boss sprite

### Projectile Assets
- Missile projectiles
- Special weapon projectiles

### Explosion Assets
- Additional explosion animation frames (3-8)
- Different sized explosions

### UI Assets
- Menu buttons
- Weapon selection icons
- Score/money display
- Game over screen
- Victory screen

### Audio Assets
- Background music for levels
- Weapon sound effects
- Explosion sound effects
- UI sound effects
- Engine sound effects
</file>

<file path="docs/TECHNICAL_REFERENCE.md">
# TECHNICAL REFERENCE

## 1. Level Data Format (v2.0)

### Overview
This document describes the data-driven format for level files (e.g., `level1.json`). This structure allows for maximum creative flexibility in level design without needing to change game engine code.

### Root Object Structure
Each level file is a single JSON object with the following top-level properties.
```json
{
  "levelName": "Bravo Sector - The Gauntlet",
  "waves": [ ... ]
}
```
- `levelName`: (String) The name of the level, displayed for debugging.
- `waves`: (Array) An array of Wave Objects that defines the entire sequence of the level.

### Wave Object Structure
Each object in the waves array defines a single wave of enemies and environment objects.

```json
{
    "wave_id": "wave_01_scouts",
    "delay_after_previous_wave_ms": 3000,
    "enemies": [ ... ],
    "environment_objects": [ ... ]
}
```
- `wave_id`: (String) A unique descriptive name for the wave.
- `delay_after_previous_wave_ms`: (Number) The time in milliseconds to wait after the previous wave is fully cleared before this wave begins. This is the primary tool for controlling level pacing.
- `enemies`: (Array) An array of Enemy Objects to spawn during this wave.
- `environment_objects`: (Optional Array) An array of Environment Objects to spawn at the start of this wave.

### Enemy Object Structure
Each object in an enemies array defines a single enemy to be spawned.

```json
{
    "type": "striker",
    "spawn_x": 300,
    "spawn_y": -50,
    "delay": 1000,
    "overrides": {
        "movementPattern": "move_to_point_and_hold",
        "formation_point": { "x": 300, "y": 200 },
        "hold_duration_ms": 4000,
        "firingPattern": "single_aimed_shot",
        "speed": 150,
        "health": 75
    }
}
```
- `type`: (String) The enemy type ID. Must match a case in the EnemyFactory.
- `spawn_x`, `spawn_y`: (Number) The coordinates where the enemy first appears. `spawn_y` should be negative to appear off-screen.
- `delay`: (Number) How many milliseconds to wait after the wave begins before this specific enemy appears.
- `overrides`: (Optional Object) This is the creative control panel. Any property here will override the default behavior for this specific enemy instance.

#### Available Overrides
- `movementPattern` (String): The key for the desired movement function from enemyBehaviors.js.
- `firingPattern` (String): The key for the desired firing function from enemyBehaviors.js.
- `speed` (Number): Base speed for movement patterns.
- `health` (Number): Overrides default health.
- `fireRate` (Number): Time in ms between shots/volleys for firing patterns.
- **Custom Pattern Parameters:** Some movement patterns require their own special parameters:
    - `formation_point`: An object `{ "x": number, "y": number }` used by move_to_point_and_hold.
    - `hold_duration_ms`: (Number) Time in ms used by move_to_point_and_hold.
    - `trigger_y`: (Number) The Y-coordinate that triggers the next phase of a pattern like descend_and_strafe.
    - `split_direction`: (Number, 1 for right or -1 for left) Used by split_and_descend.
    - `target_x`: (Number) The target X-coordinate used by strafe_to_x_position.

### Environment Object Structure
Each object in an environment_objects array defines a single static, destructible object.

```json
{
    "type": "FUEL_TANK",
    "spawn_x": 150,
    "spawn_y": 400,
    "delay": 0
}
```
- `type`: (String) The object type ID. Must match a case in the EnemyFactory (e.g., 'FUEL_TANK', 'BUNKER').
- `spawn_x`, `spawn_y`: (Number) The coordinates where the object is placed. `spawn_y` should be a positive number on the screen.
- `delay`: (Number) How many milliseconds to wait after the wave begins before this object appears.

## Environment Object Types

### Available Types
- **FUEL_TANK**: Volatile fuel storage (48x48, 25 HP, large explosion)
- **RADAR_DISH**: Communications array (64x64, 75 HP, medium explosion)
- **BUNKER**: Concrete fortification (80x60, 150 HP, large explosion)
- **SILO**: Missile launch facility (56x72, 100 HP, large explosion)
- **TURRET_BASE**: Anti-aircraft turret (40x40, 60 HP, medium explosion)
- **POWER_STATION**: Power generator (72x48, 80 HP, large explosion)
- **WAREHOUSE**: Supply storage (96x64, 120 HP, medium explosion)
- **COMM_TOWER**: Communication antenna (32x80, 40 HP, small explosion)
- **HANGAR**: Aircraft storage (120x80, 200 HP, large explosion)
- **SMALL_BUILDING**: Basic structure (40x32, 30 HP, small explosion)

### Properties
Each environment object type has:
- **Health**: How much damage it can take before being destroyed
- **Score Value**: Points awarded when destroyed
- **Explosion Size**: Visual effect size (small/medium/large)
- **Dimensions**: Width and height in pixels

### Positioning Guidelines

#### Coordinate System
- **X**: Horizontal position (0 = left edge, 800 = right edge)
- **Y**: Vertical position (0 = top of screen, positive = down)
- Environment objects are typically placed at Y > 150 to be on the ground

#### Placement Tips
1. **Spacing**: Leave enough space between objects for player movement
2. **Strategic Placement**: Place high-value targets in challenging positions
3. **Visual Balance**: Distribute objects across the level for visual appeal
4. **Gameplay Flow**: Consider how objects affect player movement and strategy

### Example Wave with Environment Objects

```json
{
  "id": 2,
  "name": "Industrial Complex",
  "duration": 15000,
  "enemies": [
    { "type": "fighter", "x": 300, "y": -50, "delay": 1000 },
    { "type": "turret", "x": 600, "y": -50, "delay": 2000 }
  ],
  "environment_objects": [
    { "type": "FUEL_TANK", "x": 150, "y": 200 },
    { "type": "RADAR_DISH", "x": 400, "y": 250 },
    { "type": "BUNKER", "x": 650, "y": 180 },
    { "type": "POWER_STATION", "x": 300, "y": 300 }
  ]
}
```

### Implementation Notes

#### Loading
Environment objects are loaded when a wave starts and placed on the environment canvas layer.

#### Collision
- Player projectiles can damage and destroy environment objects
- Environment objects are static and don't move
- Destroyed objects create explosions and award score points

#### Performance
- Environment objects are rendered on a separate canvas layer
- Objects are automatically cleaned up when destroyed
- No limit on number of objects per wave (within reason)

### Best Practices

1. **Start Simple**: Begin with a few small objects and gradually increase complexity
2. **Test Balance**: Ensure objects don't make levels too easy or too difficult
3. **Visual Variety**: Use different object types to create interesting landscapes
4. **Strategic Depth**: Place valuable targets in positions that require skill to reach
5. **Chain Reactions**: Group explosive objects for dramatic chain reaction effects

### Boss Behavior Example
To assign advanced boss behaviors in a level JSON wave:

```
{
  "type": "boss1",
  "spawn_x": 272,
  "spawn_y": -150,
  "delay": 2000,
  "overrides": {
    "health": 2500,
    "speed": 90,
    "movementPattern": "boss_patrol",
    "firingPattern": "boss_multi_weapon_fire",
    "straightFireRate": 2000,
    "aimedFireRate": 3200
  }
}
```

- `movementPattern`: Use `boss_patrol` for dynamic waypoint patrol.
- `firingPattern`: Use `boss_multi_weapon_fire` for rapid missiles, burst-aimed shots, reposition pauses, and desperation attack.
- `straightFireRate`, `aimedFireRate`: Control the base fire rates (actual rates are 3x faster in this pattern).

## 2. Asset & Behavior Inventory

### Image Assets
- **Player:** `/assets/images/player/player_ship_base.png`, `/assets/images/player/player_ship_thrust.png`
- **Enemies:** `/assets/images/enemies/enemy_fighter.png`, `/assets/images/enemies/enemy_turret.png`, `/assets/images/enemies/boss_level1.png`
- **Projectiles:** `/assets/images/projectiles/player_bullet.png`, `/assets/images/projectiles/enemy_bullet.png`
- **Explosions:** `/assets/images/explosions/explosion_1.png`, `/assets/images/explosions/explosion_2.png`
- **Collectibles:** `/assets/images/collectibles/health_pickup.png`, `/assets/images/collectibles/shield_pickup.png`, `/assets/images/collectibles/megabomb_pickup.png`
- **Environment:** `/assets/images/environment/background_level1.png`, `/assets/images/environment/background_level2.png`
- **UI:** `/assets/images/ui/health_bar.png`, `/assets/images/ui/shield_bar.png`, `/assets/images/ui/game_logo.png`

### Audio Assets
- **Sound Effects:** `player_shoot.mp3`, `enemy_shoot.mp3`, `explosion.mp3`, `player_damage.mp3`, `pickup.mp3`, `megabomb.mp3`
- **Music:** `menu_music.mp3`, `game_music_1.mp3`, `game_music_2.mp3`

### Behavior Library (`enemyBehaviors.js`)

#### Movement Patterns
| Pattern Name | Description |
| :--- | :--- |
| `default` | Enemy moves straight down at its base velocity. |
| `sine_wave_slow` | Enemy moves in a slow sine wave. |
| `sine_wave_fast` | Enemy moves in a fast sine wave. |
| `swoop_from_left` / `swoop_from_right` | Enters from the side and arcs towards the center. Used by Darts. |
| `move_straight_down` | Moves straight down using base velocity. |
| `move_to_point_and_hold` | Flies to a specific point, holds for a duration, then descends. Used by Formation Strikers. |
| `sweep` | Sweeps side-to-side as it descends. |
| `patrol_and_strafe` | Flies to a patrol altitude, moves side-to-side, then retreats. Used by Cyclones. |
| `strafe_and_descend` | Descends, strafes horizontally, then continues down. |
| `descend_and_converge` | Flies down, then angles towards the center of the screen. |
| `descend_and_veer` | Flies down, then veers towards the center. |
| `descend_and_strafe_right` / `descend_and_strafe_left` | Flies down, then strafes hard right or left. |
| `move_diagonal` | Flies in a constant diagonal line. |
| `slow_homing` | Slowly drifts and steers towards the player. Used by Mines. |
| `zigzag` | Moves back and forth horizontally while descending. |
| `strafe_to_x_position` | Descends while strafing to a target X, then continues down. |
| `strafe_out_and_in` | Strafes out to the edge, back to center, then descends. |
| `split_and_descend` | Descends, then splits off to the side. Used by V-formation followers. |
| `descend_and_diverge` | Flies down, then angles away from the center of the screen. |
| `criss_cross` | Flies in a straight diagonal line, intended for coordinated group attacks. |
| `boss_patrol` | Boss enters, then patrols between three upper-screen waypoints, pausing initial descent at y=80. |

#### Firing Patterns
| Pattern Name | Description |
| :--- | :--- |
| `none` | The enemy does not fire. |
| `single_aimed_shot` | Aims and fires a single projectile at the player'''s current location. |
| `single_straight_shot` | Fires a single, un-aimed projectile straight down. |
| `three_round_spread` | Fires a 3-shot fan of projectiles. |
| `fire_straight_missile` | Fires a powerful, non-homing missile straight ahead. |
| `burst_fire` | Fires a quick volley of 3 aimed shots. Used by Cutters. |
| `wide_v_shot` | Fires two projectiles in a wide V-pattern. Used by Goliaths. |
| `boss_multi_weapon_fire` | The boss'''s advanced pattern: rapid straight missiles, burst-aimed shots (3-shot burst after a pause), periodic reposition pauses, and a desperation ring attack at 25% health. Fire rates are 3x faster than normal. |

#### Projectile Asset Keys
- `enemyMissile`: Uses `ENEMY_MISSILE.png` (for boss and advanced enemy missiles)
- `enemyBullet`: Uses `enemy_bullet.png` (orange ball, for most enemy projectiles)

## 3. Known Issues & Best Practices

- **Rendering: The "White Box" Bug**
  - **Symptom:** A sprite renders with a solid white box behind it.
  - **Root Cause:** Canvas `globalCompositeOperation` is not being reset.
  - **Solution:** The `Game.render()` loop now includes a "Systemic State Reset" that explicitly sets `globalCompositeOperation = 'source-over'` for all canvas layers on every frame.

- **Asset Loading: The "Stale Script" Bug**
  - **Symptom:** Code changes do not seem to apply.
  - **Root Cause:** Aggressive browser caching.
  - **Solution:** When testing, always have the browser'''s Developer Tools open (F12) with the "Disable cache" option checked in the "Network" tab.

- **Assets: The "Corrupted PNG" Bug**
  - **Symptom:** An asset fails to load or renders incorrectly.
  - **Root Cause:** A script with pixel-processing logic accidentally overwrote an original PNG file.
  - **Solution:** Manually restore the asset by opening it in an image editor, removing the background, and re-exporting with a proper alpha channel.
</file>

<file path="editor/editor.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Raptor - Level Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            line-height: 1.4;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .editor-panel {
            background-color: #2a2a2a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
        }

        .json-panel {
            background-color: #2a2a2a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            grid-column: 1 / -1;
        }

        h2 {
            color: #00ff00;
            margin-bottom: 15px;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 5px;
        }

        h3 {
            color: #ffff00;
            margin-bottom: 10px;
            margin-top: 15px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #00ff00;
            font-weight: bold;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px;
            background-color: #1a1a1a;
            border: 1px solid #00ff00;
            border-radius: 4px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #ffff00;
            box-shadow: 0 0 5px #ffff00;
        }

        button {
            background-color: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s;
        }

        button:hover {
            background-color: #00ff00;
            color: #000000;
            box-shadow: 0 0 10px #00ff00;
        }

        .wave-section {
            background-color: #333333;
            border: 1px solid #666666;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .enemy-item, .env-object-item {
            background-color: #444444;
            border: 1px solid #777777;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .override-section {
            background-color: #555555;
            border: 1px solid #888888;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }

        .json-output {
            width: 100%;
            height: 600px;
            background-color: #1a1a1a;
            border: 1px solid #00ff00;
            border-radius: 4px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            resize: vertical;
        }

        .level-info {
            background-color: #333333;
            border: 1px solid #666666;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .remove-btn {
            background-color: #660000;
            border-color: #ff0000;
            color: #ff0000;
        }

        .remove-btn:hover {
            background-color: #ff0000;
            color: #000000;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>PROJECT RAPTOR - LEVEL EDITOR</h1>
    
    <div class="container">
        <div class="editor-panel">
            <div class="level-info">
                <h2>Level Information</h2>
                <div class="form-group">
                    <label for="levelName">Level Name:</label>
                    <input type="text" id="levelName" placeholder="Enter level name..." value="New Level">
                </div>
            </div>

            <h2>Wave Configuration</h2>
            <button id="addWaveBtn">Add New Wave</button>
            <div id="wavesContainer"></div>
        </div>

        <div class="json-panel">
            <h2>Generated Level JSON</h2>
            <textarea id="jsonOutput" class="json-output" readonly placeholder="Level JSON will appear here..."></textarea>
        </div>
    </div>

    <script>
        // Global state management
        let levelData = {
            levelName: "New Level",
            waves: []
        };

        // Enemy types (hardcoded for now, but designed for future loading)
        const enemyTypes = [
            'cutter', 'cyclone', 'dart', 'gnat', 'goliath', 
            'mine', 'reaper', 'striker', 'boss_level1'
        ];

        // Environment object types from the documentation
        const environmentObjectTypes = [
            'FUEL_TANK', 'RADAR_DISH', 'BUNKER', 'SILO', 'TURRET_BASE',
            'POWER_STATION', 'WAREHOUSE', 'COMM_TOWER', 'HANGAR', 'SMALL_BUILDING'
        ];

        // Movement and firing patterns (will be loaded from enemyBehaviors.js)
        let movementPatterns = {};
        let firingPatterns = {};

        // Initialize the editor
        function initializeEditor() {
            loadBehaviorPatterns();
            setupEventListeners();
            updateJsonOutput();
        }

        // Load behavior patterns from enemyBehaviors.js
        function loadBehaviorPatterns() {
            // For now, we'll hardcode the patterns based on the file analysis
            // In a real implementation, this would dynamically load from the JS file
            movementPatterns = {
                'default': 'Default movement (straight down)',
                'sine_wave_slow': 'Slow sine wave',
                'sine_wave_fast': 'Fast sine wave',
                'swoop_from_left': 'Swoop from left',
                'swoop_from_right': 'Swoop from right',
                'move_straight_down': 'Move straight down',
                'move_to_point_and_hold': 'Move to point and hold',
                'sweep': 'Side to side sweep',
                'patrol_and_strafe': 'Patrol and strafe',
                'strafe_and_descend': 'Strafe and descend',
                'descend_and_converge': 'Descend and converge',
                'descend_and_veer': 'Descend and veer',
                'descend_and_strafe_right': 'Descend and strafe right',
                'descend_and_strafe_left': 'Descend and strafe left',
                'move_diagonal': 'Move diagonal',
                'slow_homing': 'Slow homing',
                'zigzag': 'Zigzag pattern',
                'strafe_to_x_position': 'Strafe to X position',
                'strafe_out_and_in': 'Strafe out and in',
                'split_and_descend': 'Split and descend',
                'descend_and_diverge': 'Descend and diverge',
                'criss_cross': 'Criss cross',
                'boss_movement': 'Boss movement'
            };

            firingPatterns = {
                'none': 'No firing',
                'single_aimed_shot': 'Single aimed shot',
                'single_straight_shot': 'Single straight shot',
                'three_round_spread': 'Three round spread',
                'fire_straight_missile': 'Fire straight missile',
                'burst_fire': 'Burst fire',
                'wide_v_shot': 'Wide V shot',
                'boss_multi_weapon_fire': 'Boss multi-weapon fire'
            };
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('addWaveBtn').addEventListener('click', addWave);
            document.getElementById('levelName').addEventListener('input', updateLevelName);
        }

        // Update level name
        function updateLevelName() {
            levelData.levelName = document.getElementById('levelName').value;
            updateJsonOutput();
        }

        // Add a new wave
        function addWave() {
            const waveId = `wave_${levelData.waves.length + 1}`;
            const newWave = {
                wave_id: waveId,
                delay_after_previous_wave_ms: 3000,
                enemies: [],
                environment_objects: []
            };
            
            levelData.waves.push(newWave);
            renderWaves();
            updateJsonOutput();
        }

        // Render all waves
        function renderWaves() {
            const container = document.getElementById('wavesContainer');
            container.innerHTML = '';
            
            levelData.waves.forEach((wave, index) => {
                const waveElement = createWaveElement(wave, index);
                container.appendChild(waveElement);
            });
        }

        // Create wave element
        function createWaveElement(wave, index) {
            const waveDiv = document.createElement('div');
            waveDiv.className = 'wave-section';
            waveDiv.innerHTML = `
                <h3>Wave ${index + 1}</h3>
                <div class="grid-2">
                    <div class="form-group">
                        <label>Wave ID:</label>
                        <input type="text" value="${wave.wave_id}" onchange="updateWaveProperty(${index}, 'wave_id', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Delay After Previous Wave (ms):</label>
                        <input type="number" value="${wave.delay_after_previous_wave_ms}" onchange="updateWaveProperty(${index}, 'delay_after_previous_wave_ms', parseInt(this.value))">
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="addEnemyToWave(${index})">Add Enemy</button>
                    <button onclick="addEnvironmentObjectToWave(${index})">Add Environment Object</button>
                    <button class="remove-btn" onclick="removeWave(${index})">Remove Wave</button>
                </div>
                
                <div id="enemies-${index}">
                    <h4>Enemies:</h4>
                    ${renderEnemies(wave.enemies, index)}
                </div>
                
                <div id="env-objects-${index}">
                    <h4>Environment Objects:</h4>
                    ${renderEnvironmentObjects(wave.environment_objects, index)}
                </div>
            `;
            return waveDiv;
        }

        // Render enemies for a wave
        function renderEnemies(enemies, waveIndex) {
            if (enemies.length === 0) {
                return '<p>No enemies in this wave.</p>';
            }
            
            return enemies.map((enemy, enemyIndex) => `
                <div class="enemy-item">
                    <div class="grid-3">
                        <div class="form-group">
                            <label>Type:</label>
                            <select onchange="updateEnemyProperty(${waveIndex}, ${enemyIndex}, 'type', this.value)">
                                ${enemyTypes.map(type => `<option value="${type}" ${enemy.type === type ? 'selected' : ''}>${type}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Spawn X:</label>
                            <input type="number" value="${enemy.spawn_x}" onchange="updateEnemyProperty(${waveIndex}, ${enemyIndex}, 'spawn_x', parseInt(this.value))">
                        </div>
                        <div class="form-group">
                            <label>Spawn Y:</label>
                            <input type="number" value="${enemy.spawn_y}" onchange="updateEnemyProperty(${waveIndex}, ${enemyIndex}, 'spawn_y', parseInt(this.value))">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Delay (ms):</label>
                        <input type="number" value="${enemy.delay}" onchange="updateEnemyProperty(${waveIndex}, ${enemyIndex}, 'delay', parseInt(this.value))">
                    </div>
                    
                    <div class="override-section">
                        <h4>Behavior Overrides</h4>
                        <div class="grid-2">
                            <div class="form-group">
                                <label>Movement Pattern:</label>
                                <select onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'movementPattern', this.value)">
                                    <option value="">Default</option>
                                    ${Object.keys(movementPatterns).map(pattern => `<option value="${pattern}" ${enemy.overrides?.movementPattern === pattern ? 'selected' : ''}>${movementPatterns[pattern]}</option>`).join('')}
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Firing Pattern:</label>
                                <select onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'firingPattern', this.value)">
                                    <option value="">Default</option>
                                    ${Object.keys(firingPatterns).map(pattern => `<option value="${pattern}" ${enemy.overrides?.firingPattern === pattern ? 'selected' : ''}>${firingPatterns[pattern]}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        
                        <div class="grid-3">
                            <div class="form-group">
                                <label>Speed:</label>
                                <input type="number" value="${enemy.overrides?.speed || ''}" placeholder="Default" onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'speed', this.value ? parseInt(this.value) : undefined)">
                            </div>
                            <div class="form-group">
                                <label>Health:</label>
                                <input type="number" value="${enemy.overrides?.health || ''}" placeholder="Default" onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'health', this.value ? parseInt(this.value) : undefined)">
                            </div>
                            <div class="form-group">
                                <label>Fire Rate (ms):</label>
                                <input type="number" value="${enemy.overrides?.fireRate || ''}" placeholder="Default" onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'fireRate', this.value ? parseInt(this.value) : undefined)">
                            </div>
                        </div>
                        
                        <div id="dynamic-overrides-${waveIndex}-${enemyIndex}">
                            ${renderDynamicOverrides(enemy, waveIndex, enemyIndex)}
                        </div>
                    </div>
                    
                    <button class="remove-btn" onclick="removeEnemy(${waveIndex}, ${enemyIndex})">Remove Enemy</button>
                </div>
            `).join('');
        }

        // Render environment objects for a wave
        function renderEnvironmentObjects(envObjects, waveIndex) {
            if (envObjects.length === 0) {
                return '<p>No environment objects in this wave.</p>';
            }
            
            return envObjects.map((obj, objIndex) => `
                <div class="env-object-item">
                    <div class="grid-3">
                        <div class="form-group">
                            <label>Type:</label>
                            <select onchange="updateEnvironmentObjectProperty(${waveIndex}, ${objIndex}, 'type', this.value)">
                                ${environmentObjectTypes.map(type => `<option value="${type}" ${obj.type === type ? 'selected' : ''}>${type}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Spawn X:</label>
                            <input type="number" value="${obj.spawn_x}" onchange="updateEnvironmentObjectProperty(${waveIndex}, ${objIndex}, 'spawn_x', parseInt(this.value))">
                        </div>
                        <div class="form-group">
                            <label>Spawn Y:</label>
                            <input type="number" value="${obj.spawn_y}" onchange="updateEnvironmentObjectProperty(${waveIndex}, ${objIndex}, 'spawn_y', parseInt(this.value))">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Delay (ms):</label>
                        <input type="number" value="${obj.delay}" onchange="updateEnvironmentObjectProperty(${waveIndex}, ${objIndex}, 'delay', parseInt(this.value))">
                    </div>
                    <button class="remove-btn" onclick="removeEnvironmentObject(${waveIndex}, ${objIndex})">Remove Object</button>
                </div>
            `).join('');
        }

        // Update wave property
        function updateWaveProperty(waveIndex, property, value) {
            levelData.waves[waveIndex][property] = value;
            updateJsonOutput();
        }

        // Update enemy property
        function updateEnemyProperty(waveIndex, enemyIndex, property, value) {
            levelData.waves[waveIndex].enemies[enemyIndex][property] = value;
            updateJsonOutput();
        }

        // Update enemy override property
        function updateEnemyOverride(waveIndex, enemyIndex, property, value) {
            if (!levelData.waves[waveIndex].enemies[enemyIndex].overrides) {
                levelData.waves[waveIndex].enemies[enemyIndex].overrides = {};
            }
            
            if (value === undefined || value === '') {
                delete levelData.waves[waveIndex].enemies[enemyIndex].overrides[property];
            } else {
                levelData.waves[waveIndex].enemies[enemyIndex].overrides[property] = value;
            }
            
            // Re-render dynamic overrides if movement or firing pattern changed
            if (property === 'movementPattern' || property === 'firingPattern') {
                const dynamicContainer = document.getElementById(`dynamic-overrides-${waveIndex}-${enemyIndex}`);
                if (dynamicContainer) {
                    dynamicContainer.innerHTML = renderDynamicOverrides(levelData.waves[waveIndex].enemies[enemyIndex], waveIndex, enemyIndex);
                }
            }
            
            updateJsonOutput();
        }

        // Render dynamic override fields based on selected patterns
        function renderDynamicOverrides(enemy, waveIndex, enemyIndex) {
            let html = '';
            const overrides = enemy.overrides || {};
            const movementPattern = overrides.movementPattern;
            const firingPattern = overrides.firingPattern;
            
            // Movement pattern specific overrides
            if (movementPattern) {
                html += '<h5>Movement Pattern Parameters:</h5>';
                
                switch (movementPattern) {
                    case 'move_to_point_and_hold':
                        html += `
                            <div class="grid-3">
                                <div class="form-group">
                                    <label>Formation Point X:</label>
                                    <input type="number" value="${overrides.formation_point?.x || ''}" placeholder="Default" 
                                           onchange="updateFormationPoint(${waveIndex}, ${enemyIndex}, 'x', this.value)">
                                </div>
                                <div class="form-group">
                                    <label>Formation Point Y:</label>
                                    <input type="number" value="${overrides.formation_point?.y || ''}" placeholder="Default" 
                                           onchange="updateFormationPoint(${waveIndex}, ${enemyIndex}, 'y', this.value)">
                                </div>
                                <div class="form-group">
                                    <label>Hold Duration (ms):</label>
                                    <input type="number" value="${overrides.hold_duration_ms || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'hold_duration_ms', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                    case 'descend_and_strafe':
                    case 'descend_and_strafe_right':
                    case 'descend_and_strafe_left':
                        html += `
                            <div class="form-group">
                                <label>Trigger Y:</label>
                                <input type="number" value="${overrides.trigger_y || ''}" placeholder="Default" 
                                       onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'trigger_y', this.value ? parseInt(this.value) : undefined)">
                            </div>
                        `;
                        break;
                    case 'split_and_descend':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Split Direction:</label>
                                    <select onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'split_direction', this.value ? parseInt(this.value) : undefined)">
                                        <option value="">Default</option>
                                        <option value="1" ${overrides.split_direction === 1 ? 'selected' : ''}>Right (1)</option>
                                        <option value="-1" ${overrides.split_direction === -1 ? 'selected' : ''}>Left (-1)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Split Y:</label>
                                    <input type="number" value="${overrides.split_y || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'split_y', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                    case 'strafe_to_x_position':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Target X:</label>
                                    <input type="number" value="${overrides.target_x || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'target_x', this.value ? parseInt(this.value) : undefined)">
                                </div>
                                <div class="form-group">
                                    <label>Strafe Speed:</label>
                                    <input type="number" value="${overrides.strafe_speed || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'strafe_speed', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                    case 'slow_homing':
                        html += `
                            <div class="form-group">
                                <label>Turn Speed:</label>
                                <input type="number" step="0.1" value="${overrides.turn_speed || ''}" placeholder="Default" 
                                       onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'turn_speed', this.value ? parseFloat(this.value) : undefined)">
                            </div>
                        `;
                        break;
                    case 'zigzag':
                        html += `
                            <div class="form-group">
                                <label>Horizontal Speed:</label>
                                <input type="number" value="${overrides.horizontal_speed || ''}" placeholder="Default" 
                                       onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'horizontal_speed', this.value ? parseInt(this.value) : undefined)">
                            </div>
                        `;
                        break;
                    case 'descend_and_converge':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Descend Duration (ms):</label>
                                    <input type="number" value="${overrides.descend_duration_ms || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'descend_duration_ms', this.value ? parseInt(this.value) : undefined)">
                                </div>
                                <div class="form-group">
                                    <label>Converge Speed:</label>
                                    <input type="number" value="${overrides.converge_speed || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'converge_speed', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                    case 'descend_and_veer':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Veer Y:</label>
                                    <input type="number" value="${overrides.veer_y || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'veer_y', this.value ? parseInt(this.value) : undefined)">
                                </div>
                                <div class="form-group">
                                    <label>Converge Speed:</label>
                                    <input type="number" value="${overrides.converge_speed || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'converge_speed', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                    case 'patrol_and_strafe':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Patrol Y:</label>
                                    <input type="number" value="${overrides.patrol_y || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'patrol_y', this.value ? parseInt(this.value) : undefined)">
                                </div>
                                <div class="form-group">
                                    <label>Patrol Duration (ms):</label>
                                    <input type="number" value="${overrides.patrol_duration_ms || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'patrol_duration_ms', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                }
            }
            
            // Firing pattern specific overrides
            if (firingPattern) {
                html += '<h5>Firing Pattern Parameters:</h5>';
                
                switch (firingPattern) {
                    case 'boss_multi_weapon_fire':
                        html += `
                            <div class="grid-2">
                                <div class="form-group">
                                    <label>Cannon Fire Rate (ms):</label>
                                    <input type="number" value="${overrides.cannonFireRate || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'cannonFireRate', this.value ? parseInt(this.value) : undefined)">
                                </div>
                                <div class="form-group">
                                    <label>Missile Fire Rate (ms):</label>
                                    <input type="number" value="${overrides.missileFireRate || ''}" placeholder="Default" 
                                           onchange="updateEnemyOverride(${waveIndex}, ${enemyIndex}, 'missileFireRate', this.value ? parseInt(this.value) : undefined)">
                                </div>
                            </div>
                        `;
                        break;
                }
            }
            
            return html;
        }

        // Update formation point (special case for complex objects)
        function updateFormationPoint(waveIndex, enemyIndex, axis, value) {
            if (!levelData.waves[waveIndex].enemies[enemyIndex].overrides) {
                levelData.waves[waveIndex].enemies[enemyIndex].overrides = {};
            }
            
            if (!levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point) {
                levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point = {};
            }
            
            if (value === '' || value === undefined) {
                delete levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point[axis];
                // If both x and y are empty, remove the formation_point object
                if (Object.keys(levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point).length === 0) {
                    delete levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point;
                }
            } else {
                levelData.waves[waveIndex].enemies[enemyIndex].overrides.formation_point[axis] = parseInt(value);
            }
            
            updateJsonOutput();
        }

        // Update environment object property
        function updateEnvironmentObjectProperty(waveIndex, objIndex, property, value) {
            levelData.waves[waveIndex].environment_objects[objIndex][property] = value;
            updateJsonOutput();
        }

        // Add enemy to wave
        function addEnemyToWave(waveIndex) {
            const newEnemy = {
                type: 'striker',
                spawn_x: 300,
                spawn_y: -50,
                delay: 1000,
                overrides: {}
            };
            
            levelData.waves[waveIndex].enemies.push(newEnemy);
            renderWaves();
            updateJsonOutput();
        }

        // Add environment object to wave
        function addEnvironmentObjectToWave(waveIndex) {
            const newEnvObject = {
                type: 'FUEL_TANK',
                spawn_x: 150,
                spawn_y: 400,
                delay: 0
            };
            
            levelData.waves[waveIndex].environment_objects.push(newEnvObject);
            renderWaves();
            updateJsonOutput();
        }

        // Remove wave
        function removeWave(waveIndex) {
            levelData.waves.splice(waveIndex, 1);
            renderWaves();
            updateJsonOutput();
        }

        // Remove enemy
        function removeEnemy(waveIndex, enemyIndex) {
            levelData.waves[waveIndex].enemies.splice(enemyIndex, 1);
            renderWaves();
            updateJsonOutput();
        }

        // Remove environment object
        function removeEnvironmentObject(waveIndex, objIndex) {
            levelData.waves[waveIndex].environment_objects.splice(objIndex, 1);
            renderWaves();
            updateJsonOutput();
        }

        // Update JSON output
        function updateJsonOutput() {
            // Clean up the data before outputting
            const cleanedData = JSON.parse(JSON.stringify(levelData));
            
            // Remove empty override objects
            cleanedData.waves.forEach(wave => {
                wave.enemies.forEach(enemy => {
                    if (enemy.overrides && Object.keys(enemy.overrides).length === 0) {
                        delete enemy.overrides;
                    }
                });
            });
            
            const jsonOutput = document.getElementById('jsonOutput');
            jsonOutput.value = JSON.stringify(cleanedData, null, 4);
        }

        // Initialize the editor when the page loads
        document.addEventListener('DOMContentLoaded', initializeEditor);
    </script>
</body>
</html>
</file>

<file path="editor/Level Editor Test Results.md">
# Level Editor Test Results

## Test Summary
The Project Raptor Level Editor has been successfully tested and all major functionality is working correctly.

## Features Tested:

### ✅ Basic Structure
- HTML layout loads correctly with retro green terminal styling
- Two-panel layout: editor on left, JSON output on right
- Responsive design works properly

### ✅ Level Information
- Level name input field works
- Real-time JSON generation updates when level name changes

### ✅ Wave Management
- "Add New Wave" button creates new waves successfully
- Wave ID and delay fields are editable
- Waves appear in JSON output with correct structure

### ✅ Enemy Configuration
- "Add Enemy" button creates new enemies in waves
- Enemy type dropdown includes all specified types: cutter, cyclone, dart, gnat, goliath, mine, reaper, striker, boss_level1
- Spawn X, Y, and delay fields work correctly
- Enemy data appears correctly in JSON output

### ✅ Behavior Override System
- Movement pattern dropdown includes all patterns from enemyBehaviors.js
- Firing pattern dropdown includes all patterns from enemyBehaviors.js
- Basic override fields (Speed, Health, Fire Rate) work correctly
- Dynamic override fields appear when specific patterns are selected

### ✅ Dynamic Override Fields Tested
- Selected "Move to point and hold" movement pattern
- Dynamic fields appeared: Formation Point X, Formation Point Y, Hold Duration (ms)
- Fields are properly labeled and functional
- JSON output correctly includes the movementPattern override

### ✅ Environment Objects
- "Add Environment Object" button works correctly
- Environment object type dropdown includes all specified types: FUEL_TANK, RADAR_DISH, BUNKER, SILO, TURRET_BASE, POWER_STATION, WAREHOUSE, COMM_TOWER, HANGAR, SMALL_BUILDING
- Spawn X, Y, and delay fields work correctly
- Environment objects appear correctly in JSON output

### ✅ JSON Output
- Real-time JSON generation works perfectly
- JSON is properly formatted with 4-space indentation
- Empty override objects are cleaned up automatically
- JSON structure matches the LEVEL_DATA_FORMAT.md specification exactly

## JSON Output Example
The editor successfully generated the following JSON structure:
```json
{
    "levelName": "New Level",
    "waves": [
        {
            "wave_id": "wave_1",
            "delay_after_previous_wave_ms": 3000,
            "enemies": [
                {
                    "type": "striker",
                    "spawn_x": 300,
                    "spawn_y": -50,
                    "delay": 1000,
                    "overrides": {
                        "movementPattern": "move_to_point_and_hold"
                    }
                }
            ],
            "environment_objects": [
                {
                    "type": "FUEL_TANK",
                    "spawn_x": 150,
                    "spawn_y": 400,
                    "delay": 0
                }
            ]
        }
    ]
}
```

## Conclusion
The Level Editor is fully functional and meets all requirements specified in the original task. It provides a user-friendly interface for creating complex level configurations with dynamic behavior overrides and generates clean, properly formatted JSON output that matches the game's data format specification.
</file>

<file path="editor/Project Raptor Level Editor - User Guide.md">
# Project Raptor Level Editor - User Guide

## Overview

The Project Raptor Level Editor is a web-based, "Data-Pad" style tool that allows you to visually design levels by adding waves, enemies, and environment objects. The editor generates properly formatted JSON data that can be saved as level files (e.g., `level2.json`) and used directly by the game engine.

## Features

### Data-Driven Design
- Automatically reads enemy behavior patterns from the game's data files
- Smart dropdowns that update when new behaviors are added to the game
- Real-time JSON generation with proper formatting

### User-Friendly Interface
- Clean, form-based interface with retro terminal styling
- No complex drag-and-drop required
- Intuitive workflow for level creation

### Self-Contained
- Single HTML file contains all necessary code
- No external dependencies required
- Works in any modern web browser

## Getting Started

1. Open `editor.html` in your web browser
2. Enter a name for your level in the "Level Name" field
3. Click "Add New Wave" to create your first wave
4. Configure wave properties and add enemies/environment objects
5. Copy the generated JSON from the output panel

## Interface Layout

The editor is divided into two main panels:

### Left Panel - Level Configuration
- **Level Information**: Set the level name
- **Wave Configuration**: Manage waves, enemies, and environment objects

### Right Panel - JSON Output
- **Generated Level JSON**: Real-time display of the complete level data
- Properly formatted with 4-space indentation
- Ready to copy and save as a `.json` file

## Wave Configuration

### Creating Waves
1. Click "Add New Wave" to create a new wave
2. Set the Wave ID (descriptive name for the wave)
3. Set the delay after the previous wave in milliseconds

### Wave Properties
- **Wave ID**: Unique identifier for the wave (e.g., "wave_01_scouts")
- **Delay After Previous Wave**: Time in milliseconds to wait after the previous wave is cleared

## Enemy Configuration

### Adding Enemies
1. Click "Add Enemy" within a wave section
2. Configure the enemy properties
3. Set behavior overrides as needed

### Enemy Properties
- **Type**: Select from available enemy types (cutter, cyclone, dart, gnat, goliath, mine, reaper, striker, boss_level1)
- **Spawn X/Y**: Coordinates where the enemy appears (Y should be negative for off-screen spawning)
- **Delay**: Time in milliseconds to wait after the wave begins before spawning this enemy

### Behavior Overrides

#### Basic Overrides
- **Movement Pattern**: Choose from available movement patterns
- **Firing Pattern**: Choose from available firing patterns
- **Speed**: Override the enemy's default speed
- **Health**: Override the enemy's default health
- **Fire Rate**: Override the enemy's default firing rate (in milliseconds)

#### Dynamic Pattern Parameters
When you select specific movement or firing patterns, additional parameter fields will appear:

**Move to Point and Hold**:
- Formation Point X/Y: Target coordinates for the enemy to move to
- Hold Duration: Time in milliseconds to hold position

**Descend and Strafe Patterns**:
- Trigger Y: Y-coordinate that triggers the strafe behavior

**Split and Descend**:
- Split Direction: 1 for right, -1 for left
- Split Y: Y-coordinate that triggers the split

**Strafe to X Position**:
- Target X: Target X-coordinate to strafe to
- Strafe Speed: Speed of horizontal movement

**Slow Homing**:
- Turn Speed: Rate of turning toward the player

**Zigzag**:
- Horizontal Speed: Speed of horizontal oscillation

**Boss Multi-Weapon Fire**:
- Cannon Fire Rate: Time between cannon shots
- Missile Fire Rate: Time between missile volleys

## Environment Objects

### Adding Environment Objects
1. Click "Add Environment Object" within a wave section
2. Select the object type
3. Set spawn coordinates and delay

### Environment Object Types
- **FUEL_TANK**: Volatile fuel storage (48x48, 25 HP)
- **RADAR_DISH**: Communications array (64x64, 75 HP)
- **BUNKER**: Concrete fortification (80x60, 150 HP)
- **SILO**: Missile launch facility (56x72, 100 HP)
- **TURRET_BASE**: Anti-aircraft turret (40x40, 60 HP)
- **POWER_STATION**: Power generator (72x48, 80 HP)
- **WAREHOUSE**: Supply storage (96x64, 120 HP)
- **COMM_TOWER**: Communication antenna (32x80, 40 HP)
- **HANGAR**: Aircraft storage (120x80, 200 HP)
- **SMALL_BUILDING**: Basic structure (40x32, 30 HP)

### Environment Object Properties
- **Type**: Select from available environment object types
- **Spawn X/Y**: Coordinates where the object is placed (Y should be positive for on-screen placement)
- **Delay**: Time in milliseconds to wait after the wave begins before spawning this object

## JSON Output

The editor generates JSON that follows the exact format specified in `LEVEL_DATA_FORMAT.md`:

```json
{
    "levelName": "Your Level Name",
    "waves": [
        {
            "wave_id": "wave_01",
            "delay_after_previous_wave_ms": 3000,
            "enemies": [
                {
                    "type": "striker",
                    "spawn_x": 300,
                    "spawn_y": -50,
                    "delay": 1000,
                    "overrides": {
                        "movementPattern": "move_to_point_and_hold",
                        "formation_point": { "x": 400, "y": 150 },
                        "hold_duration_ms": 4000
                    }
                }
            ],
            "environment_objects": [
                {
                    "type": "FUEL_TANK",
                    "spawn_x": 150,
                    "spawn_y": 400,
                    "delay": 0
                }
            ]
        }
    ]
}
```

## Best Practices

### Level Design Tips
1. **Start Simple**: Begin with basic enemy types and movement patterns
2. **Test Incrementally**: Create small waves and test them before building complex sequences
3. **Use Delays Effectively**: Stagger enemy spawns to create interesting patterns
4. **Balance Difficulty**: Mix different enemy types and behaviors for varied gameplay

### Coordinate Guidelines
- **Screen Width**: 0-800 pixels (game canvas width)
- **Enemy Spawn Y**: Use negative values (-50 to -100) for off-screen spawning
- **Environment Object Y**: Use positive values (150-500) for on-screen placement
- **Formation Points**: Keep within screen bounds for movement patterns

### Performance Considerations
- Avoid spawning too many enemies simultaneously
- Use appropriate delays between waves to prevent overwhelming the player
- Consider the total number of entities active at once

## Troubleshooting

### Common Issues
- **Empty JSON**: Make sure you've added at least one wave
- **Missing Overrides**: Dynamic override fields only appear when specific patterns are selected
- **Invalid Coordinates**: Ensure spawn coordinates are within reasonable ranges

### Browser Compatibility
- Works in all modern browsers (Chrome, Firefox, Safari, Edge)
- JavaScript must be enabled
- No internet connection required

## Technical Details

### File Structure
The editor is contained in a single `editor.html` file that includes:
- HTML structure for the user interface
- CSS styling for the retro terminal appearance
- JavaScript for all functionality and data management

### Data Management
- Level data is stored in memory as a JavaScript object
- Real-time updates trigger JSON regeneration
- Empty override objects are automatically cleaned up

### Extensibility
The editor is designed to be easily extensible:
- New enemy types can be added to the `enemyTypes` array
- New environment objects can be added to the `environmentObjectTypes` array
- New behavior patterns are automatically detected from `enemyBehaviors.js`

## Support

For technical issues or feature requests, refer to the project documentation or contact the development team.
</file>

<file path="jest.config.js">
// jest.config.js
export default {
  // Use 'jsdom' to simulate a browser environment for tests.
  testEnvironment: 'jsdom',

  // Run the setup file before tests to create the fake browser objects.
  setupFilesAfterEnv: ['./tests/jest-setup.js'],

  // Tell Jest where to find the test files.
  testMatch: [
    '**/tests/**/*.test.js'
  ],
};
</file>

<file path="js/data/shopItems.js">
const shopItems = [
    {
        id: 'ENERGY_MODULE',
        name: 'Energy Module',
        price: 10000,
        description: 'A consumable item that instantly restores 25 points of health.',
        type: 'consumable',
        effect: {
            stat: 'health',
            value: 25
        }
    },
    {
        id: 'PHASE_SHIELD_L1',
        name: 'Phase Shield (Level 1)',
        price: 25000,
        description: 'Equips your ship with a basic, non-recharging shield that can absorb 50 damage.',
        type: 'upgrade',
        effect: {
            stat: 'shield',
            value: 50
        }
    },
    {
        id: 'AUTOCANNON_DEATHRAY',
        name: '"Deathray" Autocannon',
        price: 78800,
        description: 'Upgrades your primary cannon to fire more powerful projectiles.',
        type: 'upgrade',
        effect: {
            stat: 'primaryWeapon',
            value: 'DEATHRAY'
        }
    },
    {
        id: 'WEAPON_AIR_AIR_MISSILE',
        name: 'Air-to-Air Missile',
        price: 63500,
        description: 'Unlocks the powerful Air-to-Air homing missile as a selectable secondary weapon.',
        type: 'unlock',
        effect: {
            stat: 'secondaryWeapon',
            value: 'AIR_AIR_MISSILE'
        }
    },
    {
        id: 'MEGABOMB',
        name: 'MegaBomb',
        price: 15000,
        description: 'A powerful explosive that clears most enemies from the screen. Adds one to your inventory.',
        type: 'consumable',
        effect: {
            stat: 'megabombs',
            value: 1
        }
    }
];

export default shopItems;
</file>

<file path="js/engine/effectManager.js">
export class EffectManager {
    constructor() {
        this.effects = [];
    }

    add(effect) {
        this.effects.push(effect);
    }

    update(deltaTime) {
        // Iterate backwards to safely remove inactive effects
        for (let i = this.effects.length - 1; i >= 0; i--) {
            const effect = this.effects[i];
            effect.update(deltaTime);
            if (!effect.active) {
                this.effects.splice(i, 1);
            }
        }
    }

    render(context) {
        for (const effect of this.effects) {
            effect.render(context);
        }
    }
    
    clear() {
        this.effects = [];
    }
}
</file>

<file path="js/entities/impactEffect.js">
import { Entity } from '../engine/entity.js';

export class ImpactEffect extends Entity {
    constructor(game, x, y) {
        super(game, x, y);
        this.sprite = this.game.assets.getImage('impactEffect');
        this.duration = 100; // Effect lasts for 100ms
        this.timer = 0;
        this.width = 16;
        this.height = 16;
        // Center the effect on the impact point
        this.x -= this.width / 2;
        this.y -= this.height / 2;
    }

    update(deltaTime) {
        this.timer += deltaTime;
        if (this.timer > this.duration) {
            this.active = false; // Mark for removal
        }
    }

    render(context) {
        if (this.sprite && this.active) {
            context.drawImage(this.sprite, this.x, this.y, this.width, this.height);
        }
    }
}
</file>

<file path="js/environment/BackgroundManager.js">
/**
 * Manages the scrolling background by pre-rendering it to an off-screen buffer
 * for improved performance.
 */
export class BackgroundManager {
    constructor(game, backgroundImage, scrollSpeed) {
        this.game = game;
        this.image = backgroundImage;
        this.scrollSpeed = scrollSpeed;

        // Create an off-screen canvas (the buffer)
        this.bufferCanvas = document.createElement('canvas');
        this.bufferCanvas.width = this.game.width;
        this.bufferCanvas.height = this.game.height;
        this.bufferCtx = this.bufferCanvas.getContext('2d');

        // Set initial positions for the two scrolling images
        this.y1 = 0;
        this.y2 = -this.image.height;
    }

    update(deltaTime) {
        // Update the positions of the two images
        const scrollAmount = this.scrollSpeed * (deltaTime / 1000);
        this.y1 += scrollAmount;
        this.y2 += scrollAmount;

        // If an image has scrolled completely off the bottom of the screen,
        // wrap it back to the top.
        if (this.y1 >= this.game.height) {
            this.y1 = this.y2 - this.image.height;
        }
        if (this.y2 >= this.game.height) {
            this.y2 = this.y1 - this.image.height;
        }
    }

    /**
     * Draws the scrolling images to the off-screen buffer first,
     * then draws the buffer to the main visible canvas.
     * @param {CanvasRenderingContext2D} mainContext
     * @param {number} [x=0] - X offset to draw the background
     * @param {number} [y=0] - Y offset to draw the background
     * @param {number} [width=this.game.width] - Width of the background
     * @param {number} [height=this.game.height] - Height of the background
     */
    render(mainContext, x = 0, y = 0, width = this.game.width, height = this.game.height) {
        // Clear the off-screen buffer
        this.bufferCtx.clearRect(0, 0, this.game.width, this.game.height);

        // Draw the two background images onto the buffer
        this.bufferCtx.drawImage(this.image, 0, this.y1, this.game.width, this.image.height);
        this.bufferCtx.drawImage(this.image, 0, this.y2, this.game.width, this.image.height);

        // Now, draw the buffer canvas to the main visible canvas at the specified position and size
        mainContext.drawImage(this.bufferCanvas, x, y, width, height);
    }

    /**
     * Reset the background positions
     */
    reset() {
        this.y1 = 0;
        this.y2 = -this.image.height;
    }

    resize() {
        this.bufferCanvas.width = this.game.width;
        this.bufferCanvas.height = this.game.height;
    }
}
</file>

<file path="js/environment/tilemap.js">
/**
 * Tilemap class
 * Manages the game's tile-based background and environmental objects.
 */
import { Tileset } from './tileset.js';

export class Tilemap {
    constructor(game, tilemapData, scrollSpeed) {
        this.game = game;
        this.tilemapData = tilemapData;
        this.scrollSpeed = scrollSpeed;
        this.environmentObjects = [];
        this.y = 0;
    }

    // Register a destructible object to be managed by the grid
    registerObject(object) {
        this.environmentObjects.push(object);
    }

    update(deltaTime) {
        const scrollAmount = this.scrollSpeed * (deltaTime / 1000);
        this.y += scrollAmount;
        for (const obj of this.environmentObjects) {
            obj.y += scrollAmount;
        }
    }
}
</file>

<file path="js/environment/tileset.js">
/**
 * Tileset class
 * Manages a tileset image and provides methods to extract individual tiles
 */
class Tileset {
    constructor(image) {
        this.image = image;
        
        // Default tile dimensions (can be overridden)
        this.tileWidth = 32;
        this.tileHeight = 32;
        
        // Calculate tiles per row based on image width
        if (this.image) {
            this.tilesPerRow = Math.floor(this.image.width / this.tileWidth);
        } else {
            this.tilesPerRow = 0;
        }
    }

    /**
     * Get the source rectangle for a specific tile ID
     * @param {number} tileId - The tile ID (0-based)
     * @returns {Object} Object containing sx, sy, sWidth, sHeight
     */
    getTileRect(tileId) {
        if (!this.image || tileId < 0) {
            return { sx: 0, sy: 0, sWidth: this.tileWidth, sHeight: this.tileHeight };
        }

        const row = Math.floor(tileId / this.tilesPerRow);
        const col = tileId % this.tilesPerRow;

        return {
            sx: col * this.tileWidth,
            sy: row * this.tileHeight,
            sWidth: this.tileWidth,
            sHeight: this.tileHeight
        };
    }

    /**
     * Set custom tile dimensions
     * @param {number} width - Tile width in pixels
     * @param {number} height - Tile height in pixels
     */
    setTileSize(width, height) {
        this.tileWidth = width;
        this.tileHeight = height;
        
        if (this.image) {
            this.tilesPerRow = Math.floor(this.image.width / this.tileWidth);
        }
    }

    /**
     * Check if the tileset is ready (image loaded)
     * @returns {boolean} True if the tileset is ready
     */
    isReady() {
        return this.image && this.image.complete;
    }
}

export { Tileset };
</file>

<file path="js/utils/logger.js">
// js/utils/logger.js

export const LogLevel = {
  NONE: 0,    // No logs
  INFO: 1,    // Important events (e.g., "Wave 2 Started")
  DEBUG: 2,   // Detailed debugging (e.g., player health, score)
  SPAM: 3,    // Every repetitive, per-frame update
  ERROR: 4,   // Errors and warnings
};

class Logger {
  constructor() {
    // Start with only important info showing by default.
    this.currentLevel = LogLevel.INFO;
  }

  setLevel(level) {
    this.currentLevel = level;
    this.info(`Log level set to: ${Object.keys(LogLevel).find(key => LogLevel[key] === level)}`);
  }

  /**
  * Cycles through the log levels: NONE -> INFO -> DEBUG -> SPAM -> NONE
  */
  cycleLevel() {
      let newLevel = (this.currentLevel + 1) % 4; // Cycles through 0, 1, 2, 3
      this.setLevel(newLevel);
  }

  info(message) {
    if (this.currentLevel >= LogLevel.INFO) {
      console.log(`[INFO] ${message}`);
    }
  }

  debug(message) {
    if (this.currentLevel >= LogLevel.DEBUG) {
      console.log(`[DEBUG] ${message}`);
    }
  }

  spam(message) {
    if (this.currentLevel >= LogLevel.SPAM) {
      console.log(`[SPAM] ${message}`);
    }
  }

  error(message) {
    // Errors should always be shown unless logging is completely off.
    if (this.currentLevel >= LogLevel.INFO) {
      console.error(`[ERROR] ${message}`);
    }
  }
}

// Create a single, global instance of the logger for the whole game to use.
export const logger = new Logger();
</file>

<file path="js/utils/math.js">
/**
 * Clamps a value between a minimum and maximum range.
 * @param {number} value The value to clamp.
 * @param {number} min The minimum allowed value.
 * @param {number} max The maximum allowed value.
 * @returns {number} The clamped value.
 */
export function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
</file>

<file path="test-impact-effect.html">
<!DOCTYPE html>
<html>
<head>
    <title>Impact Effect Test</title>
</head>
<body>
    <h1>Impact Effect System Test</h1>
    <p>This test verifies that the impact effect system is working correctly.</p>
    <div id="test-results"></div>
    
    <script type="module">
        // Test the ImpactEffect class
        import { ImpactEffect } from './js/entities/impactEffect.js';
        import { EffectManager } from './js/engine/effectManager.js';
        
        const results = document.getElementById('test-results');
        
        // Mock game object for testing
        const mockGame = {
            width: 800,
            height: 600,
            assets: {
                getImage: (key) => {
                    // Return a mock image
                    const canvas = document.createElement('canvas');
                    canvas.width = 16;
                    canvas.height = 16;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'yellow';
                    ctx.fillRect(0, 0, 16, 16);
                    return canvas;
                }
            }
        };
        
        try {
            // Test EffectManager
            console.log('Testing EffectManager...');
            const effectManager = new EffectManager();
            
            // Test ImpactEffect creation
            console.log('Testing ImpactEffect creation...');
            const impactEffect = new ImpactEffect(mockGame, 100, 100);
            
            // Test effect manager add
            effectManager.add(impactEffect);
            console.log('Effect added to manager. Total effects:', effectManager.effects.length);
            
            // Test update
            effectManager.update(50); // 50ms
            console.log('Effect updated. Timer:', impactEffect.timer);
            
            // Test render (should not throw error)
            const mockContext = document.createElement('canvas').getContext('2d');
            effectManager.render(mockContext);
            console.log('Effect rendered successfully');
            
            // Test complete lifecycle
            effectManager.update(100); // Should mark effect as inactive
            console.log('Effect should be inactive now:', !impactEffect.active);
            
            // Test cleanup
            effectManager.update(0); // Should remove inactive effects
            console.log('Effects after cleanup:', effectManager.effects.length);
            
            results.innerHTML = '<p style="color: green;">✅ All tests passed! Impact effect system is working correctly.</p>';
            console.log('✅ All impact effect tests passed!');
            
        } catch (error) {
            results.innerHTML = `<p style="color: red;">❌ Test failed: ${error.message}</p>`;
            console.error('❌ Impact effect test failed:', error);
        }
    </script>
</body>
</html>
</file>

<file path="tests/collision.test.js">
import { CollisionSystem } from '../js/engine/collision.js';

describe('CollisionSystem', () => {
  let collisionSystem;

  beforeEach(() => {
    collisionSystem = new CollisionSystem();
  });

  test('checkAABBCollision should return true for overlapping entities', () => {
    const entityA = { x: 10, y: 10, width: 20, height: 20 };
    const entityB = { x: 15, y: 15, width: 20, height: 20 };
    expect(collisionSystem.checkAABBCollision(entityA, entityB)).toBe(true);
  });

  test('checkAABBCollision should return false for non-overlapping entities', () => {
    const entityA = { x: 10, y: 10, width: 20, height: 20 };
    const entityB = { x: 50, y: 50, width: 20, height: 20 };
    expect(collisionSystem.checkAABBCollision(entityA, entityB)).toBe(false);
  });
});
</file>

<file path="tests/enemyFactory.test.js">
import { EnemyFactory } from '../js/entities/enemyFactory.js';
import { Enemy } from '../js/entities/enemy.js';
import { Boss1 } from '../js/entities/boss1.js';

// Mock the dependencies
jest.mock('../js/entities/enemy.js');
jest.mock('../js/entities/boss1.js');
jest.mock('../js/entities/enemy.js');

describe('EnemyFactory', () => {
  let game;
  let factory;

  beforeEach(() => {
    // Clear all instances and calls to constructor and methods before each test
    Enemy.mockClear();
    Boss1.mockClear();

    // Mock game object with necessary properties and methods
    game = {
      entityManager: {
        add: jest.fn(),
      },
      collision: {
        addToGroup: jest.fn(),
      },
    };
    factory = new EnemyFactory(game);
  });

  test('should create an Enemy for type "fighter"', () => {
    const enemyInfo = { type: 'fighter', spawn_x: 100, spawn_y: 100 };
    factory.createEnemy(enemyInfo);
    expect(Enemy).toHaveBeenCalledTimes(1);
  });

  test('should create a Boss1 for type "boss1"', () => {
    const enemyInfo = { type: 'boss1', spawn_x: 100, spawn_y: 100 };
    factory.createEnemy(enemyInfo);
    expect(Boss1).toHaveBeenCalledTimes(1);
  });

  test('should apply health override to the created enemy', () => {
    const enemyInfo = {
      type: 'fighter',
      spawn_x: 100,
      spawn_y: 100,
      overrides: { health: 500 },
    };
    const enemyInstance = factory.createEnemy(enemyInfo);
    // The factory applies the override to the instance *after* creation.
    // We can check if the health property was set.
    // The mock constructor of Enemy needs to return an object so we can check its property.
    const mockEnemyInstance = Enemy.mock.instances[0];
    expect(mockEnemyInstance.health).toBe(500);
  });

  test('should award score to player when enemy is destroyed', () => {
    const { Enemy: ActualEnemy } = jest.requireActual('../js/entities/enemy.js');
    const player = {
      addScore: jest.fn(),
      addMoney: jest.fn(), // Mock addMoney as it is also called
    };
    game.player = player;
    game.assets = { getImage: () => ({}) }; // Mock assets
    game.entityManager = { add: jest.fn() }; // Mock entityManager

    const enemyInfo = {
      type: 'fighter',
      spawn_x: 100,
      spawn_y: 100,
      overrides: { health: 10, scoreValue: 150 },
    };

    // Create a real Enemy instance
    const enemy = new ActualEnemy(game, enemyInfo.spawn_x, enemyInfo.spawn_y, 'fighter', 'enemyFighter', enemyInfo.overrides.health, enemyInfo.overrides.scoreValue);

    // Simulate taking enough damage to be destroyed
    enemy.takeDamage(10);
    enemy.update(0); // Call update to trigger the death logic

    expect(player.addScore).toHaveBeenCalledWith(150);
  });
});
</file>

<file path="tests/jest-setup.js">
// tests/jest-setup.js
window.addEventListener = jest.fn();
window.requestAnimationFrame = jest.fn((cb) => cb());
window.AudioContext = jest.fn().mockImplementation(() => ({
    createGain: jest.fn(() => ({
        connect: jest.fn(),
        gain: { setValueAtTime: jest.fn() },
    })),
    destination: {},
}));

document.getElementById = jest.fn((id) => ({
    getContext: jest.fn(() => ({
        fillRect: jest.fn(),
        clearRect: jest.fn(),
        save: jest.fn(),
        restore: jest.fn(),
        canvas: { width: 800, height: 600 },
    })),
    style: {},
    addEventListener: jest.fn(),
}));
</file>

<file path="tests/math.test.js">
import { clamp } from '../js/utils/math.js';

describe('clamp', () => {
  it('should return the value if it is within the range', () => {
    expect(clamp(50, 0, 100)).toBe(50);
  });

  it('should return the minimum value if the value is less than the minimum', () => {
    expect(clamp(-10, 0, 100)).toBe(0);
  });

  it('should return the maximum value if the value is greater than the maximum', () => {
    expect(clamp(150, 0, 100)).toBe(100);
  });
});
</file>

<file path="tests/mocks/mock-game.js">
import { jest } from '@jest/globals';

export function createMockGame() {
  return {
    entityManager: {
      add: jest.fn(),
      getEnemies: jest.fn(() => []),
    },
    collision: {
      addToGroup: jest.fn(),
      check: jest.fn(() => ({ collisions: [] })),
    },
    assets: {
      get: jest.fn((asset) => {
        if (asset.endsWith('json')) return {};
        return { width: 10, height: 10 };
      }),
    },
    input: {
      isDown: jest.fn(() => false),
    },
    width: 800,
    height: 600,
    // Add any other game properties or methods that Player might need
  };
}
</file>

<file path="tests/player.test.js">
import { Player } from '../js/entities/player.js';
import { createMockGame } from './mocks/mock-game.js';

describe('Player', () => {
  let game;
  let player;

  beforeEach(() => {
    game = createMockGame();
    player = new Player(game, 100, 100);
  });

  test('should have correct initial health', () => {
    expect(player.health).toBe(75);
  });

  test('should have correct initial score', () => {
    expect(player.score).toBe(0);
  });

  test('should have correct initial money', () => {
    expect(player.money).toBe(0);
  });

  test('should have correct initial speed', () => {
    expect(player.speed).toBe(575);
  });
});

describe('Player Interactions', () => {
  let game;
  let player;

  beforeEach(() => {
    game = createMockGame();
    player = new Player(game, 100, 100);
  });

  test('collectHealthPickup should increase health', () => {
    player.health = 50;
    player.collectHealthPickup(25);
    expect(player.health).toBe(75);
  });

  test('collectHealthPickup should not exceed maxHealth', () => {
    player.health = 90;
    player.collectHealthPickup(25);
    expect(player.health).toBe(player.maxHealth);
  });
});
</file>

<file path="tests/projectile.test.js">
import { Projectile } from '../js/entities/projectile.js';

describe('Projectile', () => {
  let game;
  let projectile;

  beforeEach(() => {
    game = {
      projectilePool: {
        release: jest.fn(),
      },
      height: 600,
    };
    projectile = new Projectile(game);
  });

  test('should update its y position based on velocity', () => {
    projectile.activate(100, 100, 0, -500, 10, 'player', null);
    projectile.update(1000); // 1 second
    expect(projectile.y).toBe(100 - 500);
  });
});
</file>

<file path="assets/data/raptor_architecture.md">
# Raptor: Call of the Shadows Reimagining - Game Architecture

## Technology Stack

For our reimagining of Raptor: Call of the Shadows, we use:

### Core Technologies
- **HTML5**: Game structure
- **CSS3**: Styling and effects
- **JavaScript (ES6+)**: Game logic and interactivity

### Game Development Framework
- **HTML5 Canvas API**: Rendering
- **No external game engines**: Lightweight, runs well on low-spec hardware

### Audio
- **Web Audio API**: Sound effects and music

### Development Tools
- **Git**: Version control
- **npm**: Package management
- **ESLint**: Code quality

### Deployment
- **GitHub Pages**: Hosting (if needed)

## Core Architecture

### Modular, Data-Driven Design
- **Entity-Component System (ECS)**: All game objects (player, enemies, projectiles, etc.) are entities with modular components for behavior, rendering, and state.
- **Behavior Library**: All enemy movement and firing patterns are reusable, composable functions (see `enemyBehaviors.js`). These are assigned via level JSON data, making enemy design highly flexible and data-driven.
- **Level & Enemy Data in JSON**: Levels, enemy waves, and behaviors are defined in external JSON files. This enables rapid iteration, easy expansion, and future support for a visual level editor.
- **State Machine**: Clean separation of game states (boot, menu, hangar, gameplay, pause, game over, etc.) for maintainability and scalability.
- **Asset & Audio Management**: Centralized asset loader and a planned robust AudioManager for sound/music with volume controls.
- **Tilemap & Environment System (Planned)**: Future levels will use a tilemap-based system for more complex, interactive environments.

### Example: Data-Driven Enemy
```json
{
  "type": "striker",
  "movementPattern": "move_to_point_and_hold",
  "firingPattern": "single_aimed_shot",
  "spawn": { "x": 100, "y": -50 },
  "overrides": { "hold_duration_ms": 3000 }
}
```

### Layered Rendering
- Multiple canvas layers for backgrounds, entities, projectiles, UI, etc. for performance and visual clarity.

### Save System
- LocalStorage-based save manager for progress, settings, and high scores.

## Development Roadmap

1. **Setup Project Structure** *(Complete)*
2. **Implement Core Engine** *(Complete)*
3. **Create Entity System** *(Complete)*
4. **Implement Game States** *(Complete)*
5. **Develop Level 1** *(Complete)*
6. **Develop Level 2** *(Complete)*
7. **Polish and Optimize** *(In Progress)*
8. **Testing and Deployment** *(In Progress)*
9. **Future Architectural Goals & Features**
   - Refactor to a Generic, Reusable Level Class
   - Implement a Robust AudioManager with volume controls
   - Implement a full Tilemap-based Environment System
   - Design and build the Hangar/Shop System
   - Design and build the Data-Pad Level Editor
   - Design and build a Power-up/Collectibles System

## Summary

The project is now a modular, data-driven shooter with a flexible behavior library, JSON-based level/enemy design, and a clear roadmap for future extensibility and tooling.
</file>

<file path="js/engine/ObjectPool.js">
/**
 * A generic object pool for managing and recycling game objects.
 */
class ObjectPool {
    constructor(objectFactory, initialSize) {
        this.pool = [];
        this.objectFactory = objectFactory;

        // Pre-populate the pool
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(this.objectFactory());
        }
    }

    /**
     * Get an inactive object from the pool.
     */
    get() {
        // Find an available object in the existing pool
        for (let i = 0; i < this.pool.length; i++) {
            if (!this.pool[i].active) {
                return this.pool[i];
            }
        }

        // If no objects are available, expand the pool by one.
        // This is a failsafe; ideally, the initial size is sufficient.
        if (window.DEBUG) { console.warn("ObjectPool expanded. Consider increasing initial size."); }
        const newObject = this.objectFactory();
        this.pool.push(newObject);
        return newObject;
    }

    /**
     * Release an object back into the pool by marking it as inactive.
     * @param {object} obj - The object to release.
     */
    release(obj) {
        obj.active = false;
    }
}

export { ObjectPool };
</file>

<file path="js/entities/environment.js">
/**
 * Environment class
 * Represents environmental objects
 */
import { Entity } from '../engine/entity.js';

class Environment extends Entity {
    constructor(game, x, y, width, height, type) {
        super(game, x, y, width, height);
        
        this.type = type;
        this.sprite = null;
        
        // Load appropriate sprite based on type
        this.loadSprite();
    }
    
    /**
     * Load the appropriate sprit based on type
     */
    loadSprite() {
        switch (this.type) {
            case 'background1':
                this.sprite = this.game.assets.getImage('backgroundLevel1');
                break;
            case 'background2':
                this.sprite = this.game.assets.getImage('backgroundLevel2');
                break;
            // Add more environment types as needed
        }
    }
    
    /**
     * Render the environment element
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        if (this.sprite) {
            context.drawImage(
                this.sprite,
                Math.floor(this.x),
                Math.floor(this.y),
                this.width,
                this.height
            );
        }
    }
}

export { Environment };
</file>

<file path="js/entities/explosion.js">
/**
 * Explosion class
 * Represents explosion effects
 */
import { Entity } from '../engine/entity.js';

class Explosion extends Entity {
    constructor(game, x, y, width, height) {
        super(game, x, y, width, height);
        this.layer = 'explosion';
        
        // Animation properties
        this.sprites = [];
        this.frameX = 0;
        this.frameY = 0;
        this.maxFrames = 8;
        this.frameTimer = 0;
        this.frameInterval = 80; // Faster animation for explosions
        this.currentFrame = 0;
        
        // Load explosion sprites
        this.loadSprites();
    }
    
    /**
     * Load explosion sprites
     */
    loadSprites() {
        // In a real implementation, we would load multiple explosion frames
        // For now, we'll use the two frames we have
        this.sprites.push(this.game.assets.getImage('explosion1'));
        this.sprites.push(this.game.assets.getImage('explosion2'));
    }
    
    /**
     * Update explosion state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Update animation
        this.frameTimer += deltaTime;
        if (this.frameTimer > this.frameInterval) {
            this.frameTimer = 0;
            this.currentFrame++;
            
            // Destroy when animation is complete
            if (this.currentFrame >= this.sprites.length) {
                this.destroy();
            }
        }
    }
    
    /**
     * Render the explosion
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        if (this.currentFrame < this.sprites.length) {
            const sprite = this.sprites[this.currentFrame];
            
            if (sprite) {
                // Add light blend mode for more dramatic effect
                context.globalCompositeOperation = 'lighter';
                
                context.drawImage(
                    sprite,
                    0,
                    0,
                    sprite.width,
                    sprite.height,
                    Math.floor(this.x),
                    Math.floor(this.y),
                    this.width,
                    this.height
                );
                
                // Reset composite operation
                context.globalCompositeOperation = 'source-over';
            }
        }
    }
}

export { Explosion };
</file>

<file path="js/entities/smokeParticle.js">
import { Entity } from '../engine/entity.js';

export class SmokeParticle extends Entity {
    constructor(game, x, y) {
        super(game, x, y, 8, 8); // Start with a small size
        this.layer = 'explosion'; // Render on the same layer as explosions

        // Lifetime properties
        this.lifetime = 500 + Math.random() * 300; // Live for 500-800ms
        this.currentLife = this.lifetime;

        // Visual properties
        this.initialSize = 8;
        this.finalSize = 24;
        this.initialAlpha = 0.5;
    }

    update(deltaTime) {
        this.currentLife -= deltaTime;
        if (this.currentLife <= 0) {
            this.destroy();
        }
        super.update(deltaTime);
    }

    render(context) {
        const lifePercent = this.currentLife / this.lifetime;

        // Interpolate size and alpha over the particle's life
        const currentSize = this.initialSize + (this.finalSize - this.initialSize) * (1 - lifePercent);
        context.globalAlpha = this.initialAlpha * lifePercent;

        // Draw a simple smoke circle
        context.fillStyle = 'rgba(100, 100, 100, 0.8)';
        context.beginPath();
        context.arc(this.x, this.y, currentSize / 2, 0, Math.PI * 2);
        context.fill();

        // Reset global alpha
        context.globalAlpha = 1.0;
    }
}
</file>

<file path="package.json">
{
  "name": "raptor-manus-ai",
  "version": "1.0.0",
  "description": "Raptor: Call of the Shadows Reimagined",
  "main": "js/main.js",
  "scripts": {
    "test": "jest",
    "generate-placeholders": "node js/utils/generatePlaceholders.js"
  },
  "dependencies": {
    "canvas": "^2.11.2"
  },
  "devDependencies": {
    "@babel/core": "^7.28.0",
    "@babel/preset-env": "^7.28.0",
    "babel-jest": "^30.0.4",
    "jest": "^30.0.4",
    "jest-environment-jsdom": "^30.0.4"
  }
}
</file>

<file path="css/style.css">
/* Base Styles */
body, html {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: #000;
}
canvas {
    display: block;
    position: absolute;
    left: 0;
    top: 0;
}
#menu-screen, #shop-screen, #hangar-screen, #game-over-screen, #loading-screen {
    width: 100vw;
    height: 100vh;
    position: absolute;
    left: 0;
    top: 0;
}

/* Game Container */
#game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Canvas Layers */
.game-layer {
    position: absolute;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    -ms-interpolation-mode: nearest-neighbor;
    transform-origin: 0 0;
    background-color: transparent;
}

#background-layer {
    z-index: 1;
}

#environment-layer {
    z-index: 2;
}

#enemy-layer {
    z-index: 3;
}

#projectile-layer {
    z-index: 4;
}

#player-layer {
    z-index: 5;
}

#explosion-layer {
    z-index: 6;
}

#ui-layer {
    z-index: 7;
}

/* Screen overlays */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    font-family: Arial, sans-serif;
    z-index: 10;
}

#loading-screen {
    z-index: 11;
}

#menu-screen {
    z-index: 12;
}

#game-over-screen {
    z-index: 13;
}

#loading-screen.fade-out {
    opacity: 0;
    transition: opacity 0.5s ease-out;
}

#menu-screen, #game-over-screen {
    display: none;
}

/* Remove the media query since we want fullscreen regardless of screen size */
</file>

<file path="generate-placeholders.cjs">
// generate-placeholders.js

const fs = require('fs');
const { createCanvas } = require('canvas');

/**
 * Creates a placeholder image and saves it to a specified path.
 * @param {number} width - The width of the image.
 * @param {number} height - The height of the image.
 * @param {string} text - The text to display on the image.
 * @param {string} outputPath - The path to save the image file.
 */
function generatePlaceholderImage(width, height, text, outputPath) {
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Fill background
    ctx.fillStyle = '#4d1c20'; // A menacing dark red
    ctx.fillRect(0, 0, width, height);

    // Add border
    ctx.strokeStyle = '#8f3d44';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, width, height);

    // Add text
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, width / 2, height / 2);

    // Save the image
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(outputPath, buffer);
}

// --- Images to generate for the BOSS ---
const newImages = [
    { name: 'player_ship_base.png', width: 64, height: 64, dir: 'assets/images/player' },
    { name: 'player_ship_left.png', width: 64, height: 64, dir: 'assets/images/player' },
    { name: 'player_ship_right.png', width: 64, height: 64, dir: 'assets/images/player' },
    // Environment objects for destructible environments
    { name: 'FUEL_TANK.png', width: 48, height: 48, dir: 'assets/images/environment' },
    { name: 'BUNKER.png', width: 80, height: 60, dir: 'assets/images/environment' },
    { name: 'RADAR_DISH.png', width: 64, height: 64, dir: 'assets/images/environment' },
    // Missile weapon
    { name: 'MISSILE.png', width: 12, height: 24, dir: 'assets/images/projectiles' },
    // New projectile sprites
    { name: 'ENEMY_BULLET.png', width: 8, height: 8, dir: 'assets/images/projectiles' },
    { name: 'ENEMY_MISSILE.png', width: 12, height: 24, dir: 'assets/images/projectiles' },
    { name: 'SMOKE_PUFF.png', width: 16, height: 16, dir: 'assets/images/effects' },
    // You can add any other missing files here too
];
// --- Generate the new placeholder images ---
newImages.forEach(img => {
    // Ensure the directory exists
    if (!fs.existsSync(img.dir)) {
        fs.mkdirSync(img.dir, { recursive: true });
    }

    const outputPath = `${img.dir}/${img.name}`;
    if (!fs.existsSync(outputPath)) {
        generatePlaceholderImage(
            img.width,
            img.height,
            img.name.replace('.png', ''),
            outputPath
        );
        console.log(`Generated placeholder: ${outputPath}`);
    }
});

console.log('New placeholder generation complete!');
</file>

<file path="js/engine/collision.js">
/**
 * CollisionSystem class
 * Handles collision detection between game entities
 */
class CollisionSystem {
    constructor() {
        this.collisionGroups = {
            player: [],
            playerProjectiles: [],
            enemies: [],
            enemyProjectiles: [],
            collectibles: [],
            environment: [] // NEW from ManusAI
        };
    }
    
    addToGroup(entity, groupName) {
        if (this.collisionGroups[groupName]) {
            this.collisionGroups[groupName].push(entity);
        }
    }
    
    removeFromGroup(entity, groupName) {
        if (this.collisionGroups[groupName]) {
            const index = this.collisionGroups[groupName].indexOf(entity);
            if (index !== -1) {
                this.collisionGroups[groupName].splice(index, 1);
            }
        }
    }
    
    // This is the essential remove function from your existing code
    remove(entity) {
        for (const groupName in this.collisionGroups) {
            this.removeFromGroup(entity, groupName);
        }
    }
    
    checkCollisions() {
        // Player vs Enemy Projectiles
        this.checkGroupCollision(this.collisionGroups.player, this.collisionGroups.enemyProjectiles, this.handlePlayerEnemyProjectileCollision.bind(this));
        
        // Player vs Enemies
        this.checkGroupCollision(this.collisionGroups.player, this.collisionGroups.enemies, this.handlePlayerEnemyCollision.bind(this));
        
        // Player Projectiles vs Enemies (including missiles)
        this.checkGroupCollision(this.collisionGroups.playerProjectiles, this.collisionGroups.enemies, this.handlePlayerProjectileEnemyCollision.bind(this));
        
        // Regular Player Projectiles vs Environment Objects (excluding missiles)
        this.checkGroupCollision(this.collisionGroups.playerProjectiles, this.collisionGroups.environment, this.handlePlayerProjectileEnvironmentCollision.bind(this));

        // Player vs Collectibles
        this.checkGroupCollision(this.collisionGroups.player, this.collisionGroups.collectibles, this.handlePlayerCollectibleCollision.bind(this));
    }
    
    // This is your superior, backward-looping version of this method
    checkGroupCollision(groupA, groupB, handler) {
        for (let i = groupA.length - 1; i >= 0; i--) {
            for (let j = groupB.length - 1; j >= 0; j--) {
                const entityA = groupA[i];
                const entityB = groupB[j];
                if (entityA && entityB && entityA.active && entityB.active) {
                    if (this.checkAABBCollision(entityA, entityB)) {
                        handler(entityA, entityB);
                    }
                }
            }
        }
    }
    
    checkAABBCollision(entityA, entityB) {
        return (
            entityA.x < entityB.x + entityB.width &&
            entityA.x + entityA.width > entityB.x &&
            entityA.y < entityB.y + entityB.height &&
            entityA.y + entityA.height > entityB.y
        );
    }
    
    handlePlayerEnemyProjectileCollision(player, projectile) {
        player.takeDamage(projectile.damage);
        this.removeFromGroup(projectile, 'enemyProjectiles');
        projectile.destroy();
    }
    
    handlePlayerEnemyCollision(player, enemy) {
        player.takeDamage(enemy.collisionDamage);
        enemy.takeDamage(player.collisionDamage);
    }
    
    handlePlayerProjectileEnemyCollision(projectile, enemy) {
        enemy.takeDamage(projectile.damage);
        
        // Check if this is a missile and handle special missile behavior
        if (projectile.onHitTarget && typeof projectile.onHitTarget === 'function') {
            projectile.onHitTarget(enemy);
        } else {
            // Standard projectile behavior
            this.removeFromGroup(projectile, 'playerProjectiles');
            projectile.destroy();
        }
    }
    
    // This new handler function is from ManusAI
    handlePlayerProjectileEnvironmentCollision(projectile, envObject) {
        // Skip missiles - they only affect air targets
        if (projectile.constructor.name === 'Missile') {
            return;
        }
        
        envObject.takeDamage(projectile.damage, projectile);
        this.removeFromGroup(projectile, 'playerProjectiles');
        projectile.destroy();
    }

    handlePlayerCollectibleCollision(player, collectible) {
        collectible.collect(player);
        this.removeFromGroup(collectible, 'collectibles');
        collectible.destroy();
    }
    
    // Added this useful utility method from the AI's version
    clearAll() {
        Object.keys(this.collisionGroups).forEach(key => {
            this.collisionGroups[key] = [];
        });
    }
}

export { CollisionSystem };
</file>

<file path="js/engine/entity.js">
/**
 * Entity class
 * Base class for all game entities
 */
class Entity {
    constructor(game, x, y, width, height) {
        this.game = game;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.velocityX = 0;
        this.velocityY = 0;
        this.active = true;
        this.isReady = false;
        this.layer = null; // Should be set by subclasses
        this.id = Math.random(); // A simple unique identifier
        
        // Animation properties
        this.sprite = null;
        this.frameX = 0;
        this.frameY = 0;
        this.maxFrames = 1;
        this.frameTimer = 0;
        this.frameInterval = 100; // milliseconds
    }
    
    /**
     * Update the entity state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Update position based on velocity
        this.x += this.velocityX * (deltaTime / 1000);
        this.y += this.velocityY * (deltaTime / 1000);
        
        // Update animation if sprite exists
        if (this.sprite && this.maxFrames > 1) {
            this.frameTimer += deltaTime;
            if (this.frameTimer >= this.frameInterval) {
                this.frameTimer = 0;
                this.frameX = (this.frameX + 1) % this.maxFrames;
            }
        }
    }
    
    /**
     * Render the entity
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        if (!this.isReady) return;

        if (this.sprite) {
            // Use the 5-argument version of drawImage for non-spritesheet images
            context.drawImage(
                this.sprite,
                Math.floor(this.x),
                Math.floor(this.y),
                this.width,
                this.height
            );
        } else {
            // Default rendering for debugging
            context.fillStyle = 'magenta';
            context.fillRect(Math.floor(this.x), Math.floor(this.y), this.width, this.height);
        }
    }
    
    /**
     * Mark the entity for destruction
     */
    destroy() {
        this.active = false;
    }
    
    /**
     * Get the center position of the entity
     * @returns {Object} The center position {x, y}
     */
    getCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
}

/**
 * EntityManager class
 * Manages all game entities
 */
class EntityManager {
    constructor(game) {
        this.game = game;
        this.entities = [];
    }
    
    /**
     * Add an entity to the manager
     * @param {Entity} entity - The entity to add
     * @returns {Entity} The added entity
     */
    add(entity) {
        this.entities.push(entity);
        return entity;
    }
    
    /**
     * Update all entities
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        for (let i = this.entities.length - 1; i >= 0; i--) {
            const entity = this.entities[i];
            
            if (entity.active) {
                entity.update(deltaTime);
            }
            
            if (!entity.active) {
                // Also remove from collision system when destroyed
                if (this.game.collision) {
                    this.game.collision.remove(entity);
                }
                this.entities.splice(i, 1);
            }
        }
    }
    
    /**
     * Render all active entities on their appropriate canvas layers
     * @param {Object} contexts - The canvas rendering contexts
     */
    render(contexts) {
        // --- SYSTEM-LEVEL FIX FOR TRANSPARENCY ---
        // Set the correct composition mode for all entities before drawing.
        // This ensures all PNGs with alpha channels render correctly.
        if (contexts.player) { // Check if the context exists
             contexts.player.globalCompositeOperation = 'source-over';
        }
        if (contexts.enemy) {
             contexts.enemy.globalCompositeOperation = 'source-over';
        }
        if (contexts.projectile) {
             contexts.projectile.globalCompositeOperation = 'source-over';
        }
        if (contexts.explosion) {
             contexts.explosion.globalCompositeOperation = 'source-over';
        }
        // Add more for other layers as needed (e.g., contexts.explosion)
        // -----------------------------------------

        // Now, proceed with the existing rendering loop
        for (const entity of this.entities) {
            if (entity.active && typeof entity.render === 'function') {
                const layer = entity.layer || 'player'; // Default to player layer
                const context = contexts[layer];
                if (context) {
                    entity.render(context);
            }
            }
        }
    }
    
    /**
     * Get all entities of a specific type
     * @param {Function} type - The constructor function of the entity type
     * @returns {Array} Array of entities of the specified type
     */
    getEntitiesByType(type) {
        return this.entities.filter(entity => entity instanceof type && entity.active);
    }
    
    /**
     * Clear all entities
     */
    clear() {
        this.entities = [];
    }
}

export { Entity, EntityManager };
</file>

<file path="js/engine/saveManager.js">
/**
 * SaveManager class
 * Handles saving and loading game progress using the browser's localStorage API.
 * This class manages the persistence of game state between sessions, including
 * player progress, stats, and game time.
 */
import { logger } from '../utils/logger.js';
class SaveManager {
    /**
     * Create a new SaveManager instance
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        // Unique key for storing save data in localStorage
        this.saveKey = 'raptor_manus_save';
    }

    /**
     * Save the current game state to localStorage
     * Saves essential game data including level, player stats, and game time
     * @returns {boolean} True if save was successful, false otherwise
     */
    saveGame() {
        const gameState = this.game.states.game;
        if (!gameState) return false;

        // Create save data object with essential game information
        const saveData = {
            level: gameState.level,
            playerScore: gameState.player ? gameState.player.score : 0,
            playerLives: gameState.player ? gameState.player.lives : 3,
            playerHealth: gameState.player ? gameState.player.health : 100,
            gameTime: gameState.gameTime,
            timestamp: Date.now() // Store save timestamp for future reference
        };

        try {
            // Convert save data to JSON string and store in localStorage
            localStorage.setItem(this.saveKey, JSON.stringify(saveData));
            logger.info('Game saved successfully');
            return true;
        } catch (error) {
            logger.error('Error saving game:', error);
            return false;
        }
    }

    /**
     * Load the saved game state from localStorage
     * @returns {Object|null} The saved game data or null if no save exists or if there was an error
     */
    loadGame() {
        try {
            const saveData = localStorage.getItem(this.saveKey);
            if (!saveData) return null;

            // Parse the JSON string back into an object
            return JSON.parse(saveData);
        } catch (error) {
            logger.error('Error loading game:', error);
            return null;
        }
    }

    /**
     * Check if a saved game exists in localStorage
     * @returns {boolean} True if a saved game exists, false otherwise
     */
    hasSaveGame() {
        return localStorage.getItem(this.saveKey) !== null;
    }

    /**
     * Delete the saved game from localStorage
     * @returns {boolean} True if deletion was successful, false otherwise
     */
    deleteSaveGame() {
        try {
            localStorage.removeItem(this.saveKey);
            logger.info('Save game deleted');
            return true;
        } catch (error) {
            logger.error('Error deleting save game:', error);
            return false;
        }
    }

    /**
     * Apply the loaded save data to the current game state
     * This method restores the game to the state it was in when saved
     * @param {Object} saveData - The saved game data to apply
     */
    applySaveData(saveData) {
        if (!saveData) return;

        const gameState = this.game.states.game;
        if (!gameState) return;

        // Restore the level and initialize the game
        gameState.level = saveData.level;
        gameState.initializeGame();

        // Restore player stats if player exists
        if (gameState.player) {
            gameState.player.score = saveData.playerScore;
            gameState.player.lives = saveData.playerLives;
            gameState.player.health = saveData.playerHealth;
        }

        // Restore game time
        gameState.gameTime = saveData.gameTime;
    }
}

export { SaveManager };
</file>

<file path="js/entities/collectible.js">
/**
 * Collectible class
 * Represents collectible items like power-ups and pickups
 */
import { Entity } from '../engine/entity.js';

class Collectible extends Entity {
    constructor(game, x, y, width, height, type, value) {
        super(game, x, y, width, height);
        this.layer = 'projectile'; // Render on the same layer as projectiles
        
        this.type = type;
        this.value = value;
        this.velocityY = 100; // Collectibles drift downward
        
        // Animation properties
        this.sprite = null;
        this.frameX = 0;
        this.frameY = 0;
        this.maxFrames = 4;
        this.frameTimer = 0;
        this.frameInterval = 150;
        
        // Floating effect
        this.floatOffset = 0;
        this.floatSpeed = 2;
        this.floatAmount = 5;
        
        // Load appropriate sprite based on type
        this.loadSprite();
    }
    
    /**
     * Load the appropriate sprite based on type
     */
    loadSprite() {
        switch (this.type) {
            case 'health':
                this.sprite = this.game.assets.getImage('healthPickup');
                break;
            case 'megabomb':
                this.sprite = this.game.assets.getImage('megabombPickup');
                break;
            case 'weapon':
                // Different weapon pickups would have different sprites
                break;
            case 'money':
                // Money pickup sprite
                break;
        }
    }
    
    /**
     * Update collectible state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Update animation
        this.frameTimer += deltaTime;
        if (this.frameTimer > this.frameInterval) {
            this.frameTimer = 0;
            this.frameX = (this.frameX + 1) % this.maxFrames;
        }
        
        // Update floating effect
        this.floatOffset = Math.sin(Date.now() / 200) * this.floatAmount;
        
        super.update(deltaTime);
        
        // Check if collectible is off screen
        if (this.y > this.game.height + this.height) {
            this.destroy();
        }
    }
    
    /**
     * Render the collectible
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        const renderX = Math.floor(this.x);
        const renderY = Math.floor(this.y + this.floatOffset);
        
        if (this.sprite) {
            context.drawImage(
                this.sprite,
                this.frameX * this.width,
                this.frameY * this.height,
                this.width,
                this.height,
                renderX,
                renderY,
                this.width,
                this.height
            );
            
            // Add glow effect
            this.renderGlow(context, renderX, renderY);
        } else {
            // Default rendering if no sprite is available
            context.fillStyle = this.getColorByType();
            context.fillRect(renderX, renderY, this.width, this.height);
        }
    }
    
    /**
     * Render glow effect around collectible
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     * @param {number} x - X position to render at
     * @param {number} y - Y position to render at
     */
    renderGlow(context, x, y) {
        const glowColor = this.getGlowColor();
        const glowSize = 10;
        
        // Save context state
        context.save();
        
        // Set composite operation for glow
        context.globalCompositeOperation = 'lighter';
        
        // Create radial gradient for glow
        const gradient = context.createRadialGradient(
            x + this.width / 2,
            y + this.height / 2,
            this.width / 3,
            x + this.width / 2,
            y + this.height / 2,
            this.width / 2 + glowSize
        );
        
        gradient.addColorStop(0, glowColor);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        // Draw glow
        context.fillStyle = gradient;
        context.fillRect(
            x - glowSize,
            y - glowSize,
            this.width + glowSize * 2,
            this.height + glowSize * 2
        );
        
        // Restore context state
        context.restore();
    }
    
    /**
     * Get color based on collectible type
     * @returns {string} Color string
     */
    getColorByType() {
        switch (this.type) {
            case 'health': return 'green';
            case 'megabomb': return 'orange';
            case 'weapon': return 'purple';
            case 'money': return 'gold';
            default: return 'white';
        }
    }
    
    /**
     * Get glow color based on collectible type
     * @returns {string} Color string with alpha
     */
    getGlowColor() {
        switch (this.type) {
            case 'health': return 'rgba(0, 255, 0, 0.5)';
            case 'megabomb': return 'rgba(255, 100, 0, 0.5)';
            case 'weapon': return 'rgba(200, 0, 255, 0.5)';
            case 'money': return 'rgba(255, 215, 0, 0.5)';
            default: return 'rgba(255, 255, 255, 0.5)';
        }
    }
    
    /**
     * Apply collectible effect to player
     * @param {Player} player - The player entity
     */
    collect(player) {
        switch (this.type) {
            case 'health':
                player.addHealth(this.value);
                break;
            case 'megabomb':
                player.addMegabomb();
                break;
            case 'weapon':
                // Handle weapon upgrade
                player.upgradePrimaryWeapon();
                break;
            case 'money':
                player.addMoney(this.value);
                break;
        }
        
        // Play pickup sound
        this.game.audio.playSound('pickup');
    }
}

export { Collectible };
</file>

<file path="js/entities/environmentFactory.js">
/**
 * EnvironmentFactory class
 * Factory for creating destructible environmental objects
 */
import { DestructibleObject } from './destructibleObject.js';
import { logger } from '../utils/logger.js';

class EnvironmentFactory {
    constructor(game) {
        this.game = game;
    }

    /**
     * Creates a destructible environment object
     * @param {Object} envInfo - Object containing environment type and position
     * @returns {DestructibleObject|null} The created environment object, or null if type is unknown
     */
    createEnvironmentObject(envInfo) {
        const { type, x, y } = envInfo;

        logger.debug(`ENVIRONMENT FACTORY: Creating ${type} at (${x}, ${y})`);

        try {
            const envObject = new DestructibleObject(this.game, x, y, type);
            
            // Register with game systems
            this.game.entityManager.add(envObject);
            this.game.collision.addToGroup(envObject, 'environment');
            if (this.game.state && this.game.state.level && this.game.state.level.logicalGrid) {
                this.game.state.level.logicalGrid.registerObject(envObject);
            }
            
            logger.debug(`ENVIRONMENT FACTORY: Successfully created ${type}`);
            return envObject;
        } catch (error) {
            logger.error(`ENVIRONMENT FACTORY: Failed to create ${type}:`, error);
            return null;
        }
    }

    /**
     * Creates multiple environment objects from an array
     * @param {Array} envObjects - Array of environment object data
     * @returns {Array} Array of created environment objects
     */
    createEnvironmentObjects(envObjects) {
        const created = [];
        
        envObjects.forEach(envData => {
            const envObject = this.createEnvironmentObject(envData);
            if (envObject) {
                created.push(envObject);
            }
        });
        
        return created;
    }
}

export { EnvironmentFactory };
</file>

<file path="js/entities/homingProjectile.js">
/**
 * HomingProjectile class
 * A projectile that homes in on a target
 */
import { Projectile } from './projectile.js';
import { Explosion } from './explosion.js';

class HomingProjectile extends Projectile {
    /**
     * Create a new homing projectile
     * @param {Game} game - Game instance
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {number} damage - Damage amount
     * @param {string} source - Source of projectile ('player' or 'enemy')
     * @param {Entity} target - Target entity to home in on
     * @param {number} speed - Movement speed
     * @param {number} turnRate - Maximum turning rate in radians per second
     */
    constructor(game, x, y, width, height, damage, source, target, speed, turnRate) {
        // Initialize with zero velocity, we'll calculate it in update
        super(game, x, y, width, height, 0, 0, damage, source);
        this.layer = 'projectile'; // Define the rendering layer
        
        this.target = target;
        this.speed = speed;
        this.turnRate = turnRate;
        this.angle = Math.PI / 2; // Start moving downward
        
        // Homing missiles are now destructible
        this.health = 10; // Can be adjusted for difficulty
        this.maxHealth = 10;
        
        // Override sprite with homing missile sprite
        this.sprite = this.source === 'player' ? 
            this.game.assets.getImage('MISSILE') : 
            this.game.assets.getImage('enemyMissile');
            
        // If no specific missile sprite is available, use a different color
        if (!this.sprite) {
            this.color = this.source === 'player' ? '#00ffff' : '#ff00ff';
        }
        
        // Add to 'enemies' collision group if enemy missile
        if (this.source === 'enemy') {
            this.game.collision.addToGroup(this, 'enemies');
        }
    }
    
    /**
     * Update the homing projectile
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Check if target is still valid
        if (!this.target || !this.target.active) {
            // No target, continue on current trajectory
            super.update(deltaTime);
            return;
        }
        
        // Calculate angle to target
        const targetX = this.target.x + this.target.width / 2;
        const targetY = this.target.y + this.target.height / 2;
        const dx = targetX - (this.x + this.width / 2);
        const dy = targetY - (this.y + this.height / 2);
        const targetAngle = Math.atan2(dy, dx);
        
        // Calculate angle difference
        let angleDiff = targetAngle - this.angle;
        
        // Normalize angle difference to [-PI, PI]
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        // Apply turn rate limit
        const maxTurn = this.turnRate * deltaTime / 1000;
        const turn = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
        
        // Update angle
        this.angle += turn;
        
        // Update velocity based on angle
        this.velocityX = Math.cos(this.angle) * this.speed;
        this.velocityY = Math.sin(this.angle) * this.speed;
        
        // Call parent update
        super.update(deltaTime);
    }
    
    /**
     * Render the homing projectile
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     */
    render(ctx) {
        if (this.sprite) {
            // Save context
            ctx.save();
            
            // Translate to center of projectile
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            
            // Rotate to match movement direction
            ctx.rotate(this.angle + Math.PI / 2); // Add 90 degrees to point sprite in direction of travel
            
            // Draw sprite centered
            ctx.drawImage(
                this.sprite,
                -this.width / 2,
                -this.height / 2,
                this.width,
                this.height
            );
            
            // Restore context
            ctx.restore();
        } else {
            // No sprite, draw a colored triangle
            ctx.save();
            
            // Translate to center of projectile
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            
            // Rotate to match movement direction
            ctx.rotate(this.angle + Math.PI / 2);
            
            // Draw triangle
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(0, -this.height / 2);
            ctx.lineTo(-this.width / 2, this.height / 2);
            ctx.lineTo(this.width / 2, this.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Restore context
            ctx.restore();
        }
    }
    
    /**
     * Take damage (for destructible homing missiles)
     * @param {number} amount
     */
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.destroy();
            // Spawn a small explosion effect
            const explosion = new Explosion(
                this.game,
                this.x + this.width / 2 - 16,
                this.y + this.height / 2 - 16,
                32,
                32
            );
            this.game.entityManager.add(explosion);
            this.game.audio.playSound('explosion');
        }
    }
}

export { HomingProjectile };
</file>

<file path="js/environment/scrolling-background.js">
/**
 * Procedural Environment class
 * Represents a single piece of background terrain (e.g., a rock, a metal plate)
 */
class ProceduralEnvironment {
    constructor(game, y, speed, layer) {
        this.game = game;
        this.x = Math.random() * this.game.width;
        this.y = y;
        this.width = Math.random() * 100 + 50; // Increased width range: 50-150
        this.height = Math.random() * 120 + 60; // Increased height range: 60-180
        this.speed = speed;

        // Layer determines color and speed, creating parallax
        if (layer === 'far') {
            // Darker, slower rocks in the distance
            const darkShade = Math.floor(Math.random() * 30) + 30; // 30-60
            this.color = `rgba(${darkShade}, ${darkShade}, ${darkShade + 20}, 0.3)`; // Slight blue tint, semi-transparent
            this.speed *= 0.3; // Even slower speed for distant layer
        } else {
            // Lighter, faster plates/rocks in the foreground
            const lightShade = Math.floor(Math.random() * 40) + 60; // 60-100
            this.color = `rgba(${lightShade}, ${lightShade}, ${lightShade + 30}, 0.2)`; // More blue tint, more transparent
        }
    }

    update(deltaTime) {
        this.y += this.speed * (deltaTime / 1000);
        // Reset position when it scrolls off the bottom of the screen
        if (this.y > this.game.height) {
            this.y = -this.height;
            this.x = Math.random() * this.game.width;
        }
    }

    render(context) {
        context.fillStyle = this.color;
        // Draw a simple rectangle to represent a terrain piece
        context.fillRect(this.x, this.y, this.width, this.height);
    }

    reset() {
        this.y = Math.random() * this.game.height;
        this.x = Math.random() * this.game.width;
    }
}

/**
 * ScrollingBackground class
 * Creates and manages a multi-layered, procedural, vertically scrolling background
 * to give a better "Raptor" feel.
 */
import { Environment } from '../entities/environment.js';

class ScrollingBackground {
    constructor(game, speed) {
        this.game = game;
        this.speed = speed;
        this.game.mainScrollSpeed = this.speed; // Make scroll speed globally accessible
        this.farLayerObjects = [];   // Slower, darker objects for parallax
        this.nearLayerObjects = [];  // Faster, lighter objects
        this.backgrounds = [];       // Original background images
        this.backgroundHeight = 0;

        // Initialize the background elements
        this.init();
    }

    /**
     * Initialize scrolling background by creating procedural objects
     */
    init() {
        // Initialize original background
        const backgroundImage = this.game.assets.getImage('backgroundLevel1');
        if (backgroundImage) {
            this.backgroundHeight = backgroundImage.height;

            // Create two background instances for seamless scrolling
            const bg1 = new Environment(
                this.game,
                0,
                0,
                this.game.width,
                backgroundImage.height,
                'background1'
            );

            const bg2 = new Environment(
                this.game,
                0,
                -backgroundImage.height,
                this.game.width,
                backgroundImage.height,
                'background1'
            );

            this.backgrounds.push(bg1, bg2);
        }

        const objectCount = 50; // Number of objects per layer

        // Create objects for the "far" layer (distant)
        for (let i = 0; i < objectCount; i++) {
            this.farLayerObjects.push(
                new ProceduralEnvironment(this.game, Math.random() * this.game.height, this.speed, 'far')
            );
        }

        // Create objects for the "near" layer (foreground)
        for (let i = 0; i < objectCount; i++) {
            this.nearLayerObjects.push(
                new ProceduralEnvironment(this.game, Math.random() * this.game.height, this.speed, 'near')
            );
        }
    }

    /**
     * Reset the background to its initial state
     */
    reset() {
        // Reset original backgrounds
        this.backgrounds.forEach(bg => {
            bg.y = bg === this.backgrounds[0] ? 0 : -this.backgroundHeight;
        });

        // Reset procedural objects
        this.farLayerObjects.forEach(obj => obj.reset());
        this.nearLayerObjects.forEach(obj => obj.reset());
    }

    /**
     * Update scrolling background elements
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Update original backgrounds
        this.backgrounds.forEach(bg => {
            bg.y += this.speed * (deltaTime / 1000);

            // Reset position when off screen for seamless scrolling
            if (bg.y >= this.game.height) {
                bg.y = -this.backgroundHeight + (bg.y - this.game.height);
            }
        });

        // Update procedural layers
        this.farLayerObjects.forEach(obj => obj.update(deltaTime));
        this.nearLayerObjects.forEach(obj => obj.update(deltaTime));
    }

    /**
     * Render scrolling background
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        const bgContext = this.game.contexts.background;
        bgContext.clearRect(0, 0, this.game.width, this.game.height);

        // --- START OF THE FIX ---
        // This new logic ensures the main background image always stretches
        // to the full width of the game screen, removing black bars.
        const backgroundImage = this.game.assets.getImage('background1');
        if (backgroundImage) {
            this.backgrounds.forEach(bg => {
                // We manually draw the image here instead of calling bg.render().
                // This lets us force the width to match the current game width.
                bgContext.drawImage(
                    backgroundImage,
                    bg.x,            // The original horizontal position (usually 0)
                    bg.y,            // The calculated vertical position for scrolling
                    this.game.width, // Force the draw width to fill the screen
                    bg.height        // Keep the original height for the image
                );
            });
        }
        // --- END OF THE FIX ---

        // Render the procedural layers on top
        this.farLayerObjects.forEach(obj => obj.render(bgContext));
        this.nearLayerObjects.forEach(obj => obj.render(bgContext));
    }
    /**
     * Update the scroll speed and keep global reference in sync
     * @param {number} newSpeed - The new scroll speed
     */
    setSpeed(newSpeed) {
        this.speed = newSpeed;
        this.game.mainScrollSpeed = this.speed;
    }
}

export { ScrollingBackground };
</file>

<file path="js/states/characterSelect.js">
/**
 * CharacterSelectState class
 * Handles the character creation and selection screen
 */
import { logger } from '../utils/logger.js';
class CharacterSelectState {
    constructor(game) {
        this.game = game;
        this.background = null;
    }
    
    /**
     * Enter the character select state
     */
    enter() {
        logger.info('Entering Character Select State');
        
        // Show character select screen
        document.getElementById('character-select-screen').style.display = 'flex';
        
        // Get background from assets
        this.background = this.game.assets.getImage('characterSelectBackground');
        
        // Set up character select screen
        this.setupCharacterSelectScreen();
    }
    
    /**
     * Set up the character select screen
     */
    setupCharacterSelectScreen() {
        const characterSelectScreen = document.getElementById('character-select-screen');
        characterSelectScreen.innerHTML = '';
        
        // Create main container
        const mainContainer = document.createElement('div');
        mainContainer.style.display = 'flex';
        mainContainer.style.flexDirection = 'column';
        mainContainer.style.alignItems = 'center';
        mainContainer.style.justifyContent = 'center';
        mainContainer.style.width = '100%';
        mainContainer.style.height = '100%';
        mainContainer.style.position = 'relative';
        mainContainer.style.overflow = 'hidden';
        
        // Add background image if available
        if (this.background) {
            const bgImg = document.createElement('img');
            bgImg.src = this.background.src;
            bgImg.style.width = '100%';
            bgImg.style.height = '100%';
            bgImg.style.objectFit = 'cover';
            bgImg.style.position = 'absolute';
            bgImg.style.top = '0';
            bgImg.style.left = '0';
            bgImg.style.zIndex = '1';
            mainContainer.appendChild(bgImg);
        }
        
        // Create overlay for better text readability
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '2';
        mainContainer.appendChild(overlay);
        
        // Create content container
        const contentContainer = document.createElement('div');
        contentContainer.style.display = 'flex';
        contentContainer.style.flexDirection = 'column';
        contentContainer.style.alignItems = 'center';
        contentContainer.style.justifyContent = 'center';
        contentContainer.style.position = 'absolute';
        contentContainer.style.top = '0';
        contentContainer.style.left = '0';
        contentContainer.style.width = '100%';
        contentContainer.style.height = '100%';
        contentContainer.style.zIndex = '3';
        
        // Add title
        const title = document.createElement('h1');
        title.textContent = 'PILOT CREATION';
        title.style.color = 'white';
        title.style.fontSize = '48px';
        title.style.marginBottom = '40px';
        title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        contentContainer.appendChild(title);
        
        // Create form container
        const formContainer = document.createElement('div');
        formContainer.style.display = 'flex';
        formContainer.style.flexDirection = 'column';
        formContainer.style.alignItems = 'center';
        formContainer.style.gap = '20px';
        formContainer.style.marginBottom = '40px';
        
        // Name input section
        const nameSection = document.createElement('div');
        nameSection.style.display = 'flex';
        nameSection.style.flexDirection = 'column';
        nameSection.style.alignItems = 'center';
        nameSection.style.gap = '10px';
        
        const nameLabel = document.createElement('label');
        nameLabel.textContent = 'PILOT NAME:';
        nameLabel.style.color = 'white';
        nameLabel.style.fontSize = '24px';
        nameLabel.style.fontWeight = 'bold';
        nameLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = 'Enter pilot name...';
        nameInput.maxLength = '20';
        nameInput.style.fontSize = '20px';
        nameInput.style.padding = '15px 20px';
        nameInput.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        nameInput.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        nameInput.style.borderRadius = '8px';
        nameInput.style.minWidth = '300px';
        nameInput.style.textAlign = 'center';
        nameInput.style.color = 'white';
        nameInput.style.outline = 'none';
        nameInput.style.transition = 'all 0.2s ease';
        
        nameInput.addEventListener('focus', () => {
            nameInput.style.borderColor = '#ffcc00';
        });
        
        nameInput.addEventListener('blur', () => {
            nameInput.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        // Add Enter key handler to move to callsign
        nameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                callsignInput.focus();
            }
        });
        
        nameSection.appendChild(nameLabel);
        nameSection.appendChild(nameInput);
        
        // Callsign input section
        const callsignSection = document.createElement('div');
        callsignSection.style.display = 'flex';
        callsignSection.style.flexDirection = 'column';
        callsignSection.style.alignItems = 'center';
        callsignSection.style.gap = '10px';
        
        const callsignLabel = document.createElement('label');
        callsignLabel.textContent = 'CALLSIGN:';
        callsignLabel.style.color = 'white';
        callsignLabel.style.fontSize = '24px';
        callsignLabel.style.fontWeight = 'bold';
        callsignLabel.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        const callsignInput = document.createElement('input');
        callsignInput.type = 'text';
        callsignInput.placeholder = 'Enter callsign...';
        callsignInput.maxLength = '12';
        callsignInput.style.fontSize = '20px';
        callsignInput.style.padding = '15px 20px';
        callsignInput.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        callsignInput.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        callsignInput.style.borderRadius = '8px';
        callsignInput.style.minWidth = '300px';
        callsignInput.style.textAlign = 'center';
        callsignInput.style.color = 'white';
        callsignInput.style.outline = 'none';
        callsignInput.style.transition = 'all 0.2s ease';
        
        callsignInput.addEventListener('focus', () => {
            callsignInput.style.borderColor = '#ffcc00';
        });
        
        callsignInput.addEventListener('blur', () => {
            callsignInput.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });

        // Add Enter key handler to create pilot
        callsignInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.createPilot(nameInput.value, callsignInput.value);
            }
        });
        
        callsignSection.appendChild(callsignLabel);
        callsignSection.appendChild(callsignInput);
        
        // Starting funds display
        const fundsDisplay = document.createElement('div');
        fundsDisplay.textContent = 'STARTING FUNDS: $10,000';
        fundsDisplay.style.color = '#ffcc00';
        fundsDisplay.style.fontSize = '20px';
        fundsDisplay.style.marginTop = '20px';
        fundsDisplay.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        formContainer.appendChild(nameSection);
        formContainer.appendChild(callsignSection);
        formContainer.appendChild(fundsDisplay);
        contentContainer.appendChild(formContainer);
        
        // Add continue button
        const continueButton = document.createElement('div');
        continueButton.textContent = 'CREATE PILOT';
        continueButton.style.color = 'white';
        continueButton.style.fontSize = '28px';
        continueButton.style.padding = '15px 30px';
        continueButton.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        continueButton.style.borderRadius = '8px';
        continueButton.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        continueButton.style.cursor = 'pointer';
        continueButton.style.transition = 'all 0.2s ease';
        continueButton.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        // Add hover effect
        continueButton.addEventListener('mouseover', () => {
            continueButton.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            continueButton.style.color = '#ffcc00';
            continueButton.style.textShadow = '0 0 15px #ffcc00';
            continueButton.style.borderColor = '#ffcc00';
        });
        
        continueButton.addEventListener('mouseout', () => {
            continueButton.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            continueButton.style.color = 'white';
            continueButton.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            continueButton.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        // Add click handler
        continueButton.addEventListener('click', () => {
            this.createPilot(nameInput.value, callsignInput.value);
        });
        
        contentContainer.appendChild(continueButton);
        
        // Add instructions
        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.bottom = '20px';
        instructions.style.right = '20px';
        instructions.style.color = '#aaa';
        instructions.style.fontSize = '16px';
        instructions.style.textAlign = 'right';
        instructions.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        instructions.style.padding = '10px';
        instructions.style.borderRadius = '5px';
        instructions.style.border = '1px solid #333';
        instructions.style.zIndex = '4';
        instructions.innerHTML = 'Click fields to enter text<br>ENTER: Move between fields<br>ESC: Back to menu';
        mainContainer.appendChild(instructions);
        
        // Assemble the layout
        mainContainer.appendChild(contentContainer);
        characterSelectScreen.appendChild(mainContainer);
        
        // Focus on name input
        nameInput.focus();
    }
    
    /**
     * Create the pilot and continue to hangar
     */
    createPilot(name, callsign) {
        // Validate inputs
        if (!name.trim()) {
            alert('Please enter a pilot name!');
            return;
        }
        
        if (!callsign.trim()) {
            alert('Please enter a callsign!');
            return;
        }
        
        // Create player data
        const playerData = {
            name: name.trim(),
            callsign: callsign.trim(),
            money: 10000,
            level: 1,
            score: 0,
            lives: 3,
            health: 75,
            shield: 0,
            unlockedWeapons: ['basic'],
            timestamp: Date.now()
        };
        
        // Save to localStorage
        try {
            localStorage.setItem('raptor_manus_save', JSON.stringify(playerData));
            logger.info('Pilot created and saved:', playerData);
        } catch (error) {
            logger.error('Error saving pilot data:', error);
        }
        
        // Set player data in game
        this.game.playerData = playerData;
        
        // Continue to hangar
        this.continueToGame();
    }
    
    /**
     * Continue to the hangar
     */
    continueToGame() {
        document.getElementById('character-select-screen').style.display = 'none';
        this.game.changeState('hangar');
    }
    
    /**
     * Update the character select state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        if (this.game.input.wasKeyJustPressed('Escape')) {
            document.getElementById('character-select-screen').style.display = 'none';
            this.game.changeState('menu');
        }
    }
    
    /**
     * Render the character select screen
     * @param {Object} contexts - Object containing all canvas contexts
     */
    render(contexts) {
        // Character select is rendered using HTML/CSS in the character-select-screen element
    }
    
    /**
     * Exit the character select state
     */
    exit() {
        document.getElementById('character-select-screen').style.display = 'none';
        logger.info('Exiting Character Select State');
    }
}

export { CharacterSelectState };
</file>

<file path="js/states/gameover.js">
/**
 * GameOverState class
 * Handles the game over state
 */
import { logger } from '../utils/logger.js';
class GameOverState {
    constructor(game) {
        this.game = game;
        this.score = 0;
        this.victory = false;
        this.menuOptions = [
            { text: 'Play Again', action: () => this.playAgain() },
            { text: 'Return to Menu', action: () => this.returnToMenu() }
        ];
        this.selectedOption = 0;
        this.keyDelay = 200;
        this.lastKeyTime = 0;
    }
    
    /**
     * Enter the game over state
     */
    enter() {
        logger.info('Entering Game Over State');
        
        // Show game over screen
        document.getElementById('game-over-screen').style.display = 'flex';
        
        // Get player score
        if (this.game.player) {
            this.score = this.game.player.score;
        }
        
        // Check if player completed all levels (victory)
        if (this.game.states.game && this.game.states.game.level > 2) {
            this.victory = true;
        }
        
        // Set up game over screen
        this.setupGameOverScreen();
    }
    
    /**
     * Set up the game over screen
     */
    setupGameOverScreen() {
        const gameOverScreen = document.getElementById('game-over-screen');
        gameOverScreen.innerHTML = '';
        
        // Create game over container
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.alignItems = 'center';
        container.style.justifyContent = 'center';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        
        // Add title
        const title = document.createElement('h1');
        title.textContent = this.victory ? 'Victory!' : 'Game Over';
        title.style.color = this.victory ? '#ffcc00' : '#ff3333';
        title.style.fontSize = '48px';
        title.style.marginBottom = '20px';
        container.appendChild(title);
        
        // Add message
        const message = document.createElement('p');
        message.textContent = this.victory ? 
            'Congratulations! You have completed all levels!' : 
            'Your ship has been destroyed!';
        message.style.color = 'white';
        message.style.fontSize = '24px';
        message.style.marginBottom = '30px';
        container.appendChild(message);
        
        // Add score
        const score = document.createElement('p');
        score.textContent = `Final Score: ${this.score}`;
        score.style.color = '#ffcc00';
        score.style.fontSize = '36px';
        score.style.marginBottom = '40px';
        container.appendChild(score);
        
        // Add menu options
        this.menuOptions.forEach((option, index) => {
            const optionElement = document.createElement('div');
            optionElement.textContent = option.text;
            optionElement.style.color = index === this.selectedOption ? '#ffcc00' : 'white';
            optionElement.style.fontSize = '24px';
            optionElement.style.margin = '10px';
            optionElement.style.cursor = 'pointer';
            optionElement.style.textShadow = index === this.selectedOption ? '0 0 10px #ffcc00' : 'none';
            
            // Add hover effect
            optionElement.addEventListener('mouseover', () => {
                this.selectedOption = index;
                this.updateMenuSelection();
            });
            
            // Add click handler
            optionElement.addEventListener('click', option.action);
            
            container.appendChild(optionElement);
        });
        
        // Add instructions
        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.bottom = '20px';
        instructions.style.color = '#aaa';
        instructions.style.fontSize = '16px';
        instructions.textContent = 'Use Arrow Keys to navigate, Enter to select';
        container.appendChild(instructions);
        
        gameOverScreen.appendChild(container);
    }
    
    /**
     * Update menu selection highlighting
     */
    updateMenuSelection() {
        const gameOverScreen = document.getElementById('game-over-screen');
        const options = gameOverScreen.querySelectorAll('div > div:not(:last-child)');
        
        options.forEach((option, index) => {
            option.style.color = index === this.selectedOption ? '#ffcc00' : 'white';
            option.style.textShadow = index === this.selectedOption ? '0 0 10px #ffcc00' : 'none';
        });
    }
    
    /**
     * Update the game over state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        const now = Date.now();
        
        // Handle keyboard navigation with delay
        if (now - this.lastKeyTime > this.keyDelay) {
            if (this.game.input.isKeyPressed('ArrowUp') || this.game.input.isKeyPressed('w')) {
                this.selectedOption = (this.selectedOption - 1 + this.menuOptions.length) % this.menuOptions.length;
                this.updateMenuSelection();
                this.lastKeyTime = now;
            }
            
            if (this.game.input.isKeyPressed('ArrowDown') || this.game.input.isKeyPressed('s')) {
                this.selectedOption = (this.selectedOption + 1) % this.menuOptions.length;
                this.updateMenuSelection();
                this.lastKeyTime = now;
            }
            
            if (this.game.input.isKeyPressed('Enter') || this.game.input.isKeyPressed(' ')) {
                this.menuOptions[this.selectedOption].action();
                this.lastKeyTime = now;
            }
        }
    }
    
    /**
     * Render the game over state
     */
    render() {
        // Game over is rendered using HTML/CSS in the game-over-screen element
    }
    
    /**
     * Play the game again
     */
    playAgain() {
        // Reset game state
        if (this.game.states.game) {
            this.game.states.game.level = 1;
        }
        
        // Change to game state
        this.game.changeState('game');
    }
    
    /**
     * Return to the main menu
     */
    returnToMenu() {
        this.game.changeState('menu');
    }
    
    /**
     * Exit the game over state
     */
    exit() {
        logger.info('Exiting Game Over State');
        
        // Hide game over screen
        document.getElementById('game-over-screen').style.display = 'none';
    }
}

export { GameOverState };
</file>

<file path="js/states/LoadingState.js">
import { logger } from '../utils/logger.js';

export class LoadingState {
    constructor(game) {
        this.game = game;
        this.loadingProgress = 0;
    }

    /**
     * The main entry point for the state. This will now reliably
     * load all assets and then transition to the next state.
     */
    async enter() {
        logger.info("--- Running Final, Corrected LoadingState ---");
        
        // Set up progress callback
        this.game.assets.setProgressCallback((progress) => {
            this.loadingProgress = progress / 100; // Convert percentage to 0-1 range
        });
        
        // Define all assets in the format expected by AssetManager
        // Only include assets that haven't been loaded yet
        const allAssets = {
            images: {
                // UI & Backgrounds (skip logo as it's already loaded in BootState)
                'menuBackground': 'assets/images/ui/menu_background.png',
                'hangarBackground': 'assets/images/ui/hangar_background.png',
                'shopBackground': 'assets/images/ui/shop_background.png',
                'characterSelectBackground': 'assets/images/ui/character_select_background.png',
                'cutscenePanel1': 'assets/images/ui/Raptor intro cutscene 1.png',
                'cutscenePanel2': 'assets/images/ui/Raptor intro cutscene 2.png',
                'healthBar': 'assets/images/ui/health_bar.png',
                'shieldBar': 'assets/images/ui/shield_bar.png',
                // Player Assets
                'playerShipBase': 'assets/images/player/player_ship_base.png',
                'playerShipLeft': 'assets/images/player/player_ship_left.png',
                'playerShipRight': 'assets/images/player/player_ship_right.png',
                'playerShipThrust': 'assets/images/player/player_ship_thrust.png',
                // Projectile Assets
                'enemyBullet': 'assets/images/projectiles/enemy_projectile.png',
                'MISSILE': 'assets/images/projectiles/player_missile.png',
                'enemyMissile': 'assets/images/projectiles/enemyMissile.png',
                // Enemy Assets
                'enemyStriker': 'assets/images/enemies/striker.png',
                'enemyCyclone': 'assets/images/enemies/cyclone.png',
                'enemyGnat': 'assets/images/enemies/gnat.png',
                'enemyReaper': 'assets/images/enemies/reaper.png',
                'enemyDart': 'assets/images/enemies/dart.png',
                'enemyGoliath': 'assets/images/enemies/goliath.png',
                'enemyCutter': 'assets/images/enemies/cutter.png',
                'enemyMine': 'assets/images/enemies/mine.png',
                'enemyTurret': 'assets/images/enemies/enemy_turret.png',
                'bossLevel1': 'assets/images/enemies/boss_level1.png',
                // Environment & Backgrounds
                'backgroundLevel1': 'assets/images/environment/background_level1.png',
                'tileset_level1': 'assets/images/environment/tileset.png',
                'fuelTank': 'assets/images/environment/FUEL_TANK.png',
                'bunker': 'assets/images/environment/BUNKER.png',
                'radarDish': 'assets/images/environment/RADAR_DISH.png',
                // Effects & Collectibles
                'explosion1': 'assets/images/explosions/explosion_1.png',
                'shieldPickup': 'assets/images/collectibles/shield_pickup.png',
                'megabombPickup': 'assets/images/collectibles/megabomb_pickup.png',
            }
        };
        
        try {
            await this.game.assets.loadAssets(allAssets);
            logger.info("SUCCESS: All assets loaded. Transitioning state...");
            this.game.changeState('introCutscene');
        } catch (error) {
            logger.error("CRITICAL ERROR in LoadingState:", error);
            // Even if loading fails, try to continue to the next state
            this.game.changeState('introCutscene');
        }
    }

    render(contexts) {
        const ctx = contexts.ui;
        ctx.clearRect(0, 0, this.game.width, this.game.height);
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.game.width, this.game.height);
        const barWidth = this.game.width * 0.6;
        const barX = (this.game.width - barWidth) / 2;
        ctx.fillStyle = 'cyan';
        ctx.fillRect(barX, this.game.height / 2, barWidth * this.loadingProgress, 30);
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Loading... ${Math.round(this.loadingProgress * 100)}%`, this.game.width / 2, this.game.height / 2 + 22);
    }

    update(deltaTime) {}
    exit() {}
}
</file>

<file path="js/states/supply.js">
/**
 * SupplyState class
 * Handles the supply shop state for buying items
 */
import { logger } from '../utils/logger.js';
class SupplyState {
    constructor(game) {
        this.game = game;
    }
    
    /**
     * Enter the supply state
     */
    enter() {
        logger.info('Entering Supply State');
        
        // For the simplified version, we'll just return to the game
        // In a full implementation, this would show a shop interface
        this.game.changeState('game');
    }
    
    /**
     * Update the supply state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Not implemented in this simplified version
    }
    
    /**
     * Render the supply state
     */
    render() {
        // Not implemented in this simplified version
    }
    
    /**
     * Exit the supply state
     */
    exit() {
        logger.info('Exiting Supply State');
    }
}

export { SupplyState };
</file>

<file path="js/engine/audio.js">
/**
 * AudioManager class
 * Handles sound effects and music playback using Web Audio API
 */
import { logger } from '../utils/logger.js';
class AudioManager {
    constructor(assetList) {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGainNode = this.audioContext.createGain();
        this.musicGainNode = this.audioContext.createGain();
        this.sfxGainNode = this.audioContext.createGain();

        // Connect nodes: master -> (music/sfx) -> destination
        this.musicGainNode.connect(this.masterGainNode);
        this.sfxGainNode.connect(this.masterGainNode);
        this.masterGainNode.connect(this.audioContext.destination);

        // Default volumes
        this._masterVolume = 1.0;
        this._musicVolume = 0.5;
        this._sfxVolume = 0.7;

        // Apply initial volumes to gain nodes
        this.masterGainNode.gain.value = this._masterVolume;
        this.musicGainNode.gain.value = this._musicVolume;
        this.sfxGainNode.gain.value = this._sfxVolume;

        this.soundBuffers = {}; // Stores AudioBuffer objects for sound effects
        this.musicBuffer = null; // Stores AudioBuffer for current music
        this.currentMusicSource = null; // Current AudioBufferSourceNode for music
        this.musicFadeInterval = null; // For fading music

        this.loadAssets(assetList);
    }

    // --- Volume Control Methods ---

    setMasterVolume(value) {
        this._masterVolume = Math.max(0, Math.min(1, value));
        this.masterGainNode.gain.value = this._masterVolume;
    }

    setMusicVolume(value) {
        this._musicVolume = Math.max(0, Math.min(1, value));
        this.musicGainNode.gain.value = this._musicVolume;
    }

    setSfxVolume(value) {
        this._sfxVolume = Math.max(0, Math.min(1, value));
        this.sfxGainNode.gain.value = this._sfxVolume;
    }

    getMasterVolume() {
        return this._masterVolume;
    }

    getMusicVolume() {
        return this._musicVolume;
    }

    getSfxVolume() {
        return this._sfxVolume;
    }

    // --- Asset Loading ---
    async loadAssets(assetList) {
        logger.info("Loading audio assets...");
        const audioAssets = this.parseAssetListForAudio(assetList);
        const promises = Object.entries(audioAssets).map(([key, path]) => this.loadSound(key, path));
        await Promise.all(promises);
        logger.info("All audio assets loaded.");
    }

    parseAssetListForAudio(assetList) {
        const audioAssets = {};
        // Correctly access the 'audio' object inside the assetList
        if (assetList && assetList.audio) {
            for (const [key, path] of Object.entries(assetList.audio)) {
                audioAssets[key] = path;
            }
        }
        return audioAssets;
    }

    async loadSound(key, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            // Use the key as the sound name
            this.soundBuffers[key] = audioBuffer;
            logger.debug(`Loaded ${key}`);
        } catch (error) {
            logger.error(`Error loading sound ${key} from ${url}:`, error);
        }
    }

    // --- Sound Effect Management ---
    playSound(soundName, pitchVariation = 0.1, xPosition = null) {
        const buffer = this.soundBuffers[soundName];
        if (!buffer) {
            logger.debug(`[AudioManager] Sound not found: '${soundName}'`);
            return;
        }

        const source = this.audioContext.createBufferSource();
        source.buffer = buffer;

        // Apply pitch variation
        const cents = (Math.random() * 2 - 1) * pitchVariation * 100; // +/- pitchVariation cents
        source.detune.value = cents;

        // Create a gain node for this specific sound to apply sfxVolume
        const soundGainNode = this.audioContext.createGain();
        soundGainNode.gain.value = 1.0; // Initial gain, actual volume controlled by sfxGainNode

        // Connect nodes: source -> (panner) -> soundGainNode -> sfxGainNode -> masterGainNode -> destination
        if (xPosition !== null) {
            const panner = this.audioContext.createStereoPanner();
            // Map xPosition (e.g., 0 to 800) to pan value (-1 to 1)
            // Assuming a game width of 800 for now, this can be made dynamic later
            const gameWidth = 800; 
            const panValue = (xPosition / gameWidth) * 2 - 1; // Normalize to -1 to 1
            panner.pan.value = panValue;
            source.connect(panner).connect(soundGainNode);
        } else {
            source.connect(soundGainNode);
        }
        soundGainNode.connect(this.sfxGainNode);

        source.start(0);
        // Clean up source node after it finishes playing
        source.onended = () => {
            source.disconnect();
            soundGainNode.disconnect();
        };
    }

    // --- Music Management ---
    async playMusic(musicName, loop = true) {
        // Stop any currently playing music with fade out
        if (this.currentMusicSource) {
            await this.fadeOutMusic(this.currentMusicSource, 1000); // Fade out over 1 second
            this.currentMusicSource.stop();
            this.currentMusicSource.disconnect();
            this.currentMusicSource = null;
        }

        const buffer = this.soundBuffers[musicName]; // Music is also stored in soundBuffers
        if (!buffer) {
            logger.debug(`[AudioManager] Music not found: '${musicName}'`);
            return;
        }

        this.currentMusicSource = this.audioContext.createBufferSource();
        this.currentMusicSource.buffer = buffer;
        this.currentMusicSource.loop = loop;

        this.currentMusicSource.connect(this.musicGainNode);
        this.currentMusicSource.start(0);

        // Fade in the new music
        this.fadeInMusic(this.currentMusicSource, 1000); // Fade in over 1 second
    }

    stopMusic() {
        if (this.currentMusicSource) {
            this.fadeOutMusic(this.currentMusicSource, 500).then(() => {
                this.currentMusicSource.stop();
                this.currentMusicSource.disconnect();
                this.currentMusicSource = null;
            });
        }
    }

    async fadeOutMusic(source, duration) {
        const initialVolume = this.musicGainNode.gain.value;
        const fadeOutInterval = 50; // ms
        const steps = duration / fadeOutInterval;
        const volumeStep = initialVolume / steps;

        return new Promise(resolve => {
            let currentStep = 0;
            this.musicFadeInterval = setInterval(() => {
                if (currentStep < steps) {
                    this.musicGainNode.gain.value = initialVolume - (volumeStep * currentStep);
                    currentStep++;
                } else {
                    this.musicGainNode.gain.value = 0;
                    clearInterval(this.musicFadeInterval);
                    this.musicFadeInterval = null;
                    resolve();
                }
            }, fadeOutInterval);
        });
    }

    fadeInMusic(source, duration) {
        const targetVolume = this._musicVolume; // Fade in to the set music volume
        this.musicGainNode.gain.value = 0;
        const fadeInInterval = 50; // ms
        const steps = duration / fadeInInterval;
        const volumeStep = targetVolume / steps;

        let currentStep = 0;
        this.musicFadeInterval = setInterval(() => {
            if (currentStep < steps) {
                this.musicGainNode.gain.value = volumeStep * currentStep;
                currentStep++;
            } else {
                this.musicGainNode.gain.value = targetVolume;
                clearInterval(this.musicFadeInterval);
                this.musicFadeInterval = null;
            }
        }, fadeInInterval);
    }

    // Placeholder for mute/unmute if needed, though volume control handles this implicitly
    toggleMute() {
        if (this.masterGainNode.gain.value > 0) {
            this.masterGainNode.gain.value = 0;
            return true; // Muted
        } else {
            this.masterGainNode.gain.value = this._masterVolume; // Restore to previous master volume
            return false; // Unmuted
        }
    }
}

export { AudioManager };
</file>

<file path="js/entities/destructibleObject.js">
/**
 * DestructibleObject class
 * Represents static destructible environmental objects
 */
import { Entity } from '../engine/entity.js';
import { Explosion } from './explosion.js';
import { ImpactEffect } from './impactEffect.js';
import { getEnvironmentData } from '../../assets/data/environmentData.js';
import { logger } from '../utils/logger.js';

class DestructibleObject extends Entity {
    constructor(game, x, y, environmentType, spriteKey) {
        // Get environment data
        const envData = getEnvironmentData(environmentType);
        if (!envData) {
            throw new Error(`Unknown environment type: ${environmentType}`);
        }
        
        super(game, x, y, envData.width, envData.height);
        
        // Set the layer for rendering
        this.layer = 'environment';
        
        // Environment properties
        this.environmentType = environmentType;
        this.environmentData = envData;
        this.maxHealth = envData.health;
        this.health = this.maxHealth;
        this.scoreValue = envData.scoreValue;
        this.explosionSize = envData.explosionSize;
        
        // Load sprite and set ready state
        this.sprite = this.game.assets.getImage(spriteKey);
        if (this.sprite) {
            this.isReady = true;
        } else {
            logger.error(`Failed to load sprite with key "${spriteKey}" for environment object: ${environmentType}.`);
            this.isReady = false;
        }
        
        // Static object - no movement
        this.velocityX = 0;
        this.velocityY = 0;
        
        // Collision properties
        this.collisionGroup = 'environment';
        this.canTakeDamage = true;
        
        // Visual properties
        this.damaged = false;
        this.damageThreshold = this.maxHealth * 0.5; // Show damage at 50% health
    }
    
    /**
     * Update the destructible object
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Move the object down the screen at the same speed as the background
        if (this.game.mainScrollSpeed) {
            this.y += this.game.mainScrollSpeed * (deltaTime / 1000);
        }

        // Call the parent Entity's update method to handle being active, etc.
        super.update(deltaTime);

        // Remove if it goes off the bottom of the screen
        if (this.y > this.game.height + this.height) {
            this.destroy();
        }
        
        // Check if object should show damage
        if (this.health <= this.damageThreshold && !this.damaged) {
            this.damaged = true;
        }
    }
    
    /**
     * Take damage from projectiles or other sources
     * @param {number} damage - Amount of damage to take
     * @param {Entity} sourceProjectile - The projectile that caused the damage (optional)
     */
    takeDamage(damage, sourceProjectile = null) {
        if (!this.canTakeDamage || !this.active) {
            return false;
        }
        
        this.health -= damage;
        
        // Create impact effect at projectile position
        if (sourceProjectile && this.game.currentState && this.game.currentState.effectManager) {
            this.game.currentState.effectManager.add(new ImpactEffect(this.game, sourceProjectile.x, sourceProjectile.y));
        }
        
        // Check if destroyed
        if (this.health <= 0) {
            this.destroyObject();
            return true;
        }
        
        return false;
    }
    
    /**
     * Create a small impact effect when hit
     */
    createImpactEffect() {
        // Create small sparks or debris effect
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;
        
        // Add small explosion effect at impact point
        const smallExplosion = new Explosion(
            this.game,
            centerX - 16,
            centerY - 16,
            32,
            32
        );
        
        this.game.entityManager.add(smallExplosion);
    }
    
    /**
     * Destroy the object and create explosion
     */
    destroyObject() {
        // Add score to player
        if (this.game.currentState && this.game.currentState.player) {
            this.game.currentState.player.addScore(this.scoreValue);
        }
        
        // Create explosion based on size
        this.createExplosion();
        
        // Mark for destruction
        this.destroy();
    }
    
    /**
     * Create explosion effect based on object's explosion size
     */
    createExplosion() {
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;
        
        let explosionWidth, explosionHeight;
        
        // Determine explosion size
        switch (this.explosionSize) {
            case 'small':
                explosionWidth = 48;
                explosionHeight = 48;
                break;
            case 'medium':
                explosionWidth = 80;
                explosionHeight = 80;
                break;
            case 'large':
                explosionWidth = 120;
                explosionHeight = 120;
                break;
            default:
                explosionWidth = 64;
                explosionHeight = 64;
        }
        
        // Create main explosion
        const explosion = new Explosion(
            this.game,
            centerX - explosionWidth / 2,
            centerY - explosionHeight / 2,
            explosionWidth,
            explosionHeight
        );
        
        this.game.entityManager.add(explosion);
        
        // For large explosions, create additional smaller explosions
        if (this.explosionSize === 'large') {
            this.createSecondaryExplosions(centerX, centerY);
        }
    }
    
    /**
     * Create secondary explosions for large objects
     * @param {number} centerX - Center X position
     * @param {number} centerY - Center Y position
     */
    createSecondaryExplosions(centerX, centerY) {
        const numSecondary = 3;
        const radius = 40;
        
        for (let i = 0; i < numSecondary; i++) {
            const angle = (i / numSecondary) * Math.PI * 2;
            const offsetX = Math.cos(angle) * radius;
            const offsetY = Math.sin(angle) * radius;
            
            setTimeout(() => {
                if (this.game.entityManager) {
                    const secondaryExplosion = new Explosion(
                        this.game,
                        centerX + offsetX - 24,
                        centerY + offsetY - 24,
                        48,
                        48
                    );
                    this.game.entityManager.add(secondaryExplosion);
                }
            }, i * 150); // Stagger the secondary explosions
        }
    }
    
    /**
     * Render the destructible object
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    render(context) {
        if (this.sprite) {
            // Apply damage tinting if damaged
            if (this.damaged) {
                context.save();
                context.globalAlpha = 0.8;
                context.filter = 'sepia(100%) hue-rotate(0deg) saturate(200%)';
            }
            
            context.drawImage(
                this.sprite,
                0,
                0,
                this.sprite.width,
                this.sprite.height,
                Math.floor(this.x),
                Math.floor(this.y),
                this.width,
                this.height
            );
            
            if (this.damaged) {
                context.restore();
            }
        } else {
            // Render placeholder based on environment type
            this.renderPlaceholder(context);
        }
        
        // Render health bar for debugging (optional)
        if (this.game.debug) {
            this.renderHealthBar(context);
        }
    }
    
    /**
     * Render a placeholder when sprite is not available
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    renderPlaceholder(context) {
        // Choose color based on environment type
        let color = '#666666'; // Default gray
        
        switch (this.environmentType) {
            case 'FUEL_TANK':
                color = '#FF6600'; // Orange
                break;
            case 'RADAR_DISH':
                color = '#0066FF'; // Blue
                break;
            case 'BUNKER':
                color = '#444444'; // Dark gray
                break;
            case 'SILO':
                color = '#FF0000'; // Red
                break;
            case 'TURRET_BASE':
                color = '#FFFF00'; // Yellow
                break;
            case 'POWER_STATION':
                color = '#00FF00'; // Green
                break;
            default:
                color = '#666666'; // Gray
        }
        
        // Apply damage tinting
        if (this.damaged) {
            context.save();
            context.globalAlpha = 0.7;
        }
        
        // Draw main shape
        context.fillStyle = color;
        context.fillRect(Math.floor(this.x), Math.floor(this.y), this.width, this.height);
        
        // Draw border
        context.strokeStyle = '#000000';
        context.lineWidth = 2;
        context.strokeRect(Math.floor(this.x), Math.floor(this.y), this.width, this.height);
        
        // Draw type indicator
        context.fillStyle = '#FFFFFF';
        context.font = '10px Arial';
        context.textAlign = 'center';
        context.fillText(
            this.environmentType.substring(0, 4),
            Math.floor(this.x + this.width / 2),
            Math.floor(this.y + this.height / 2 + 3)
        );
        
        if (this.damaged) {
            context.restore();
        }
    }
    
    /**
     * Render health bar for debugging
     * @param {CanvasRenderingContext2D} context - The canvas context to render to
     */
    renderHealthBar(context) {
        const barWidth = this.width;
        const barHeight = 4;
        const barX = this.x;
        const barY = this.y - 8;
        
        // Background
        context.fillStyle = '#FF0000';
        context.fillRect(barX, barY, barWidth, barHeight);
        
        // Health
        const healthPercent = this.health / this.maxHealth;
        context.fillStyle = '#00FF00';
        context.fillRect(barX, barY, barWidth * healthPercent, barHeight);
        
        // Border
        context.strokeStyle = '#000000';
        context.lineWidth = 1;
        context.strokeRect(barX, barY, barWidth, barHeight);
    }
    
    /**
     * Check if this object is off screen (override to prevent removal)
     * @returns {boolean} Always false for static objects
     */
    isOffScreen() {
        // Static environment objects should never be removed for being off screen
        return false;
    }
    
    /**
     * Get information about this destructible object
     * @returns {Object} Object information
     */
    getInfo() {
        return {
            type: this.environmentType,
            name: this.environmentData.name,
            health: this.health,
            maxHealth: this.maxHealth,
            scoreValue: this.scoreValue,
            explosionSize: this.explosionSize,
            damaged: this.damaged
        };
    }
}

export { DestructibleObject };
</file>

<file path="js/main.js">
/**
 * Raptor: Call of the Shadows Reimagined
 * Main entry point for the game
 */
logger.info('main.js: Starting to load...');

import { Game } from './engine/game.js';
import { logger } from './utils/logger.js';
logger.info('main.js: Game class imported successfully');

// Function to start the game
function startGame() {
    logger.info('main.js: Starting game...');
    try {
        // Create and start the game
        const game = new Game();
        logger.info('main.js: Game instance created successfully');
        
        // Expose game to window for debugging
        window.game = game;
        
        logger.info('Raptor: Call of the Shadows Reimagined - Game Initialized');
    } catch (error) {
        logger.error('main.js: Error creating game instance:', error);
    }
}

// Check if the window is already loaded
if (document.readyState === 'complete') {
    logger.info('main.js: Window already loaded, starting game immediately');
    startGame();
} else {
    logger.info('main.js: Window not loaded yet, waiting for load event');
    window.addEventListener('load', () => {
        logger.info('main.js: Window load event fired');
        startGame();
    });
}

logger.info('main.js: Event listener added successfully');
</file>

<file path="js/states/boot.js">
/**
 * BootState class
 * Initial game state that sets up the game and loads essential assets
 */
import { logger } from '../utils/logger.js';
class BootState {
    constructor(game) {
        this.game = game;
    }
    
    /**
     * Enter the boot state
     */
    enter() {
        logger.info('Entering Boot State');
        
        // Hide all screens except loading
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'flex';
        
        // Set up asset loading callbacks
        this.game.assets.setProgressCallback(this.updateLoadingProgress.bind(this));
        this.game.assets.setCompleteCallback(() => {
            this.game.changeState('loading');
        });
        
        // Load essential assets
        this.loadEssentialAssets();
    }
    
    /**
     * Update loading progress display
     * @param {number} progress - Loading progress (0-100)
     */
    updateLoadingProgress(progress) {
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.textContent = `Loading... ${Math.floor(progress)}%`;
    }
    
    /**
     * Load essential assets needed before the main loading screen
     */
    loadEssentialAssets() {
        // Load minimal assets needed for the loading screen
        const essentialAssets = {
            images: {
                'logo': 'assets/images/ui/game_logo.png'
            }
        };
        
        this.game.assets.loadAssets(essentialAssets)
            .then(() => {
                // Once essential assets are loaded, move to the loading state
                this.game.changeState('loading');
            })
            .catch(error => {
                logger.error('Error loading essential assets:', error);
                // Show error message on loading screen
                document.getElementById('loading-screen').textContent = 'Error loading game assets. Please refresh the page.';
            });
    }
    
    /**
     * Update the boot state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Nothing to update in boot state
    }
    
    /**
     * Render the boot state
     */
    render() {
        // Clear the screen
        this.game.contexts.ui.clearRect(0, 0, this.game.width, this.game.height);
        
        // Draw loading text
        this.game.contexts.ui.fillStyle = 'white';
        this.game.contexts.ui.font = '24px Arial';
        this.game.contexts.ui.textAlign = 'center';
        this.game.contexts.ui.fillText('Initializing...', this.game.width / 2, this.game.height / 2);
    }
    
    /**
     * Exit the boot state
     */
    exit() {
        logger.info('Exiting Boot State');
        
        // Clear the onComplete callback to prevent it from being triggered later
        this.game.assets.setCompleteCallback(null);
    }
}

export { BootState };
</file>

<file path="js/states/introCutscene.js">
/**
 * IntroCutsceneState class
 * Plays a cinematic intro sequence with images and text overlays
 */
import { logger } from '../utils/logger.js';

export class IntroCutsceneState {
    constructor(game) {
        this.game = game;
        this.script = null;
        this.currentEventIndex = -1;
        this.eventTimer = 0;
        this.lastImage = null; // To keep drawing the image behind the text
        this.lastText = null;
        this.skipListener = this.skip.bind(this);
        this.hasPlayedOnce = false; // Flag to ensure cutscene only plays once
    }

    async enter() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }
        logger.info("Entering IntroCutsceneState");
        
        // If cutscene has already played once, go directly to menu
        if (this.hasPlayedOnce) {
            logger.info("Cutscene already played once, going to menu");
            this.game.changeState('menu');
            return;
        }
        
        // Assets are now loaded upfront in LoadingState, so no need to load gameplay assets here
        
        try {
            logger.info("Loading intro cutscene script...");
            const response = await fetch('assets/data/introCutscene.json');
            this.script = await response.json();
            logger.info("Cutscene script loaded:", this.script);
            this.currentEventIndex = -1;
            this.nextEvent(); // Start the first event
            logger.info("First event started, currentEventIndex:", this.currentEventIndex);
            
            // Add listeners to skip
            window.addEventListener('keydown', this.skipListener);
            window.addEventListener('mousedown', this.skipListener);
        } catch (error) {
            logger.error("Failed to load cutscene script:", error);
            this.hasPlayedOnce = true; // Mark as played even on error
            this.game.changeState('menu');
        }
    }

    exit() {
        logger.info("Exiting IntroCutsceneState");
        // CRITICAL: Remove listeners to prevent them from firing in other states
        window.removeEventListener('keydown', this.skipListener);
        window.removeEventListener('mousedown', this.skipListener);
        
        // Hide the loading screen div when the cutscene ends
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }
    }

    skip() {
        logger.debug("Cutscene event skipped by user.");
        // Force the timer to zero to immediately advance to the next event
        this.eventTimer = 0;
    }

    nextEvent() {
        this.currentEventIndex++;
        logger.debug("nextEvent called, new index:", this.currentEventIndex);
        const currentEvent = this.script.events[this.currentEventIndex];

        if (!currentEvent || currentEvent.type === 'end_scene') {
            logger.info("End of cutscene reached, transitioning to menu");
            this.hasPlayedOnce = true; // Mark cutscene as played
            this.game.changeState('menu');
            return;
        }

        logger.debug("Current event:", currentEvent);
        this.eventTimer = currentEvent.duration;
        
        if (currentEvent.type === 'show_image') {
            this.lastImage = this.game.assets.getImage(currentEvent.asset);
            logger.debug("Loading image for asset:", currentEvent.asset, "Image found:", !!this.lastImage);
            this.lastText = null;
        } else if (currentEvent.type === 'show_image_with_text') {
            this.lastImage = this.game.assets.getImage(currentEvent.asset);
            logger.debug("Loading image for asset:", currentEvent.asset, "Image found:", !!this.lastImage);
            this.lastText = currentEvent.text;
        } else if (currentEvent.type === 'show_text') {
            this.lastText = currentEvent.text;
        }
    }

    update(deltaTime) {
        if (!this.script) return;

        this.eventTimer -= deltaTime;
        if (this.eventTimer <= 0) {
            logger.debug("Event timer expired, advancing to next event");
            this.nextEvent();
        }
    }

    render(contexts) {
        if (!this.script || !this.script.events[this.currentEventIndex]) {
            logger.spam("Render: No script or no current event");
            return;
        }
        
        const ctx = contexts.ui; // Render everything on the top UI layer
        const currentEvent = this.script.events[this.currentEventIndex];

        // Black background as a base
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.game.width, this.game.height);

        // Draw the last displayed image (so text can overlay it)
        if (this.lastImage) {
            ctx.drawImage(this.lastImage, 0, 0, this.game.width, this.game.height);
        }
        
        // Render the text for a 'show_text' or 'show_image_with_text' event
        if (currentEvent.type === 'show_text' || currentEvent.type === 'show_image_with_text') {
            const text = currentEvent.type === 'show_text' ? currentEvent.text : this.lastText;
            ctx.textAlign = 'center';
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 7;
            ctx.fillText(text, this.game.width / 2, this.game.height - 70);
        }
        
        // Handle the fade-to-black transition
        if (currentEvent.type === 'fade_to_black') {
            const progress = 1 - (this.eventTimer / currentEvent.duration);
            ctx.fillStyle = `rgba(0, 0, 0, ${progress})`;
            ctx.fillRect(0, 0, this.game.width, this.game.height);
        }
    }
}
</file>

<file path="js/states/shop.js">
import shopItems from '../data/shopItems.js';
import { logger } from '../utils/logger.js';

class ShopState {
    constructor(game) {
        this.game = game;
        this.items = shopItems;
        this.selectedItemIndex = 0;
    }

    enter() {
        logger.info("Entering Shop State");
        this.setupShopScreen();
    }

    exit() {
        logger.info("Exiting Shop State");
        const shopScreen = document.getElementById('shop-screen');
        if (shopScreen) {
            shopScreen.style.display = 'none';
        }
    }

    update(deltaTime) {
        if (this.game.input.wasKeyJustPressed('ArrowUp') || this.game.input.wasKeyJustPressed('w')) {
            this.selectPreviousItem();
        }
        if (this.game.input.wasKeyJustPressed('ArrowDown') || this.game.input.wasKeyJustPressed('s')) {
            this.selectNextItem();
        }
        if (this.game.input.wasKeyJustPressed('Enter') || this.game.input.wasKeyJustPressed(' ')) {
            this.purchaseSelectedItem();
        }
        if (this.game.input.wasKeyJustPressed('Escape')) {
            this.exitShop();
        }
    }

    setupShopScreen() {
        let shopScreen = document.getElementById('shop-screen');
        if (!shopScreen) {
            shopScreen = document.createElement('div');
            shopScreen.id = 'shop-screen';
            shopScreen.style.position = 'absolute';
            shopScreen.style.top = '0';
            shopScreen.style.left = '0';
            shopScreen.style.width = '100%';
            shopScreen.style.height = '100%';
            shopScreen.style.display = 'flex';
            shopScreen.style.zIndex = '1000';
            document.body.appendChild(shopScreen);
        } else {
            shopScreen.style.display = 'flex';
        }

        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('hangar-screen').style.display = 'none';

        shopScreen.innerHTML = '';

        const shopBackground = this.game.assets.getImage('shopBackground');

        const mainContainer = document.createElement('div');
        mainContainer.style.display = 'flex';
        mainContainer.style.flexDirection = 'column';
        mainContainer.style.alignItems = 'center';
        mainContainer.style.justifyContent = 'center';
        mainContainer.style.width = '100%';
        mainContainer.style.height = '100%';
        mainContainer.style.position = 'relative';
        mainContainer.style.overflow = 'hidden';

        if (shopBackground) {
            const bgImg = document.createElement('img');
            bgImg.src = shopBackground.src;
            bgImg.style.width = '100%';
            bgImg.style.height = '100%';
            bgImg.style.objectFit = 'cover';
            bgImg.style.position = 'absolute';
            bgImg.style.top = '0';
            bgImg.style.left = '0';
            bgImg.style.zIndex = '1';
            mainContainer.appendChild(bgImg);
        } else {
            mainContainer.style.backgroundColor = '#0a1128';
        }

        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '2';
        mainContainer.appendChild(overlay);

        const title = document.createElement('h1');
        title.textContent = 'WEAPONS & SUPPLY';
        title.style.color = 'white';
        title.style.fontSize = '40px';
        title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        title.style.zIndex = '3';
        title.style.position = 'absolute';
        title.style.top = '20px';
        title.style.left = '50%';
        title.style.transform = 'translateX(-50%)';
        mainContainer.appendChild(title);

        let playerMoney = 0;
        if (this.game.player && this.game.player.money !== undefined) {
            playerMoney = this.game.player.money;
        } else if (this.game.playerData && this.game.playerData.money !== undefined) {
            playerMoney = this.game.playerData.money;
        }

        const moneyDisplay = document.createElement('div');
        moneyDisplay.textContent = `Funds: $${playerMoney}`;
        moneyDisplay.style.color = '#ffcc00';
        moneyDisplay.style.fontSize = '24px';
        moneyDisplay.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        moneyDisplay.style.zIndex = '3';
        moneyDisplay.style.position = 'absolute';
        moneyDisplay.style.top = '80px';
        moneyDisplay.style.left = '50%';
        moneyDisplay.style.transform = 'translateX(-50%)';
        mainContainer.appendChild(moneyDisplay);

        // Add health display on middle left side
        let playerHealth = 75; // Default fallback
        if (this.game.player && this.game.player.health !== undefined) {
            playerHealth = this.game.player.health;
        } else if (this.game.playerData && this.game.playerData.health !== undefined) {
            playerHealth = this.game.playerData.health;
        }

        const healthDisplay = document.createElement('div');
        healthDisplay.innerHTML = `
            <div style="color: #ffcc00; font-size: 20px; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">PILOT HEALTH</div>
            <div style="color: white; font-size: 36px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">${playerHealth}/100</div>
        `;
        healthDisplay.style.zIndex = '3';
        healthDisplay.style.position = 'absolute';
        healthDisplay.style.bottom = '80px';
        healthDisplay.style.left = '20px';
        healthDisplay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        healthDisplay.style.padding = '20px';
        healthDisplay.style.borderRadius = '10px';
        healthDisplay.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        healthDisplay.style.textAlign = 'center';
        mainContainer.appendChild(healthDisplay);

        const itemsContainer = document.createElement('div');
        itemsContainer.style.display = 'flex';
        itemsContainer.style.flexDirection = 'column';
        itemsContainer.style.alignItems = 'center';
        itemsContainer.style.justifyContent = 'center';
        itemsContainer.style.position = 'absolute';
        itemsContainer.style.top = '45%';
        itemsContainer.style.left = '50%';
        itemsContainer.style.transform = 'translate(-50%, -50%)';
        itemsContainer.style.zIndex = '3';
        itemsContainer.style.width = '80%';
        itemsContainer.style.maxWidth = '800px';

        this.items.forEach((item, index) => {
            const itemRow = document.createElement('div');
            itemRow.style.display = 'flex';
            itemRow.style.alignItems = 'center';
            itemRow.style.width = '100%';
            itemRow.style.margin = '5px 0';
            itemRow.style.position = 'relative';

            const itemElement = document.createElement('div');
            itemElement.style.display = 'flex';
            itemElement.style.justifyContent = 'space-between';
            itemElement.style.alignItems = 'center';
            itemElement.style.width = '300px';
            itemElement.style.padding = '15px 20px';
            itemElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            itemElement.style.border = '1px solid rgba(255, 255, 255, 0.3)';
            itemElement.style.borderRadius = '8px';
            itemElement.style.cursor = 'pointer';
            itemElement.style.transition = 'all 0.2s ease';
            itemElement.style.color = 'white';
            itemElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';

            const itemName = document.createElement('span');
            itemName.textContent = item.name;
            itemName.style.fontSize = '20px';
            itemName.style.fontWeight = 'bold';

            const itemPrice = document.createElement('span');
            // Get current money dynamically
            let currentMoney = 0;
            if (this.game.player && this.game.player.money !== undefined) {
                currentMoney = this.game.player.money;
            } else if (this.game.playerData && this.game.playerData.money !== undefined) {
                currentMoney = this.game.playerData.money;
            }
            const canAfford = currentMoney >= item.price;
            itemPrice.textContent = `$${item.price}`;
            itemPrice.style.fontSize = '20px';
            itemPrice.style.color = canAfford ? 'white' : '#7D8491';

            itemElement.appendChild(itemName);
            itemElement.appendChild(itemPrice);

            const description = document.createElement('div');
            description.textContent = item.description;
            description.style.color = 'cyan';
            description.style.fontSize = '16px';
            description.style.position = 'absolute';
            description.style.left = '350px';
            description.style.top = '50%';
            description.style.transform = 'translateY(-50%)';
            description.style.maxWidth = '400px';
            description.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            description.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            description.style.padding = '10px';
            description.style.borderRadius = '5px';
            description.style.border = '1px solid #333';
            description.style.display = 'none';
            description.style.zIndex = '10';

            itemElement.addEventListener('mouseover', () => {
                this.selectedItemIndex = index;
                itemElement.style.color = '#ffcc00';
                itemElement.style.textShadow = '0 0 15px #ffcc00';
                itemElement.style.borderColor = '#ffcc00';
                description.style.display = 'block';
            });

            itemElement.addEventListener('mouseout', () => {
                itemElement.style.color = 'white';
                itemElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                itemElement.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                description.style.display = 'none';
            });

            itemElement.addEventListener('click', () => {
                this.selectedItemIndex = index;
                this.purchaseSelectedItem();
            });

            itemRow.appendChild(itemElement);
            itemRow.appendChild(description);
            itemsContainer.appendChild(itemRow);
        });

        mainContainer.appendChild(itemsContainer);

        const instructions = document.createElement('div');
        instructions.innerHTML = 'Arrow Keys: Navigate | Enter: Purchase | Escape: Exit';
        instructions.style.color = '#aaa';
        instructions.style.fontSize = '14px';
        instructions.style.textAlign = 'center';
        instructions.style.position = 'absolute';
        instructions.style.bottom = '50px';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.zIndex = '3';
        instructions.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        instructions.style.padding = '10px';
        instructions.style.borderRadius = '5px';
        instructions.style.border = '1px solid #333';
        mainContainer.appendChild(instructions);

        const backButton = document.createElement('button');
        backButton.textContent = '← Back to Hangar';
        backButton.style.position = 'absolute';
        backButton.style.bottom = '20px';
        backButton.style.left = '20px';
        backButton.style.zIndex = '4';
        backButton.style.padding = '12px 20px';
        backButton.style.fontSize = '16px';
        backButton.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        backButton.style.color = 'white';
        backButton.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        backButton.style.borderRadius = '6px';
        backButton.style.cursor = 'pointer';
        backButton.style.transition = 'all 0.2s ease';
        backButton.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';

        backButton.addEventListener('mouseover', () => {
            backButton.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            backButton.style.color = '#ffcc00';
            backButton.style.textShadow = '0 0 15px #ffcc00';
            backButton.style.borderColor = '#ffcc00';
        });

        backButton.addEventListener('mouseout', () => {
            backButton.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            backButton.style.color = 'white';
            backButton.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            backButton.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });

        backButton.addEventListener('click', () => {
            this.exitShop();
        });

        mainContainer.appendChild(backButton);
        shopScreen.appendChild(mainContainer);
    }

    render(contexts) {
        // Shop is now rendered using HTML/CSS
    }

    selectNextItem() {
        this.selectedItemIndex = (this.selectedItemIndex + 1) % this.items.length;
        this.highlightSelectedItem();
    }

    selectPreviousItem() {
        this.selectedItemIndex = (this.selectedItemIndex - 1 + this.items.length) % this.items.length;
        this.highlightSelectedItem();
    }

    /**
     * Highlight the currently selected item for keyboard navigation
     */
    highlightSelectedItem() {
        const shopScreen = document.getElementById('shop-screen');
        const items = shopScreen.querySelectorAll('div > div > div > div > div');
        
        items.forEach((item, index) => {
            if (index < this.items.length) {
                if (index === this.selectedItemIndex) {
                    item.style.color = '#ffcc00';
                    item.style.textShadow = '0 0 15px #ffcc00';
                    item.style.borderColor = '#ffcc00';
                } else {
                    item.style.color = 'white';
                    item.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
                    item.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                }
            }
        });
    }

    exitShop() {
        this.game.changeState('hangar'); 
    }

    purchaseSelectedItem() {
        const item = this.items[this.selectedItemIndex];
        
        let currentMoney = 0;
        let moneySource = null;
        
        if (this.game.player && this.game.player.money !== undefined) {
            currentMoney = this.game.player.money;
            moneySource = this.game.player;
        } else if (this.game.playerData && this.game.playerData.money !== undefined) {
            currentMoney = this.game.playerData.money;
            moneySource = this.game.playerData;
        } else {
            logger.debug("No money source found - cannot purchase items");
            return;
        }

        if (currentMoney >= item.price) {
            moneySource.money -= item.price;
            
            // Apply effect to both player and playerData if they exist
            if (this.game.player) {
                logger.info(`Purchased ${item.name} for ${item.price}`);
                this.applyItemEffect(this.game.player, item);
            }
            
            // Also apply to playerData for persistence
            if (this.game.playerData) {
                this.applyItemEffect(this.game.playerData, item);
                // Save updated playerData to localStorage
                try {
                    localStorage.setItem('raptor_manus_save', JSON.stringify(this.game.playerData));
                } catch (error) {
                    logger.error('Error saving updated player data:', error);
                }
            }
            
            // Update displays and refresh shop
            this.updateMoneyDisplay();
            this.updateHealthDisplay();
            this.refreshShopDisplay();
        } else {
            logger.debug("Not enough funds!");
        }
    }

    refreshShopDisplay() {
        // Refresh the shop display to update price colors and other dynamic elements
        this.setupShopScreen();
    }

    updateMoneyDisplay() {
        const shopScreen = document.getElementById('shop-screen');
        const moneyDisplay = shopScreen.querySelector('div > div > div:nth-child(3)');
        if (moneyDisplay) {
            let playerMoney = 0;
            if (this.game.player && this.game.player.money !== undefined) {
                playerMoney = this.game.player.money;
            } else if (this.game.playerData && this.game.playerData.money !== undefined) {
                playerMoney = this.game.playerData.money;
            }
            moneyDisplay.textContent = `Funds: $${playerMoney}`;
        }
    }

    updateHealthDisplay() {
        const shopScreen = document.getElementById('shop-screen');
        const healthDisplay = shopScreen.querySelector('div > div > div:nth-child(4)');
        if (healthDisplay) {
            let playerHealth = 75; // Default fallback
            if (this.game.player && this.game.player.health !== undefined) {
                playerHealth = this.game.player.health;
            } else if (this.game.playerData && this.game.playerData.health !== undefined) {
                playerHealth = this.game.playerData.health;
            }
            
            const healthValue = healthDisplay.querySelector('div:nth-child(2)');
            if (healthValue) {
                healthValue.textContent = `${playerHealth}/100`;
            }
        }
    }

    applyItemEffect(player, item) {
        const effect = item.effect;
        switch (item.type) {
            case 'consumable':
                if (effect.stat === 'health') {
                    // For energy module, increase health by 25 up to maximum of 100
                    const currentHealth = player.health || 75;
                    const newHealth = Math.min(100, currentHealth + effect.value);
                    player.health = newHealth;
                    logger.debug(`Energy module applied: ${currentHealth} -> ${newHealth}`);
                } else {
                    player[effect.stat] = (player[effect.stat] || 0) + effect.value;
                }
                break;
            case 'upgrade':
                 player[effect.stat] = effect.value;
                break;
            case 'unlock':
                if (!player.unlockedWeapons.includes(effect.value)) {
                    player.unlockedWeapons.push(effect.value);
                }
                break;
        }
        
        logger.debug(`Applied effect: ${item.name}. New player stats:`, player);
    }
}

export default ShopState;
</file>

<file path="js/utils/generatePlaceholders.js">
// js/utils/generatePlaceholders.js

const fs = require('fs');
const { createCanvas } = require('canvas');
const { logger } = require('./logger.js');

/**
 * Creates a placeholder image and saves it to a specified path.
 * @param {number} width - The width of the image.
 * @param {number} height - The height of the image.
 * @param {string} text - The text to display on the image.
 * @param {string} outputPath - The path to save the image file.
 */
function generatePlaceholderImage(width, height, text, outputPath) {
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // Fill background
    ctx.fillStyle = '#4d1c20'; // A menacing dark red
    ctx.fillRect(0, 0, width, height);

    // Add border
    ctx.strokeStyle = '#8f3d44';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, width, height);

    // Add text
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, width / 2, height / 2);

    // Save the image
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(outputPath, buffer);
    logger.info(`Generated placeholder: ${outputPath}`);
}

// --- List of ALL placeholder images to generate ---
const imagesToGenerate = [
    // Player Ships
    { name: 'player_ship_base.png', width: 64, height: 64, dir: 'assets/images/player' },
    { name: 'player_ship_left.png', width: 64, height: 64, dir: 'assets/images/player' },
    { name: 'player_ship_right.png', width: 64, height: 64, dir: 'assets/images/player' },
    
    // Environment Objects
    { name: 'FUEL_TANK.png', width: 48, height: 48, dir: 'assets/images/environment' },
    { name: 'BUNKER.png', width: 80, height: 60, dir: 'assets/images/environment' },
    { name: 'RADAR_DISH.png', width: 64, height: 64, dir: 'assets/images/environment' }
];

// --- Generate all images ---
imagesToGenerate.forEach(img => {
    // Ensure the directory exists
    if (!fs.existsSync(img.dir)) {
        fs.mkdirSync(img.dir, { recursive: true });
    }

    const outputPath = `${img.dir}/${img.name}`;
    // Only generate if the file doesn't already exist
    if (!fs.existsSync(outputPath)) {
        generatePlaceholderImage(
            img.width,
            img.height,
            img.name.replace('.png', ''),
            outputPath
        );
    }
});

logger.info('Placeholder generation complete!');
</file>

<file path="js/entities/missile.js">
import { Projectile } from './projectile.js';
import { SmokeParticle } from './smokeParticle.js';

export class Missile extends Projectile {
    constructor(game) {
        super(game); // Calls the simple constructor from the base Projectile
        this.width = 16;
        this.height = 32;
        this.smokeTimer = 0;
        this.smokeInterval = 50; // Create smoke every 50ms
    }

    // The activate method is now responsible for all setup
    activate(x, y, damage, owner, initialVelocity, sprite) {
        // Call the base activate method to set common properties
        super.activate(x, y, initialVelocity.x, initialVelocity.y, damage, owner, sprite);

        // Missile-specific properties
        this.acceleration = 1.2;
        this.maxSpeed = 600;
        this.smokeTimer = 0;
    }

    update(deltaTime) {
        if (!this.active) return;

        // Apply acceleration for player missiles
        if (this.owner === 'player') {
            this.velocityY *= this.acceleration;
            if (Math.abs(this.velocityY) > this.maxSpeed) {
                this.velocityY = -this.maxSpeed;
            }
        }

        // Create smoke puff effects
        this.smokeTimer += deltaTime;
        if (this.smokeTimer >= this.smokeInterval) {
            this.createSmokePuff();
            this.smokeTimer = 0;
        }

        // Call the base update method for movement and off-screen check
        super.update(deltaTime);
    }

    createSmokePuff() {
        // Create smoke at the missile's position
        const smokeX = this.x + this.width / 2 + (Math.random() - 0.5) * 8;
        const smokeY = this.y + this.height + (Math.random() - 0.5) * 4;
        
        const smoke = new SmokeParticle(this.game, smokeX, smokeY);
        this.game.entityManager.add(smoke);
    }

    destroy() {
        // Overrides the base destroy to release back to the correct pool
        this.game.missilePool.release(this);
    }
}
</file>

<file path="js/entities/projectile.js">
/**
 * Projectile class
 * Represents projectiles fired by the player and enemies
 */
import { Entity } from '../engine/entity.js';

export class Projectile extends Entity {
    constructor(game) {
        // The constructor is now very simple, only setting default values.
        super(game, 0, 0, 8, 16); // Using placeholder dimensions
        this.active = false; // All projectiles start as inactive in the pool
        this.layer = 'projectile';
    }

    /**
     * "Wakes up" a projectile from the pool and sets its properties for a new shot.
     */
    activate(x, y, velocityX, velocityY, damage, owner, sprite) {
        this.x = x;
        this.y = y;
        this.velocityX = velocityX;
        this.velocityY = velocityY;
        this.damage = damage;
        this.owner = owner;
        this.sprite = sprite; // This can be an image object or null
        this.active = true;
    }

    update(deltaTime) {
        if (!this.active) return; // Do nothing if inactive

        // Standard movement
        this.y += this.velocityY * (deltaTime / 1000);
        this.x += this.velocityX * (deltaTime / 1000);

        // If projectile is off-screen, destroy it (release it back to the pool)
        if (this.y < -this.height || this.y > this.game.height) {
            this.destroy();
        }
    }

    /**
     * Instead of permanently destroying the object, release it back to the pool.
     */
    destroy() {
        this.game.projectilePool.release(this);
    }

    render(context) {
        if (!this.active) return;

        // Ensure proper transparency
        context.globalCompositeOperation = 'source-over';

        // This logic allows for either a sprite or a programmatically drawn rectangle
        if (this.sprite) {
            // --- FIX IS HERE ---
            // We now provide a destination width and height to scale the sprite.
            const renderWidth = this.width;
            const renderHeight = this.height;
            // -------------------

            context.drawImage(
                this.sprite,
                this.x,
                this.y,
                renderWidth,  // Use the full width
                renderHeight  // Use the full height
            );
        } else {
            context.fillStyle = 'white';
            context.fillRect(this.x, this.y, 2, 4); // The tiny rectangle for the machine gun
        }
    }
}
</file>

<file path="js/levels/level2.js">
/**
 * Level2 class
 * Implements the second level of the game with more advanced enemy patterns
 */
import { EnemyFactory } from '../entities/enemyFactory.js';
import { Projectile } from '../entities/projectile.js';
import { HomingProjectile } from '../entities/homingProjectile.js';
import { BackgroundManager } from '../environment/BackgroundManager.js';
import { Collectible } from '../entities/collectible.js';
import { Enemy } from '../entities/enemy.js';
import { logger } from '../utils/logger.js';

class Level2 {
    constructor(game) {
        this.game = game;
        this.levelData = null;
        this.background = null;
        this.enemyFactory = null;
        this.spawnQueue = [];
        this.collectibleQueue = [];
        this.waveIndex = 0;
        this.levelTime = 0;
        this.waveStartTime = 0;
        this.bossSpawned = false;
        this.bossDefeated = false;
        this.levelComplete = false;
        this.terrainElements = [];
    }
    
    /**
     * Initialize the level
     */
    init() {
        // Load level data
        this.loadLevelData();
        
        // Create scrolling background
        const bgImage = this.game.assets.getImage('backgroundLevel2'); // Use the correct key
        this.background = new BackgroundManager(this.game, bgImage, 60); // Slightly faster scrolling
        
        // Create enemy factory
        this.enemyFactory = new EnemyFactory(this.game);
        
        // Create terrain elements
        this.createTerrainElements();
        
        // Reset level state
        this.spawnQueue = [];
        this.collectibleQueue = [];
        this.waveIndex = 0;
        this.levelTime = 0;
        this.waveStartTime = 0;
        this.bossSpawned = false;
        this.bossDefeated = false;
        this.levelComplete = false;
        
        // Play level music
        this.game.audio.playMusic('gameMusic2');
    }
    
    /**
     * Create terrain elements for level 2
     */
    createTerrainElements() {
        // Create terrain obstacles
        const terrainData = [
            { type: 'building', x: 100, y: -300, width: 80, height: 120, delay: 5000 },
            { type: 'building', x: 600, y: -400, width: 80, height: 120, delay: 8000 },
            { type: 'radar', x: 300, y: -600, width: 60, height: 60, delay: 12000 },
            { type: 'bunker', x: 450, y: -800, width: 100, height: 80, delay: 15000 }
        ];
        
        this.terrainElements = terrainData.map(data => {
            return {
                ...data,
                spawned: false,
                active: true
            };
        });
    }
    
    /**
     * Load level data
     */
    loadLevelData() {
        // In a real implementation, this would load from the JSON file
        // For now, we'll use the hardcoded data with enhanced patterns
        this.levelData = {
            "level": 2,
            "name": "Bravo Sector - Wave 2",
            "background": "backgroundLevel2",
            "music": "gameMusic2",
            "waves": [
                {
                    "id": 1,
                    "name": "Fighter Formation",
                    "duration": 12000,
                    "enemies": [
                        // V formation
                        { "type": "fighter", "x": 400, "y": -50, "delay": 0, "pattern": "zigzag" },
                        { "type": "fighter", "x": 350, "y": -100, "delay": 300, "pattern": "zigzag" },
                        { "type": "fighter", "x": 450, "y": -100, "delay": 300, "pattern": "zigzag" },
                        { "type": "fighter", "x": 300, "y": -150, "delay": 600, "pattern": "zigzag" },
                        { "type": "fighter", "x": 500, "y": -150, "delay": 600, "pattern": "zigzag" },
                        
                        // Side attackers
                        { "type": "fighter", "x": 100, "y": -200, "delay": 2000, "pattern": "sweep" },
                        { "type": "fighter", "x": 700, "y": -200, "delay": 2000, "pattern": "sweep" },
                        
                        // Delayed reinforcements
                        { "type": "fighter", "x": 200, "y": -250, "delay": 4000, "pattern": "dive" },
                        { "type": "fighter", "x": 600, "y": -250, "delay": 4000, "pattern": "dive" },
                        { "type": "fighter", "x": 400, "y": -300, "delay": 5000, "pattern": "dive" }
                    ]
                },
                {
                    "id": 2,
                    "name": "Turret Defense",
                    "duration": 18000,
                    "enemies": [
                        // Turret line
                        { "type": "turret", "x": 150, "y": -50, "delay": 0 },
                        { "type": "turret", "x": 300, "y": -50, "delay": 500 },
                        { "type": "turret", "x": 450, "y": -50, "delay": 1000 },
                        { "type": "turret", "x": 600, "y": -50, "delay": 1500 },
                        
                        // Bomber support
                        { "type": "bomber", "x": 250, "y": -200, "delay": 3000, "pattern": "horizontal" },
                        { "type": "bomber", "x": 550, "y": -200, "delay": 3000, "pattern": "horizontal" },
                        
                        // Advanced turret
                        { "type": "advancedTurret", "x": 400, "y": -150, "delay": 6000 },
                        
                        // Fighter reinforcements
                        { "type": "fighter", "x": 200, "y": -300, "delay": 8000, "pattern": "dive" },
                        { "type": "fighter", "x": 600, "y": -300, "delay": 8000, "pattern": "dive" }
                    ]
                },
                {
                    "id": 3,
                    "name": "Mixed Attack Force",
                    "duration": 25000,
                    "enemies": [
                        // Initial wave
                        { "type": "bomber", "x": 200, "y": -100, "delay": 0, "pattern": "horizontal" },
                        { "type": "bomber", "x": 600, "y": -100, "delay": 0, "pattern": "horizontal" },
                        { "type": "turret", "x": 400, "y": -50, "delay": 1000 },
                        
                        // Fighter squadrons
                        { "type": "fighter", "x": 100, "y": -150, "delay": 3000, "pattern": "sweep" },
                        { "type": "fighter", "x": 200, "y": -200, "delay": 3300, "pattern": "sweep" },
                        { "type": "fighter", "x": 300, "y": -250, "delay": 3600, "pattern": "sweep" },
                        
                        { "type": "fighter", "x": 700, "y": -150, "delay": 6000, "pattern": "sweep" },
                        { "type": "fighter", "x": 600, "y": -200, "delay": 6300, "pattern": "sweep" },
                        { "type": "fighter", "x": 500, "y": -250, "delay": 6600, "pattern": "sweep" },
                        
                        // Advanced enemies
                        { "type": "advancedTurret", "x": 300, "y": -300, "delay": 10000 },
                        { "type": "advancedTurret", "x": 500, "y": -300, "delay": 10000 },
                        { "type": "heavyBomber", "x": 400, "y": -350, "delay": 12000, "pattern": "vertical" }
                    ]
                },
                {
                    "id": 4,
                    "name": "Boss Wave",
                    "duration": 40000,
                    "enemies": [
                        // Boss escort
                        { "type": "fighter", "x": 200, "y": -100, "delay": 0, "pattern": "protect" },
                        { "type": "fighter", "x": 600, "y": -100, "delay": 0, "pattern": "protect" },
                        { "type": "turret", "x": 300, "y": -50, "delay": 1000 },
                        { "type": "turret", "x": 500, "y": -50, "delay": 1000 },
                        
                        // Level 2 boss
                        { "type": "boss2", "x": 336, "y": -200, "delay": 5000 }
                    ]
                }
            ],
            "collectibles": [
                { "type": "health", "x": 200, "y": -200, "delay": 5000 },
                { "type": "shield", "x": 600, "y": -300, "delay": 10000 },
                { "type": "megabomb", "x": 400, "y": -400, "delay": 15000 },
                { "type": "health", "x": 300, "y": -500, "delay": 20000 },
                { "type": "shield", "x": 500, "y": -600, "delay": 25000 },
                { "type": "weapon", "x": 400, "y": -700, "delay": 30000, "weaponType": "laser" }
            ]
        };
    }
    
    /**
     * Update the level
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Check for wave-skipper debug feature
        if (this.game.input.skipWavePressed) {
            this.forceNextWave();
            this.game.input.skipWavePressed = false; // Reset the flag
        }

        // Update level time
        this.levelTime += deltaTime;
        
        // Update background
        this.background.update(deltaTime);
        
        // Process current wave
        this.updateWave(deltaTime);
        
        // Process collectibles
        this.updateCollectibles(deltaTime);
        
        // Process terrain elements
        this.updateTerrainElements(deltaTime);
        
        // Check for level completion
        this.checkLevelCompletion();
    }
    
    /**
     * Update the current wave
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateWave(deltaTime) {
        if (this.waveIndex >= this.levelData.waves.length) {
            return;
        }
        
        const currentWave = this.levelData.waves[this.waveIndex];
        const waveTime = this.levelTime - this.waveStartTime;
        
        // Process enemy spawns for current wave
        currentWave.enemies.forEach(enemy => {
            if (enemy.delay <= waveTime && !enemy.spawned) {
                this.spawnEnemy(enemy);
                enemy.spawned = true;
                
                // Check if boss was spawned
                if (enemy.type.includes('boss')) {
                    this.bossSpawned = true;
                }
            }
        });
        
        // Check if wave is complete
        if (waveTime >= currentWave.duration) {
            // Check if all enemies from this wave are defeated
            const allEnemiesDefeated = currentWave.enemies.every(enemy => {
                return enemy.spawned && !this.isEnemyActive(enemy);
            });
            
            if (allEnemiesDefeated) {
                this.advanceToNextWave();
            }
        }
    }
    
    /**
     * Update collectibles
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateCollectibles(deltaTime) {
        this.levelData.collectibles.forEach(collectible => {
            if (collectible.delay <= this.levelTime && !collectible.spawned) {
                this.spawnCollectible(collectible);
                collectible.spawned = true;
            }
        });
    }
    
    /**
     * Update terrain elements
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateTerrainElements(deltaTime) {
        this.terrainElements.forEach(terrain => {
            if (terrain.delay <= this.levelTime && !terrain.spawned && terrain.active) {
                this.spawnTerrainElement(terrain);
                terrain.spawned = true;
            }
        });
    }
    
    /**
     * Spawn a terrain element
     * @param {Object} terrainData - Terrain element data
     */
    spawnTerrainElement(terrainData) {
        // Create a destructible terrain element
        const terrain = new Enemy(
            this.game,
            terrainData.x,
            terrainData.y,
            terrainData.width,
            terrainData.height,
            terrainData.type
        );
        
        // Set terrain properties based on type
        switch (terrainData.type) {
            case 'building':
                terrain.health = 50;
                terrain.score = 50;
                terrain.velocityY = 50; // Move with background
                terrain.sprite = this.game.assets.getImage('enemyTurret'); // Reuse turret sprite for now
                break;
                
            case 'radar':
                terrain.health = 30;
                terrain.score = 100;
                terrain.velocityY = 50;
                terrain.sprite = this.game.assets.getImage('enemyTurret'); // Reuse turret sprite for now
                
                // Add radar scanning behavior
                const originalUpdate = terrain.update.bind(terrain);
                terrain.update = function(deltaTime) {
                    originalUpdate(deltaTime);
                    
                    // Periodically spawn enemies if radar is active
                    if (Math.random() < 0.005) {
                        const fighter = this.game.enemyFactory.createEnemy(
                            'fighter',
                            this.x + this.width / 2,
                            this.y - 50
                        );
                        
                        if (fighter) {
                            fighter.setMovementPattern('dive');
                        }
                    }
                };
                break;
                
            case 'bunker':
                terrain.health = 100;
                terrain.score = 200;
                terrain.velocityY = 50;
                terrain.sprite = this.game.assets.getImage('enemyTurret'); // Reuse turret sprite for now
                
                // Add bunker firing behavior
                const bunkerUpdate = terrain.update.bind(terrain);
                terrain.update = function(deltaTime) {
                    bunkerUpdate(deltaTime);
                    
                    // Fire periodically
                    if (Math.random() < 0.01) {
                        // Create projectile
                        const projectile = new Projectile(
                            this.game,
                            this.x + this.width / 2 - 5,
                            this.y + this.height,
                            10,
                            10,
                            0,
                            300,
                            15,
                            'enemy',
                            'enemyBullet'
                        );
                        
                        this.game.entityManager.add(projectile);
                        this.game.collision.addToGroup(projectile, 'enemyProjectiles');
                    }
                };
                break;
        }
        
        // Add to game
        this.game.entityManager.add(terrain);
        this.game.collision.addToGroup(terrain, 'enemies');
    }
    
    /**
     * Spawn an enemy
     * @param {Object} enemyData - Enemy data object
     */
    spawnEnemy(enemyData) {
        // Create the enemy
        let enemy;
        
        switch (enemyData.type) {
            case 'advancedTurret':
                enemy = this.createAdvancedTurret(enemyData.x, enemyData.y);
                break;
                
            case 'heavyBomber':
                enemy = this.createHeavyBomber(enemyData.x, enemyData.y);
                break;
                
            case 'boss2':
                enemy = this.createBoss2(enemyData.x, enemyData.y);
                break;
                
            default:
                // Use the new factory signature with the entire enemyData object
                enemy = this.enemyFactory.createEnemy(enemyData);
                break;
        }
        
        // Apply movement pattern if specified (legacy support)
        if (enemy && enemyData.pattern && !enemyData.overrides?.movementPattern) {
            this.applyMovementPattern(enemy, enemyData.pattern);
        }
        
        return enemy;
    }
    
    /**
     * Create an advanced turret enemy
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Enemy} The created advanced turret
     */
    createAdvancedTurret(x, y) {
        const turret = this.enemyFactory.createEnemy('turret', x, y);
        
        // Enhance turret properties
        turret.health = 60;
        turret.score = 300;
        turret.fireRate = 1500;
        
        // Override fire method to fire multiple projectiles
        turret.fire = function() {
            // Calculate angle to player
            const player = this.game.player;
            if (!player || !player.active) return;
            
            const dx = player.x + player.width / 2 - (this.x + this.width / 2);
            const dy = player.y + player.height / 2 - (this.y + this.height / 2);
            const angle = Math.atan2(dy, dx);
            
            // Fire three projectiles in a spread
            const speed = 250;
            const spreadAngle = Math.PI / 12; // 15 degrees
            
            for (let i = -1; i <= 1; i++) {
                const projectileAngle = angle + i * spreadAngle;
                const projectile = new Projectile(
                    this.game,
                    this.x + this.width / 2 - 5,
                    this.y + this.height / 2,
                    10,
                    10,
                    Math.cos(projectileAngle) * speed,
                    Math.sin(projectileAngle) * speed,
                    15,
                    'enemy',
                    'enemyBullet'
                );
                
                this.game.entityManager.add(projectile);
                this.game.collision.addToGroup(projectile, 'enemyProjectiles');
            }
            
            // Play sound
            this.game.audio.playSound('enemyShoot');
        };
        
        return turret;
    }
    
    /**
     * Create a heavy bomber enemy
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Enemy} The created heavy bomber
     */
    createHeavyBomber(x, y) {
        const bomber = this.enemyFactory.createEnemy('bomber', x, y);
        
        // Enhance bomber properties
        bomber.health = 80;
        bomber.score = 400;
        bomber.width = 80;
        bomber.height = 60;
        bomber.dropRate = 1000;
        
        // Override drop bomb method to drop multiple bombs
        bomber.dropBomb = function() {
            // Drop three bombs in a spread
            for (let i = -1; i <= 1; i++) {
                const bomb = new Projectile(
                    this.game,
                    this.x + this.width / 2 - 10 + i * 20,
                    this.y + this.height,
                    20,
                    20,
                    0,
                    200,
                    20,
                    'enemy',
                    'enemyBullet'
                );
                
                this.game.entityManager.add(bomb);
                this.game.collision.addToGroup(bomb, 'enemyProjectiles');
            }
        };
        
        return bomber;
    }
    
    /**
     * Create the level 2 boss
     * @param {number} x - X position
     * @param {number} y - Y position
     * @returns {Enemy} The created boss
     */
    createBoss2(x, y) {
        // Start with the level 1 boss as a base
        const boss = this.enemyFactory.createBoss1(x, y);
        
        // Enhance boss properties for level 2
        boss.type = 'boss2';
        boss.health = 800;
        boss.phaseHealth = 800;
        boss.score = 5000;
        boss.fireRate = 800;
        
        // Override fire spread method for more projectiles
        boss.fireSpread = function() {
            const numProjectiles = 8;
            const spreadAngle = Math.PI * 2 / 3; // 120 degrees
            const startAngle = Math.PI / 2 - spreadAngle / 2; // Center at bottom
            
            for (let i = 0; i < numProjectiles; i++) {
                const angle = startAngle + (spreadAngle * i) / (numProjectiles - 1);
                const speed = 250;
                
                const projectile = new Projectile(
                    this.game,
                    this.x + this.width / 2 - 5,
                    this.y + this.height / 2,
                    10,
                    10,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    10,
                    'enemy',
                    'enemyBullet'
                );
                
                this.game.entityManager.add(projectile);
                this.game.collision.addToGroup(projectile, 'enemyProjectiles');
            }
        };
        
        // Add special attack for phase 3
        boss.specialAttack = function() {
            // Create homing missile
            const player = this.game.player;
            if (!player || !player.active) return;
            
            const missile = new HomingProjectile(
                this.game,
                this.x + this.width / 2 - 10,
                this.y + this.height,
                20,
                20,
                30,
                'enemy',
                player,
                200,
                Math.PI / 4 // 45 degrees per second turning rate
            );
            
            this.game.entityManager.add(missile);
            this.game.collision.addToGroup(missile, 'enemyProjectiles');
            
            // Play sound
            this.game.audio.playSound('enemyShoot');
        };
        
        // Override update phase method to include special attack
        const originalUpdatePhase = boss.updatePhase.bind(boss);
        boss.updatePhase = function() {
            originalUpdatePhase();
            
            // Special attack in phase 3
            if (this.phase === 3) {
                const now = Date.now();
                if (now - this.lastSpecialTime > 3000) {
                    this.lastSpecialTime = now;
                    this.specialAttack();
                }
            }
        };
        
        // Initialize last special attack time
        boss.lastSpecialTime = 0;
        
        return boss;
    }
    
    /**
     * Apply a movement pattern to an enemy
     * @param {Enemy} enemy - The enemy to apply the pattern to
     * @param {string} pattern - The pattern to apply
     */
    applyMovementPattern(enemy, pattern) {
        switch (pattern) {
            case 'zigzag':
                // Zigzag pattern
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        minX: options.minX || 50,
                        maxX: options.maxX || this.game.width - 50,
                        speed: options.speed || 100,
                        direction: options.direction || 1
                    };
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        // Apply zigzag movement
                        this.velocityX = this.patternOptions.speed * this.patternOptions.direction;
                        
                        // Reverse direction at edges
                        if (this.x <= this.patternOptions.minX) {
                            this.patternOptions.direction = 1;
                        } else if (this.x + this.width >= this.patternOptions.maxX) {
                            this.patternOptions.direction = -1;
                        }
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('zigzag', {
                    minX: 50,
                    maxX: this.game.width - 50,
                    speed: 100,
                    direction: Math.random() > 0.5 ? 1 : -1
                });
                break;
                
            case 'sweep':
                // Sweep across screen
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        startX: this.x,
                        endX: options.endX || (this.x < this.game.width / 2 ? this.game.width - 50 : 50),
                        speed: options.speed || 150,
                        verticalSpeed: options.verticalSpeed || 80
                    };
                    
                    // Calculate direction
                    this.patternOptions.direction = this.patternOptions.startX < this.patternOptions.endX ? 1 : -1;
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        // Apply sweep movement
                        this.velocityX = this.patternOptions.speed * this.patternOptions.direction;
                        this.velocityY = this.patternOptions.verticalSpeed;
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('sweep', {
                    endX: enemy.x < this.game.width / 2 ? this.game.width - 50 : 50,
                    speed: 150,
                    verticalSpeed: 80
                });
                break;
                
            case 'dive':
                // Dive toward player
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        speed: options.speed || 200,
                        delay: options.delay || 1000
                    };
                    
                    this.patternState = {
                        waiting: true,
                        startTime: Date.now()
                    };
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        const now = Date.now();
                        
                        if (this.patternState.waiting) {
                            // Wait before diving
                            this.velocityY = 50;
                            this.velocityX = 0;
                            
                            if (now - this.patternState.startTime > this.patternOptions.delay) {
                                this.patternState.waiting = false;
                                
                                // Target player position
                                const player = this.game.player;
                                if (player && player.active) {
                                    const dx = player.x - this.x;
                                    const dy = player.y - this.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    this.velocityX = (dx / distance) * this.patternOptions.speed;
                                    this.velocityY = (dy / distance) * this.patternOptions.speed;
                                } else {
                                    // No player, just dive down
                                    this.velocityY = this.patternOptions.speed;
                                }
                            }
                        }
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('dive', {
                    speed: 200,
                    delay: 1000 + Math.random() * 1000
                });
                break;
                
            case 'horizontal':
                // Horizontal movement
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        minX: options.minX || 50,
                        maxX: options.maxX || this.game.width - 50,
                        speed: options.speed || 80,
                        direction: options.direction || 1,
                        verticalSpeed: options.verticalSpeed || 50
                    };
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        // Apply horizontal movement
                        this.velocityX = this.patternOptions.speed * this.patternOptions.direction;
                        this.velocityY = this.patternOptions.verticalSpeed;
                        
                        // Reverse direction at edges
                        if (this.x <= this.patternOptions.minX) {
                            this.patternOptions.direction = 1;
                        } else if (this.x + this.width >= this.patternOptions.maxX) {
                            this.patternOptions.direction = -1;
                        }
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('horizontal', {
                    minX: 50,
                    maxX: this.game.width - 50,
                    speed: 80,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    verticalSpeed: 50
                });
                break;
                
            case 'vertical':
                // Vertical movement with slight horizontal drift
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        minY: options.minY || 50,
                        maxY: options.maxY || 200,
                        speed: options.speed || 60,
                        direction: options.direction || 1,
                        horizontalSpeed: options.horizontalSpeed || 20
                    };
                    
                    this.patternState = {
                        baseY: this.y,
                        time: 0
                    };
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        // Apply vertical oscillation
                        this.patternState.time += deltaTime / 1000;
                        const offsetY = Math.sin(this.patternState.time) * 50;
                        this.velocityY = 50 + offsetY;
                        
                        // Apply slight horizontal drift
                        this.velocityX = Math.sin(this.patternState.time * 0.5) * this.patternOptions.horizontalSpeed;
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('vertical', {
                    minY: 50,
                    maxY: 200,
                    speed: 60,
                    horizontalSpeed: 20
                });
                break;
                
            case 'protect':
                // Protect the boss
                enemy.setMovementPattern = function(pattern, options = {}) {
                    this.movementPattern = pattern;
                    this.patternOptions = {
                        radius: options.radius || 100,
                        speed: options.speed || 1,
                        offset: options.offset || Math.random() * Math.PI * 2
                    };
                    
                    this.patternState = {
                        time: 0,
                        baseX: this.x,
                        baseY: this.y
                    };
                    
                    // Override update method
                    const originalUpdate = this.update.bind(this);
                    this.update = function(deltaTime) {
                        // Find boss
                        const boss = this.game.collision.collisionGroups.enemies.find(e => e.type.includes('boss'));
                        
                        if (boss && boss.active) {
                            // Orbit around boss
                            this.patternState.time += deltaTime / 1000 * this.patternOptions.speed;
                            
                            const angle = this.patternState.time + this.patternOptions.offset;
                            const targetX = boss.x + boss.width / 2 + Math.cos(angle) * this.patternOptions.radius - this.width / 2;
                            const targetY = boss.y + boss.height / 2 + Math.sin(angle) * this.patternOptions.radius - this.height / 2;
                            
                            // Calculate velocity to move toward target position
                            const dx = targetX - this.x;
                            const dy = targetY - this.y;
                            
                            this.velocityX = dx * 5;
                            this.velocityY = dy * 5;
                        } else {
                            // No boss, just move down
                            this.velocityY = 100;
                        }
                        
                        // Call original update
                        originalUpdate(deltaTime);
                    };
                };
                
                enemy.setMovementPattern('protect', {
                    radius: 100,
                    speed: 1,
                    offset: Math.random() * Math.PI * 2
                });
                break;
        }
    }
    
    /**
     * Spawn a collectible
     * @param {Object} collectibleData - Collectible data object
     */
    spawnCollectible(collectibleData) {
        const collectible = new Collectible(
            this.game,
            collectibleData.x,
            collectibleData.y,
            30,
            30,
            collectibleData.type,
            collectibleData.type === 'megabomb' ? 1 : 20
        );
        
        // Set weapon type for weapon collectibles
        if (collectibleData.type === 'weapon' && collectibleData.weaponType) {
            collectible.weaponType = collectibleData.weaponType;
            
            // Override collect method to upgrade specific weapon
            const originalCollect = collectible.collect.bind(collectible);
            collectible.collect = function(player) {
                if (this.type === 'weapon' && this.weaponType) {
                    player.upgradeWeapon(this.weaponType);
                } else {
                    originalCollect(player);
                }
            };
        }
        
        this.game.entityManager.add(collectible);
        this.game.collision.addToGroup(collectible, 'collectibles');
    }
    
    /**
     * Check if an enemy is still active
     * @param {Object} enemyData - Enemy data object
     * @returns {boolean} True if enemy is active, false otherwise
     */
    isEnemyActive(enemyData) {
        // Check if any enemies of this type are still active at the spawn position
        const enemies = this.game.collision.collisionGroups.enemies;
        return enemies.some(enemy => {
            return enemy.type === enemyData.type && 
                   Math.abs(enemy.x - enemyData.x) < 10 && 
                   enemy.active;
        });
    }
    
    /**
     * Advance to the next wave
     */
    advanceToNextWave() {
        this.waveIndex++;
        this.waveStartTime = this.levelTime;
        
        // Log wave change
        if (this.waveIndex < this.levelData.waves.length) {
            logger.info(`Starting Wave ${this.waveIndex + 1}: ${this.levelData.waves[this.waveIndex].name}`);
        }
    }
    
    /**
     * Force advance to the next wave (debug feature)
     */
    forceNextWave() {
        logger.debug("DEBUG: Forcing next wave.");
        
        // Clear out any remaining enemies from the current wave
        const enemies = this.game.collision.collisionGroups.enemies;
        enemies.forEach(enemy => {
            if (enemy.active) {
                enemy.destroy();
            }
        });
        
        if (this.waveIndex < this.levelData.waves.length - 1) {
            this.waveIndex++;
            this.waveStartTime = this.levelTime;
            logger.debug(`DEBUG: Advanced to wave index ${this.waveIndex + 1}: ${this.levelData.waves[this.waveIndex].name}`);
        } else {
            logger.debug("DEBUG: Already on the last wave.");
        }
    }
    
    /**
     * Check if the level is complete
     */
    checkLevelCompletion() {
        // Level is complete when all waves are processed and boss is defeated
        if (this.waveIndex >= this.levelData.waves.length && this.bossSpawned) {
            // Check if boss is defeated
            const bossAlive = this.game.collision.collisionGroups.enemies.some(enemy => {
                return enemy.type.includes('boss') && enemy.active;
            });
            
            if (!bossAlive) {
                this.bossDefeated = true;
                this.levelComplete = true;
            }
        }
    }
    
    /**
     * Check if the level is complete
     * @returns {boolean} True if level is complete, false otherwise
     */
    isComplete() {
        return this.levelComplete;
    }
    
    /**
     * Render the level
     */
    render(contexts) {
        // Render background
        if (this.background) {
            this.background.render(contexts.background);
        }
    }
    
    /**
     * Clean up the level
     */
    cleanup() {
        // Stop music
        this.game.audio.stopMusic();
    }
}

export { Level2 };
</file>

<file path="js/states/pause.js">
/**
 * PauseState class
 * Handles the game pause state as a simple overlay without changing game states
 */
import { logger } from '../utils/logger.js';
class PauseState {
    /**
     * Create a new PauseState instance
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        this.isPaused = false;
        this.pauseOverlay = null;
        
        // Define menu options with their associated actions
        this.menuOptions = [
            { text: 'Resume Game', action: () => this.resumeGame() },
            { text: 'Save Game', action: () => this.saveGame() },
            { text: 'Return to Menu', action: () => this.returnToMenu() }
        ];
        
        this.selectedOption = 0;
        this.keyDelay = 200;
        this.lastKeyTime = 0;
        this.saveMessage = '';
        this.saveMessageTimeout = null;
    }
    
    /**
     * Toggle pause state
     */
    togglePause() {
        if (this.isPaused) {
            this.resumeGame();
        } else {
            this.pauseGame();
        }
    }
    
    /**
     * Pause the game
     */
    pauseGame() {
        if (this.isPaused) return;
        
        logger.info('Pausing game with overlay');
        this.isPaused = true;
        
        // Stop game audio (AudioManager doesn't have pause/resume, only stop)
        this.game.audio.stopMusic();
        
        // Create the pause overlay
        this.createPauseOverlay();
    }
    
    /**
     * Resume the game
     */
    resumeGame() {
        if (!this.isPaused) return;
        
        logger.info('Resuming game');
        this.isPaused = false;
        
        // Remove the pause overlay
        this.removePauseOverlay();
        
        // Note: AudioManager doesn't have resumeMusic method
        // Music will need to be restarted manually if needed
    }
    
    /**
     * Create the pause overlay UI
     */
    createPauseOverlay() {
        // Create pause overlay container
        this.pauseOverlay = document.createElement('div');
        this.pauseOverlay.id = 'pause-overlay';
        this.pauseOverlay.style.position = 'absolute';
        this.pauseOverlay.style.top = '0';
        this.pauseOverlay.style.left = '0';
        this.pauseOverlay.style.width = '100%';
        this.pauseOverlay.style.height = '100%';
        this.pauseOverlay.style.display = 'flex';
        this.pauseOverlay.style.flexDirection = 'column';
        this.pauseOverlay.style.alignItems = 'center';
        this.pauseOverlay.style.justifyContent = 'center';
        this.pauseOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        this.pauseOverlay.style.zIndex = '1000';
        this.pauseOverlay.style.backdropFilter = 'blur(2px)';
        
        // Create title
        const title = document.createElement('div');
        title.textContent = 'PAUSED';
        title.style.color = '#ffcc00';
        title.style.fontSize = '36px';
        title.style.fontFamily = 'Arial';
        title.style.marginBottom = '40px';
        title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        this.pauseOverlay.appendChild(title);
        
        // Create menu options as clickable buttons
        this.menuOptions.forEach((option, index) => {
            const button = document.createElement('div');
            button.textContent = option.text;
            button.style.color = index === this.selectedOption ? '#ffcc00' : 'white';
            button.style.fontSize = '24px';
            button.style.fontFamily = 'Arial';
            button.style.margin = '10px';
            button.style.padding = '10px 20px';
            button.style.cursor = 'pointer';
            button.style.transition = 'all 0.2s ease';
            button.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            button.style.borderRadius = '5px';
            
            // Add hover effect
            button.addEventListener('mouseenter', () => {
                button.style.color = '#ffcc00';
                button.style.transform = 'scale(1.05)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.color = index === this.selectedOption ? '#ffcc00' : 'white';
                button.style.transform = 'scale(1)';
            });
            
            // Add click handler
            button.addEventListener('click', () => {
                option.action();
            });
            
            this.pauseOverlay.appendChild(button);
        });
        
        // Create save message container
        const saveMessageContainer = document.createElement('div');
        saveMessageContainer.id = 'pause-save-message';
        saveMessageContainer.style.color = '#00ff00';
        saveMessageContainer.style.fontSize = '20px';
        saveMessageContainer.style.fontFamily = 'Arial';
        saveMessageContainer.style.marginTop = '20px';
        saveMessageContainer.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        this.pauseOverlay.appendChild(saveMessageContainer);
        
        // Create controls reminder
        const controlsReminder = document.createElement('div');
        controlsReminder.textContent = 'Use Arrow Keys or W/S to navigate, Enter to select, or click buttons';
        controlsReminder.style.color = 'rgba(255, 255, 255, 0.5)';
        controlsReminder.style.fontSize = '16px';
        controlsReminder.style.fontFamily = 'Arial';
        controlsReminder.style.marginTop = '40px';
        controlsReminder.style.textAlign = 'center';
        this.pauseOverlay.appendChild(controlsReminder);
        
        // Add to document
        document.body.appendChild(this.pauseOverlay);
    }
    
    /**
     * Remove the pause overlay
     */
    removePauseOverlay() {
        if (this.pauseOverlay) {
            this.pauseOverlay.remove();
            this.pauseOverlay = null;
        }
        
        // Clear any pending save message timeout
        if (this.saveMessageTimeout) {
            clearTimeout(this.saveMessageTimeout);
            this.saveMessageTimeout = null;
        }
    }
    
    /**
     * Update the pause state
     */
    update(deltaTime) {
        if (!this.isPaused) return;
        
        const now = Date.now();
        
        // Handle keyboard navigation with delay to prevent too rapid menu movement
        if (now - this.lastKeyTime > this.keyDelay) {
            let optionChanged = false;
            
            // Navigate up in menu
            if (this.game.input.isKeyPressed('ArrowUp') || this.game.input.isKeyPressed('w')) {
                this.selectedOption = (this.selectedOption - 1 + this.menuOptions.length) % this.menuOptions.length;
                this.lastKeyTime = now;
                optionChanged = true;
            }
            
            // Navigate down in menu
            if (this.game.input.isKeyPressed('ArrowDown') || this.game.input.isKeyPressed('s')) {
                this.selectedOption = (this.selectedOption + 1) % this.menuOptions.length;
                this.lastKeyTime = now;
                optionChanged = true;
            }
            
            // Select current menu option
            if (this.game.input.isKeyPressed('Enter') || this.game.input.isKeyPressed(' ')) {
                this.menuOptions[this.selectedOption].action();
                this.lastKeyTime = now;
            }
            
            // Resume game if Escape or P is pressed
            if (this.game.input.isKeyPressed('Escape') || this.game.input.isKeyPressed('p')) {
                this.resumeGame();
                this.lastKeyTime = now;
            }
            
            // Update button highlighting if option changed
            if (optionChanged) {
                this.updateButtonHighlighting();
            }
        }
    }
    
    /**
     * Update button highlighting based on selected option
     */
    updateButtonHighlighting() {
        if (!this.pauseOverlay) return;
        
        const buttons = this.pauseOverlay.querySelectorAll('div');
        // Skip the first div (title) and last two divs (save message and controls reminder)
        for (let i = 1; i < buttons.length - 2; i++) {
            const button = buttons[i];
            const optionIndex = i - 1;
            
            if (optionIndex === this.selectedOption) {
                button.style.color = '#ffcc00';
            } else {
                button.style.color = 'white';
            }
        }
    }
    
    /**
     * Save the current game
     */
    saveGame() {
        if (this.game.saveManager.saveGame()) {
            this.showSaveMessage('Game saved successfully!');
        } else {
            this.showSaveMessage('Failed to save game.');
        }
    }
    
    /**
     * Show a temporary save message
     */
    showSaveMessage(message) {
        this.saveMessage = message;
        
        // Update the HTML message container
        const saveMessageContainer = document.getElementById('pause-save-message');
        if (saveMessageContainer) {
            saveMessageContainer.textContent = message;
        }
        
        // Clear any existing timeout
        if (this.saveMessageTimeout) {
            clearTimeout(this.saveMessageTimeout);
        }
        
        // Set timeout to clear message after 2 seconds
        this.saveMessageTimeout = setTimeout(() => {
            this.saveMessage = '';
            if (saveMessageContainer) {
                saveMessageContainer.textContent = '';
            }
        }, 2000);
    }
    
    /**
     * Return to the main menu
     */
    returnToMenu() {
        // Remove the pause overlay
        this.removePauseOverlay();
        
        // Save game before returning to menu
        this.game.saveManager.saveGame();
        
        // Change to menu state
        this.game.changeState('menu');
    }
    
    /**
     * Render the pause overlay (called by game state when paused)
     */
    render(contexts) {
        // The pause overlay is rendered as HTML, so we don't need canvas rendering
    }
}

export { PauseState };
</file>

<file path="js/ui/hud.js">
import { logger } from '../utils/logger.js';

/**
 * Represents the Heads-Up Display (HUD) of the game, which shows player information
 * such as score, health, and other important game data.
 */
export class HUD {
    /**
     * @param {Game} game - The main game object, providing access to game state.
     */
    constructor(game) {
        this.game = game;
        this.fontSize = 25;
        this.fontFamily = 'Helvetica';
        this.color = 'white';
        // Cache the formatted high score string
        this.highScoreText = `High Score: ${this.game.highScore}`;
    }

    /**
     * Draws the entire HUD on the given rendering context.
     * @param {CanvasRenderingContext2D} context - The 2D rendering context to draw on.
     */
    draw(context) {
        context.save();
        context.fillStyle = this.color;
        context.font = `${this.fontSize}px ${this.fontFamily}`;

        // Score
        const scoreText = `Score: ${this.game.score}`;
        context.fillText(scoreText, 20, 40);

        // High Score display
        context.fillText(this.highScoreText, 20, 80);

        // --- START OF HEALTH VISUALIZATION CHANGE ---

        // Draw player health as vertical ticks on the right side
        const player = this.game.player;
        let rightEdge = this.game.width;
        if (this.game.currentState && typeof this.game.currentState.getPlayableBounds === 'function') {
            rightEdge = this.game.currentState.getPlayableBounds().right;
        }
        const TICK_RIGHT_MARGIN = 40; // Margin from the right edge to stay inside border
        if (player) {
            const maxHealth = player.maxHealth;
            const currentHealth = player.health;
            const healthPercentage = currentHealth / maxHealth;

            const totalTicks = 30; // The total number of ticks representing full health
            const ticksToShow = Math.ceil(totalTicks * healthPercentage);

            const tickWidth = 15;
            const tickHeight = 5;
            const tickGap = 5; // Space between ticks
            const xPosition = rightEdge - tickWidth - TICK_RIGHT_MARGIN; // Position from the right edge, inside border
            const totalBarHeight = (tickHeight + tickGap) * totalTicks;
            const startY = (this.game.height - totalBarHeight) / 2; // Center the bar vertically

            context.fillStyle = 'orange';
            for (let i = 0; i < ticksToShow; i++) {
                const yPosition = startY + i * (tickHeight + tickGap);
                context.fillRect(xPosition, yPosition, tickWidth, tickHeight);
            }
        }

        // --- END OF HEALTH VISUALIZATION CHANGE ---

        // Game Over message
        if (this.game.gameOver) {
            context.textAlign = 'center';
            context.fillStyle = 'white';
            context.font = `50px ${this.fontFamily}`;
            context.fillText('Game Over', this.game.width / 2, this.game.height / 2);
        }

        context.restore();
    }

    /**
     * Render the HUD (alias for draw)
     * @param {CanvasRenderingContext2D} context - The rendering context for the UI layer
     */
    render(context) {
        this.draw(context);
    }
}
</file>

<file path="js/engine/input.js">
/**
 * InputHandler class
 * Handles keyboard and mouse input with state tracking for a single frame.
 */
import { logger } from '../utils/logger.js';
class InputHandler {
    constructor() {
        // Keyboard state
        this.keys = {};
        this.previousKeys = {};

        // Mouse state
        this.mousePosition = { x: 0, y: 0 };
        this.mouseButtons = { left: false, middle: false, right: false };
        this.previousMouseButtons = { left: false, middle: false, right: false };

        // Mouse wheel state
        this.wheelDeltaY = 0;

        // Debug-specific flags
        this.skipWavePressed = false;
        this.restartLevelPressed = false;
        this.cycleLevelPressed = false;

        // Bind 'this' context once to prevent issues in event listeners
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.handleWheel = this.handleWheel.bind(this);

        // Set up event listeners
        window.addEventListener('keydown', this.handleKeyDown);
        window.addEventListener('keyup', this.handleKeyUp);
        window.addEventListener('mousemove', this.handleMouseMove);
        window.addEventListener('mousedown', this.handleMouseDown);
        window.addEventListener('mouseup', this.handleMouseUp);
        window.addEventListener('wheel', this.handleWheel);
    }

    // This method MUST be called once per game loop (from game.js)
    update() {
        // Copy the current key states to the previous key states for wasKeyJustPressed logic
        this.previousKeys = { ...this.keys };
        
        // Copy the current mouse button states to the previous mouse button states for wasMouseButtonJustPressed logic
        this.previousMouseButtons = { ...this.mouseButtons };
        
        // Reset wheel delta each frame after it's been processed
        this.wheelDeltaY = 0;
    }

    // Replace your existing handleKeyDown method with this one

    handleKeyDown(event) {
        // For debugging, let's see every key press
        logger.spam(`Key pressed: ${event.key}`);

        // Set the state for continuous-press keys
        this.keys[event.key] = true;

        // --- Handle single-press debug flags ---
        if (event.key === '2' || event.key === 'Numpad2') {
            this.skipWavePressed = true;
            logger.debug(`INPUT_HANDLER: skipWavePressed flag SET to: ${this.skipWavePressed}`);
        }
        
        if (event.key === '3' || event.key === 'Numpad3') {
            this.restartLevelPressed = true;
            logger.debug(`INPUT_HANDLER: restartLevelPressed flag SET to: ${this.restartLevelPressed}`);
        }
        
        if (event.key === '4' || event.key === 'Numpad4') {
            this.cycleLevelPressed = true;
            logger.debug(`INPUT_HANDLER: cycleLevelPressed flag SET to: ${this.cycleLevelPressed}`);
        }

        // Prevent default browser actions for game keys to stop the window from scrolling
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(event.key)) {
            event.preventDefault();
        }
    }

    handleKeyUp(event) {
        this.keys[event.key] = false;

        if (event.key === '2' || event.key === 'Numpad2') {
            this.skipWavePressed = false;
        }
        
        if (event.key === '3' || event.key === 'Numpad3') {
            this.restartLevelPressed = false;
        }
        
        if (event.key === '4' || event.key === 'Numpad4') {
            this.cycleLevelPressed = false;
        }
    }

    handleMouseMove(event) {
        // Get the first canvas (they should all have the same scaling)
        const canvas = document.querySelector('#game-container canvas');
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        
        // Get the scaled mouse position relative to the canvas
        const scaledX = event.clientX - rect.left;
        const scaledY = event.clientY - rect.top;
        
        // Convert from scaled canvas coordinates to internal game coordinates
        // Use the actual game dimensions instead of hardcoded values
        const gameWidth = canvas.width;   // Internal game width
        const gameHeight = canvas.height; // Internal game height
        
        const scaleX = gameWidth / rect.width;   // Internal width / scaled width
        const scaleY = gameHeight / rect.height; // Internal height / scaled height
        
        this.mousePosition.x = scaledX * scaleX;
        this.mousePosition.y = scaledY * scaleY;
        
        // Clamp to game boundaries
        this.mousePosition.x = Math.max(0, Math.min(gameWidth, this.mousePosition.x));
        this.mousePosition.y = Math.max(0, Math.min(gameHeight, this.mousePosition.y));
    }

    handleMouseDown(event) {
        switch (event.button) {
            case 0: this.mouseButtons.left = true; break;
            case 1: this.mouseButtons.middle = true; break;
            case 2: this.mouseButtons.right = true; break;
        }
    }

    handleMouseUp(event) {
        switch (event.button) {
            case 0: this.mouseButtons.left = false; break;
            case 1: this.mouseButtons.middle = false; break;
            case 2: this.mouseButtons.right = false; break;
        }
    }

    handleWheel(event) {
        this.wheelDeltaY = Math.sign(event.deltaY);
    }

    isKeyPressed(key) {
        return this.keys[key] === true;
    }

    wasKeyJustPressed(key) {
        return this.isKeyPressed(key) && !this.previousKeys[key];
    }

    isMouseButtonPressed(button) {
        return this.mouseButtons[button] === true;
    }

    wasMouseButtonJustPressed(button) {
        return this.isMouseButtonPressed(button) && !this.previousMouseButtons[button];
    }

    getMousePosition() {
        return this.mousePosition;
    }

    getWheelDeltaY() {
        return this.wheelDeltaY;
    }
}

export { InputHandler };
</file>

<file path="js/entities/boss1.js">
/**
 * Boss1 class
 * The first boss of the game.
 */
import { Enemy } from './enemy.js';
import { Projectile } from './projectile.js';
import { HomingProjectile } from './homingProjectile.js';

class Boss1 extends Enemy {
    constructor(game, x, y, spriteKey) {
        // Define the boss's stats to pass to the parent Enemy constructor.
        const health = 800;
        const scoreValue = 5000;
        const moneyValue = 1000;

        // Call the parent constructor CORRECTLY.
        // The Enemy constructor expects: (game, x, y, type, spriteKey, health, scoreValue)
        super(game, x, y, 'boss1', spriteKey, health, scoreValue);
        
        // --- Now, set properties specific to the Boss1 class ---

        // Override dimensions AFTER the parent constructor has run.
        this.width = 178;
        this.height = 117;

        // Set the critical flags and values.
        this.isBoss = true;
        this.layer = 'enemy';
        this.moneyValue = moneyValue;
        this.maxHealth = this.health; // Ensure maxHealth matches the real health.

        // Movement parameters
        this.movementSpeed = 50;
        this.movementDirection = 1;

        // Attack Pattern Cooldowns
        this.machineGunCooldown = 2000;
        this.lastMachineGunShot = 0;
        this.homingMissileCooldown = 7000;
        this.lastHomingMissileLaunch = 0;
        this.isBoss = true;
    }

    // The update method's only job is to run boss-specific logic,
    // and then call the parent Enemy's update method, which contains the death sequence.
    update(deltaTime) {
        // Run all boss-specific behaviors.
        this.handleMovement(deltaTime);
        this.handleAttacks(deltaTime);

        // Call the master update method from Enemy.js.
        // This is the essential line that runs the health checks and death sequence.
        super.update(deltaTime);
    }

    handleMovement(deltaTime) {
        // Simple side-to-side movement
        this.x += this.movementSpeed * this.movementDirection * (deltaTime / 1000);

        // Clamp position to stay on screen.
        if (this.x <= 0) {
            this.x = 0;
            this.movementDirection = 1;
        } else if (this.x + this.width >= this.game.width) {
            this.x = this.game.width - this.width;
            this.movementDirection = -1;
        }
        // Clamp y position near the top.
        if (this.y > 50) this.y = 50;
    }

    handleAttacks(deltaTime) {
        const now = this.game.currentState ? this.game.currentState.gameTime : 0; // Use level's gameTime

        if (now - this.lastMachineGunShot > this.machineGunCooldown) {
            this.lastMachineGunShot = now;
            this.fireMachineGun();
        }

        if (now - this.lastHomingMissileLaunch > this.homingMissileCooldown) {
            this.lastHomingMissileLaunch = now;
            this.launchHomingMissiles();
        }
    }

    fireMachineGun() {
        if (!this.game.player) return;

        const numProjectiles = 5;
        const spreadAngle = Math.PI / 6; // 30 degrees
        const projectileSpeed = 300;
        const projectileDamage = 10;
        
        const playerX = this.game.player.getCenter().x;
        const playerY = this.game.player.getCenter().y;
        const bossX = this.getCenter().x;
        const bossY = this.getCenter().y;
        
        const centerAngle = Math.atan2(playerY - bossY, playerX - bossX);
        const startAngle = centerAngle - spreadAngle / 2;

        for (let i = 0; i < numProjectiles; i++) {
            const angle = startAngle + (spreadAngle * i) / (numProjectiles - 1);
            
            const sprite = this.game.assets.getImage('enemyBullet');
            const projectile = this.game.projectilePool.get();
            projectile.activate(
                bossX, bossY,
                Math.cos(angle) * projectileSpeed, // velocityX
                Math.sin(angle) * projectileSpeed, // velocityY
                projectileDamage,
                'enemy',
                sprite
            );
            
            this.game.entityManager.add(projectile);
            this.game.collision.addToGroup(projectile, 'enemyProjectiles');
        }
    }

    launchHomingMissiles() {
        if (!this.game.player) return;
        const missileDamage = 25;
        const missileSpeed = 150;

        const missile1 = new HomingProjectile(this.game, this.x, this.y + this.height / 2, missileDamage, this.game.player, missileSpeed);
        const missile2 = new HomingProjectile(this.game, this.x + this.width, this.y + this.height / 2, missileDamage, this.game.player, missileSpeed);

        this.game.entityManager.add(missile1);
        this.game.entityManager.add(missile2);
        this.game.collision.addToGroup(missile1, 'enemyProjectiles');
        this.game.collision.addToGroup(missile2, 'enemyProjectiles');
    }

    render(context) {
        // The parent Entity.render() handles drawing the sprite.
        super.render(context);
    }
}

export { Boss1 };
</file>

<file path="js/levels/level1.json">
{
    "level": 1,
    "levelName": "Bravo Sector",
    "tileset": "tileset_level1",
    "tilemap": [
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    "music": "gameMusic1",
    "waves": [
        {
            "wave_id": "wave_01_striker_assault",
            "delay_after_previous_wave_ms": 2000,
            "enemies": [
                { "type": "striker", "spawn_x": 275, "spawn_y": -50, "delay": 500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 800, "speed": 80 } },
                { "type": "striker", "spawn_x": 325, "spawn_y": -50, "delay": 500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 1200, "speed": 80 } },
                { "type": "striker", "spawn_x": 25, "spawn_y": -80, "delay": 2500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 600, "speed": 80 } },
                { "type": "striker", "spawn_x": 125, "spawn_y": -80, "delay": 2500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 1000, "speed": 80 } },
                { "type": "striker", "spawn_x": 475, "spawn_y": -80, "delay": 4500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 900, "speed": 80 } },
                { "type": "striker", "spawn_x": 575, "spawn_y": -80, "delay": 4500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 700, "speed": 80 } },
                { "type": "striker", "spawn_x": 50, "spawn_y": -50, "delay": 7000, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 1100, "speed": 90 } },
                { "type": "striker", "spawn_x": 150, "spawn_y": -50, "delay": 7500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 800, "speed": 90 } },
                { "type": "striker", "spawn_x": 250, "spawn_y": -50, "delay": 8000, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 1300, "speed": 90 } },
                { "type": "striker", "spawn_x": 550, "spawn_y": -50, "delay": 9500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 950, "speed": 90 } },
                { "type": "striker", "spawn_x": 650, "spawn_y": -50, "delay": 10000, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 650, "speed": 90 } },
                { "type": "striker", "spawn_x": 750, "spawn_y": -50, "delay": 10500, "overrides": { "movementPattern": "descend_and_converge", "firingPattern": "single_straight_shot", "fireRate": 1050, "speed": 90 } }
            ]
        },
        {
            "wave_id": "wave_02_cyclone_and_gnats",
            "delay_after_previous_wave_ms": 3000,
            "enemies": [
                { "type": "cyclone", "spawn_x": 50, "spawn_y": -60, "delay": 0, "overrides": { "health": 90, "speed": 180, "movementPattern": "descend_and_veer", "firingPattern": "fire_straight_missile", "fireRate": 1200 } },
                { "type": "cyclone", "spawn_x": 550, "spawn_y": -60, "delay": 0, "overrides": { "health": 90, "speed": 180, "movementPattern": "descend_and_veer", "firingPattern": "fire_straight_missile", "fireRate": 1500 } },
                { "type": "gnat", "spawn_x": 100, "spawn_y": -50, "delay": 4000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 800, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 500, "spawn_y": -50, "delay": 6000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 1100, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 200, "spawn_y": -50, "delay": 8000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 900, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 400, "spawn_y": -50, "delay": 10000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 700, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 150, "spawn_y": -50, "delay": 12000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 1000, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 450, "spawn_y": -50, "delay": 14000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 850, "loot": { "type": "money", "value": 50 } } },
                { "type": "gnat", "spawn_x": 250, "spawn_y": -50, "delay": 16000, "overrides": { "movementPattern": "sine_wave_custom", "speed": 110, "sine_frequency": 0.025, "sine_amplitude": 70, "firingPattern": "single_straight_shot", "fireRate": 950, "loot": { "type": "money", "value": 50 } } }
            ]
        },
        {
            "wave_id": "wave_03_reaper_crossfire",
            "delay_after_previous_wave_ms": 4000,
            "enemies": [
                {
                    "type": "reaper", "spawn_x": 50, "spawn_y": -50, "delay": 0,
                    "overrides": { "movementPattern": "descend_and_strafe_right", "trigger_y": 300, "speed": 120, "firingPattern": "fire_straight_missile", "fireRate": 1800 }
                },
                {
                    "type": "reaper", "spawn_x": 100, "spawn_y": -50, "delay": 500,
                    "overrides": { "movementPattern": "descend_and_strafe_right", "trigger_y": 350, "speed": 120, "firingPattern": "fire_straight_missile", "fireRate": 2200 }
                },
                {
                    "type": "cutter", "spawn_x": 50, "spawn_y": -50, "delay": 4000,
                    "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 1500 }
                },
                {
                    "type": "cutter", "spawn_x": 550, "spawn_y": -50, "delay": 4000,
                    "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 1800 }
                },
                {
                    "type": "reaper", "spawn_x": 500, "spawn_y": -50, "delay": 8000,
                    "overrides": { "movementPattern": "descend_and_strafe_left", "trigger_y": 300, "speed": 120, "firingPattern": "fire_straight_missile", "fireRate": 1600 }
                },
                {
                    "type": "reaper", "spawn_x": 550, "spawn_y": -50, "delay": 8500,
                    "overrides": { "movementPattern": "descend_and_strafe_left", "trigger_y": 350, "speed": 120, "firingPattern": "fire_straight_missile", "fireRate": 2000 }
                }
            ]
        },
        {
            "wave_id": "wave_04_striker_zigzag_and_darts",
            "delay_after_previous_wave_ms": 4000,
            "enemies": [
                { "type": "striker", "spawn_x": 150, "spawn_y": -100, "delay": 0,    "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 1200, "speed": 90 }},
                { "type": "striker", "spawn_x": 200, "spawn_y": -50,  "delay": 500,  "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 900, "speed": 90 }},
                { "type": "striker", "spawn_x": 150, "spawn_y": -150, "delay": 1000, "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 1100, "speed": 90 }},
                { "type": "striker", "spawn_x": 200, "spawn_y": -100, "delay": 1500, "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 800, "speed": 90 }},
                { "type": "striker", "spawn_x": 450, "spawn_y": -100, "delay": 3000, "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 1000, "speed": 90 }},
                { "type": "striker", "spawn_x": 500, "spawn_y": -50,  "delay": 3500, "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 750, "speed": 90 }},
                { "type": "striker", "spawn_x": 450, "spawn_y": -150, "delay": 4000, "overrides": { "movementPattern": "move_straight_down", "firingPattern": "single_straight_shot", "fireRate": 950, "speed": 90 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 50, "delay": 6000, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 30, "delay": 6150, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 10, "delay": 6300, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 50, "delay": 8000, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 30, "delay": 8150, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 10, "delay": 8300, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 50, "delay": 10000, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 30, "delay": 10150, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": -30, "spawn_y": 10, "delay": 10300, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 50, "delay": 12000, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 30, "delay": 12150, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }},
                { "type": "dart", "spawn_x": 630, "spawn_y": 10, "delay": 12300, "overrides": { "movementPattern": "swoop_and_dash", "firingPattern": "none", "speed": 40 }}
            ]
        },
        {
            "wave_id": "wave_05_goliath_and_gnats",
            "delay_after_previous_wave_ms": 5000,
            "enemies": [
                { "type": "cutter", "spawn_x": 50, "spawn_y": -50, "delay": 0, "overrides": { "movementPattern": "move_diagonal", "speed": 200, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 550, "spawn_y": -50, "delay": 0, "overrides": { "movementPattern": "move_diagonal", "speed": 200, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 100, "spawn_y": -50, "delay": 1500, "overrides": { "movementPattern": "move_diagonal", "speed": 200, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 500, "spawn_y": -50, "delay": 1500, "overrides": { "movementPattern": "move_diagonal", "speed": 200, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "goliath", "spawn_x": 100, "spawn_y": -100, "delay": 4000, "overrides": { "health": 450, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }},
                { "type": "goliath", "spawn_x": 500, "spawn_y": -100, "delay": 6000, "overrides": { "health": 450, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }},
                { "type": "goliath", "spawn_x": 100, "spawn_y": -100, "delay": 8000, "overrides": { "health": 450, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }},
                { "type": "gnat", "spawn_x": 50, "spawn_y": -50, "delay": 11000, "overrides": { "movementPattern": "sweep", "firingPattern": "single_straight_shot", "loot": { "type": "money", "value": 50 } }},
                { "type": "gnat", "spawn_x": 550, "spawn_y": -50, "delay": 12000, "overrides": { "movementPattern": "sweep", "firingPattern": "single_straight_shot", "loot": { "type": "money", "value": 50 } }},
                { "type": "gnat", "spawn_x": 250, "spawn_y": -50, "delay": 13000, "overrides": { "movementPattern": "sweep", "firingPattern": "single_straight_shot", "loot": { "type": "money", "value": 50 } }},
                { "type": "gnat", "spawn_x": 350, "spawn_y": -50, "delay": 14000, "overrides": { "movementPattern": "sweep", "firingPattern": "single_straight_shot", "loot": { "type": "money", "value": 50 } }},
                { "type": "gnat", "spawn_x": 150, "spawn_y": -50, "delay": 15000, "overrides": { "movementPattern": "sweep", "firingPattern": "single_straight_shot", "loot": { "type": "money", "value": 50 } }},
                { "type": "gnat", "spawn_x": 300, "spawn_y": -50, "delay": 17000, "overrides": { "movementPattern": "strafe_out_and_in", "firingPattern": "none", "speed": 80 }},
                { "type": "gnat", "spawn_x": 300, "spawn_y": -50, "delay": 17500, "overrides": { "movementPattern": "strafe_out_and_in", "firingPattern": "none", "speed": 80 }}
            ]
        },
        {
            "wave_id": "wave_06_minefield",
            "delay_after_previous_wave_ms": 4000,
            "enemies": [
                { "type": "mine", "spawn_x": 120, "spawn_y": -50, "delay": 0, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 300, "spawn_y": -80, "delay": 300, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 480, "spawn_y": -50, "delay": 600, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 600, "spawn_y": -100, "delay": 800, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                
                { "type": "mine", "spawn_x": 80,  "spawn_y": -70, "delay": 2000, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 65, "turn_speed": 0.9 }},
                { "type": "mine", "spawn_x": 220, "spawn_y": -120, "delay": 2300, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 65, "turn_speed": 0.9 }},
                { "type": "mine", "spawn_x": 420, "spawn_y": -90, "delay": 2600, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 65, "turn_speed": 0.9 }},
                { "type": "mine", "spawn_x": 580, "spawn_y": -140, "delay": 2900, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 65, "turn_speed": 0.9 }},

                { "type": "mine", "spawn_x": 150, "spawn_y": -150, "delay": 4000, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 350, "spawn_y": -180, "delay": 4300, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 500, "spawn_y": -160, "delay": 4600, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }},
                { "type": "mine", "spawn_x": 650, "spawn_y": -200, "delay": 4900, "overrides": { "movementPattern": "slow_homing", "firingPattern": "none", "speed": 60, "turn_speed": 0.8 }}
            ]
        },
        {
            "wave_id": "wave_07_grand_assault",
            "delay_after_previous_wave_ms": 6000,
            "enemies": [
                { "type": "striker", "spawn_x": 300, "spawn_y": -50, "delay": 0, "overrides": { "movementPattern": "move_straight_down", "speed": 100, "firingPattern": "none" }},
                { "type": "striker", "spawn_x": 250, "spawn_y": -100, "delay": 0, "overrides": { "movementPattern": "split_and_descend", "split_y": 150, "split_direction": -1, "speed": 100, "firingPattern": "single_straight_shot", "fireRate": 2000 }},
                { "type": "striker", "spawn_x": 350, "spawn_y": -100, "delay": 0, "overrides": { "movementPattern": "split_and_descend", "split_y": 150, "split_direction": 1, "speed": 100, "firingPattern": "single_straight_shot", "fireRate": 2000 }},
                { "type": "striker", "spawn_x": 500, "spawn_y": -50, "delay": 3000, "overrides": { "movementPattern": "descend_and_converge", "speed": 90, "firingPattern": "single_aimed_shot", "fireRate": 2800 }},
                { "type": "striker", "spawn_x": 550, "spawn_y": -80, "delay": 3000, "overrides": { "movementPattern": "descend_and_converge", "speed": 90, "firingPattern": "single_aimed_shot", "fireRate": 2800 }},
                { "type": "striker", "spawn_x": 100, "spawn_y": -50, "delay": 3000, "overrides": { "movementPattern": "descend_and_converge", "speed": 90, "firingPattern": "single_aimed_shot", "fireRate": 2800 }},
                { "type": "striker", "spawn_x": 150, "spawn_y": -80, "delay": 3000, "overrides": { "movementPattern": "descend_and_converge", "speed": 90, "firingPattern": "single_aimed_shot", "fireRate": 2800 }},
                { "type": "striker", "spawn_x": 275, "spawn_y": -50, "delay": 6000, "overrides": { "movementPattern": "descend_and_diverge", "diverge_y": 200, "speed": 110, "firingPattern": "single_straight_shot" }},
                { "type": "striker", "spawn_x": 325, "spawn_y": -50, "delay": 6000, "overrides": { "movementPattern": "descend_and_diverge", "diverge_y": 200, "speed": 110, "firingPattern": "single_straight_shot" }},
                { "type": "striker", "spawn_x": 275, "spawn_y": -100, "delay": 7000, "overrides": { "movementPattern": "descend_and_diverge", "diverge_y": 250, "speed": 110, "firingPattern": "single_aimed_shot" }},
                { "type": "striker", "spawn_x": 325, "spawn_y": -100, "delay": 7000, "overrides": { "movementPattern": "descend_and_diverge", "diverge_y": 250, "speed": 110, "firingPattern": "single_aimed_shot" }},
                { "type": "striker", "spawn_x": 300, "spawn_y": -100, "delay": 7000, "overrides": { "movementPattern": "move_straight_down", "speed": 110, "firingPattern": "single_aimed_shot" }},
                { "type": "cyclone", "spawn_x": 300, "spawn_y": -50, "delay": 8500, "overrides": { "movementPattern": "move_straight_down", "speed": 400, "firingPattern": "three_round_spread", "fireRate": 1000 }}
            ]
        },
        {
            "wave_id": "wave_08_crossfire",
            "delay_after_previous_wave_ms": 6000,
            "enemies": [
                { "type": "reaper", "spawn_x": 50, "spawn_y": -50, "delay": 0, "overrides": { "movementPattern": "descend_and_strafe_right", "speed": 130, "firingPattern": "fire_straight_missile", "fireRate": 3000 }},
                { "type": "reaper", "spawn_x": 100, "spawn_y": -50, "delay": 500, "overrides": { "movementPattern": "descend_and_strafe_right", "speed": 130, "firingPattern": "fire_straight_missile", "fireRate": 3000 }},
                { "type": "cyclone", "spawn_x": 550, "spawn_y": -50, "delay": 2000, "overrides": { "movementPattern": "criss_cross", "speed": 250, "firingPattern": "three_round_spread", "fireRate": 2000 }},
                { "type": "cyclone", "spawn_x": 100, "spawn_y": -50, "delay": 3000, "overrides": { "movementPattern": "criss_cross", "speed": 250, "firingPattern": "three_round_spread", "fireRate": 2000 }},
                { "type": "reaper", "spawn_x": 550, "spawn_y": -50, "delay": 5000, "overrides": { "movementPattern": "descend_and_strafe_left", "speed": 130, "firingPattern": "fire_straight_missile", "fireRate": 3000 }},
                { "type": "reaper", "spawn_x": 500, "spawn_y": -50, "delay": 5500, "overrides": { "movementPattern": "descend_and_strafe_left", "speed": 130, "firingPattern": "fire_straight_missile", "fireRate": 3000 }}
            ]
        },
        {
            "wave_id": "wave_09_heavy_hitters",
            "delay_after_previous_wave_ms": 4000,
            "enemies": [
                { "type": "goliath", "spawn_x": 300, "spawn_y": -100, "delay": 0, "overrides": { "health": 500, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }},
                { "type": "goliath", "spawn_x": 450, "spawn_y": -100, "delay": 4000, "overrides": { "health": 500, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }},
                { "type": "goliath", "spawn_x": 150, "spawn_y": -100, "delay": 8000, "overrides": { "health": 500, "speed": 40, "movementPattern": "move_straight_down", "firingPattern": "wide_v_shot", "fireRate": 2000 }}
            ]
        },
        {
            "wave_id": "wave_10_final_swarm",
            "delay_after_previous_wave_ms": 4000,
            "enemies": [
                { "type": "striker", "spawn_x": 150, "spawn_y": -100, "delay": 0, "overrides": { "movementPattern": "zigzag", "speed": 90, "horizontal_speed": 120, "firingPattern": "single_straight_shot", "fireRate": 2500 }},
                { "type": "striker", "spawn_x": 200, "spawn_y": -50, "delay": 500, "overrides": { "movementPattern": "zigzag", "speed": 90, "horizontal_speed": 120, "firingPattern": "single_straight_shot", "fireRate": 2500 }},
                { "type": "striker", "spawn_x": 150, "spawn_y": -150, "delay": 1000, "overrides": { "movementPattern": "zigzag", "speed": 90, "horizontal_speed": 120, "firingPattern": "single_straight_shot", "fireRate": 2500 }},
                { "type": "striker", "spawn_x": 200, "spawn_y": -200, "delay": 1500, "overrides": { "movementPattern": "zigzag", "speed": 90, "horizontal_speed": 120, "firingPattern": "single_straight_shot", "fireRate": 2500 }},
                { "type": "cutter", "spawn_x": 50, "spawn_y": -50, "delay": 2500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 550, "spawn_y": -50, "delay": 2500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 100, "spawn_y": -50, "delay": 3500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 500, "spawn_y": -50, "delay": 3500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 50, "spawn_y": -50, "delay": 4500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }},
                { "type": "cutter", "spawn_x": 550, "spawn_y": -50, "delay": 4500, "overrides": { "movementPattern": "move_diagonal", "speed": 220, "firingPattern": "burst_fire", "fireRate": 3000 }}
            ]
        },
        {
            "wave_id": "wave_11_boss_finale",
            "delay_after_previous_wave_ms": 5000,
            "enemies": [
                {
                    "type": "boss1",
                    "spawn_x": 272,
                    "spawn_y": -150,
                    "delay": 2000,
                    "overrides": {
                        "health": 2500,
                        "speed": 90,
                        "movementPattern": "boss_patrol",
                        "firingPattern": "boss_multi_weapon_fire",
                        "straightFireRate": 2000,
                        "aimedFireRate": 3200
                    }
                }
            ]
        }
    ]
}
</file>

<file path="js/states/gameState.js">
/**
 * GameState class
 * Handles the main gameplay state
 */
import { Level1 } from '../levels/level1.js';
import { Level2 } from '../levels/level2.js';
import { Player } from '../entities/player.js';
import { HUD } from '../ui/hud.js';
import { BackgroundManager } from '../environment/BackgroundManager.js';
import { EffectManager } from '../engine/effectManager.js';
import { logger } from '../utils/logger.js';

class GameState {
    constructor(game) {
        this.game = game;
        this.name = 'game';  // Add name property for state identification
        this.level = 1;
        this.player = null;
        this.currentLevel = null;
        this.hud = null;
        this.backgroundManager = null; // Changed from this.background
        this.gameTime = 0;
        this.levelComplete = false;
        this.levelCompleteTime = 0;
        this.levelCompleteDelay = 3000; // 3 seconds before next level
        this.isInitializing = false;
        this.debugMode = true; // Add debug mode flag
        this.effectManager = new EffectManager(); // Add effect manager
    }

    /**
     * Enter the game state
     */
    async enter() {
        logger.info('Entering Game State');

        // Prevent multiple rapid transitions
        if (this.isInitializing) return;
        this.isInitializing = true;

        // Initialize game components
        await this.initializeGame();

        // Reset initialization flag after a short delay
        setTimeout(() => {
            this.isInitializing = false;
        }, 1000);
    }

    /**
     * Initialize game components
     */
    async initializeGame() {
        // Clear all old entities from the collision system to prevent "ghost" collisions.
        this.game.collision.clearAll();

        // Clear existing entities from the entity manager.
        this.game.entityManager.clear();

        // Reset game state
        this.gameTime = 0;
        this.levelComplete = false;
        this.level = 1;

        // Create player
        this.player = new Player(this.game, this.game.width / 2 - 32, this.game.height - 100);
        this.player.loadSprites();
        this.game.entityManager.add(this.player);
        this.game.collision.addToGroup(this.player, 'player');
        this.game.player = this.player; // Store a global reference

        // Create HUD
        this.hud = new HUD(this.game);

        // Initialize the current level
        await this.initializeLevel();

        // Start level music
        this.game.audio.playMusic('level1Music');
    }

    /**
     * Initialize the current level
     */
    async initializeLevel() {
        if (this.currentLevel) {
            this.currentLevel.cleanup();
        }

        if (this.level === 1) {
            this.currentLevel = await new Level1(this.game).init(); // Use await for async init
        } else if (this.level === 2) {
            this.currentLevel = new Level2(this.game);
            this.currentLevel.init(); // Level2 still uses sync init for now
        } else {
            // No more levels, game is won
            this.game.changeState('gameover');
            return;
        }
    }

    /**
     * Update the game state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        if (this.game.currentState !== this) return;

        if (this.game.states.pause && this.game.states.pause.isPaused) return;

        // (Your existing debug mode toggles can stay here)
        if (this.game.input.wasKeyJustPressed('1')) {
            this.debugMode = !this.debugMode;
            logger.debug(`Debug mode ${this.debugMode ? 'enabled' : 'disabled'}`);
        }

        // Restart level with '3' key (debug)
        if (this.game.input.restartLevelPressed) {
            logger.debug('Restarting current level...');
            this.restartLevel();
            this.game.input.restartLevelPressed = false; // Reset the flag
        }

        this.gameTime += deltaTime;

        if (this.currentLevel) {
            this.currentLevel.update(deltaTime);
        }

        this.game.entityManager.update(deltaTime);

        this.game.collision.checkCollisions();

        // Update effect manager
        this.effectManager.update(deltaTime);

        // (Your existing logic for debug invincibility, level completion, game over, etc., can stay here)
        if (this.debugMode && this.player) {
            this.player.health = this.player.maxHealth;
        }

        // Check for level completion
        if (!this.levelComplete && this.currentLevel && this.currentLevel.isComplete()) {
            this.levelComplete = true;
            this.levelCompleteTime = this.gameTime;
        }

        // Handle level completion delay
        if (this.levelComplete) {
            if (this.gameTime - this.levelCompleteTime > this.levelCompleteDelay) {
                this.completeLevel();
            }
        }

        // Check for game over
        if (!this.player || !this.player.active) {
            this.game.changeState('gameover');
            return;
        }

        // Check for pause - use the overlay approach
        if (this.game.input.isKeyPressed('Escape') || this.game.input.isKeyPressed('p')) {
            if (this.game.states.pause) {
                this.game.states.pause.togglePause();
            }
        }
    }

    /**
     * Render the game state
     * @param {Object} contexts - The canvas rendering contexts
     */
    render(contexts) {
        if (this.currentLevel) {
            this.currentLevel.render(contexts);
        }
        this.game.entityManager.render(contexts);
        this.effectManager.render(contexts.explosion);
        this.hud.render(contexts.ui);

        // Debug rendering to help identify issues
        if (this.debugMode) {
            const ctx = contexts.ui;

            // --- NEW FONT STYLE ---
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'white';     // Set the main text color to white
            ctx.strokeStyle = 'black';   // Set the outline color to black
            ctx.lineWidth = 4;           // Make the outline thick enough to be visible
            // ----------------------

            // --- UPDATED DRAWING LOGIC ---
            // For each line of text, we now draw the outline first, then the fill.
            ctx.strokeText('DEBUG MODE', 10, 30);
            ctx.fillText('DEBUG MODE', 10, 30);

            // 1. FPS (Frames Per Second)
            const fps = this.game.currentFPS || 0;
            ctx.strokeText(`FPS: ${fps}`, 10, 60);
            ctx.fillText(`FPS: ${fps}`, 10, 60);

            // 2. Current Game State
            const currentStateName = this.game.currentState.constructor.name;
            ctx.strokeText(`State: ${currentStateName}`, 10, 90);
            ctx.fillText(`State: ${currentStateName}`, 10, 90);

            // 3. Level/Wave Information (only show when in a level)
            if (this.currentLevel && this.currentLevel.levelData) {
                const waveIndex = this.currentLevel.waveIndex || 0;
                const totalWaves = this.currentLevel.levelData.waves ? this.currentLevel.levelData.waves.length : 0;
                ctx.strokeText(`Wave: ${waveIndex + 1} / ${totalWaves}`, 10, 120);
                ctx.fillText(`Wave: ${waveIndex + 1} / ${totalWaves}`, 10, 120);

                // Show next spawn timer if available
                if (this.currentLevel.waveStartTime !== undefined && this.currentLevel.levelTime !== undefined) {
                    const waveTime = this.currentLevel.levelTime - this.currentLevel.waveStartTime;
                    const currentWave = this.currentLevel.levelData.waves[waveIndex];
                    if (currentWave && currentWave.enemies) {
                        const nextSpawn = currentWave.enemies.find(e => !e.spawned);
                        if (nextSpawn) {
                            const timeUntilSpawn = Math.max(0, nextSpawn.delay - waveTime);
                            ctx.strokeText(`Next Spawn In: ${Math.round(timeUntilSpawn / 1000)}s`, 10, 150);
                            ctx.fillText(`Next Spawn In: ${Math.round(timeUntilSpawn / 1000)}s`, 10, 150);
                        }
                    }
                }
            }

            // Show player position and status
            if (this.player) {
                ctx.strokeText(`Player: ${Math.floor(this.player.x)}, ${Math.floor(this.player.y)}`, 10, 180);
                ctx.fillText(`Player: ${Math.floor(this.player.x)}, ${Math.floor(this.player.y)}`, 10, 180);
                ctx.strokeText(`Health: ${this.player.health}`, 10, 210);
                ctx.fillText(`Health: ${this.player.health}`, 10, 210);
                ctx.strokeText(`Visible: ${this.player.visible}`, 10, 240);
                ctx.fillText(`Visible: ${this.player.visible}`, 10, 240);
            } else {
                ctx.strokeText('Player: NULL', 10, 180);
                ctx.fillText('Player: NULL', 10, 180);
            }

            // Show game dimensions
            ctx.strokeText(`Game: ${this.game.width}x${this.game.height}`, 10, 270);
            ctx.fillText(`Game: ${this.game.width}x${this.game.height}`, 10, 270);

            // Show entity counts
            const entities = this.game.entityManager.entities;
            ctx.strokeText(`Entities: ${entities.length}`, 10, 300);
            ctx.fillText(`Entities: ${entities.length}`, 10, 300);

            // Show canvas contexts
            const contextKeys = Object.keys(contexts);
            ctx.strokeText(`Contexts: ${contextKeys.join(', ')}`, 10, 330);
            ctx.fillText(`Contexts: ${contextKeys.join(', ')}`, 10, 330);
        }

        // Render level complete message if needed
        if (this.levelComplete) {
            this.renderLevelComplete();
        }
    }

    /**
     * Render level complete message
     */
    renderLevelComplete() {
        const ctx = this.game.contexts.ui;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, this.game.width, this.game.height);

        ctx.fillStyle = '#ffcc00';
        ctx.font = '36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Level ${this.level} Complete!`, this.game.width / 2, this.game.height / 2 - 20);

        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.fillText('Loading next level...', this.game.width / 2, this.game.height / 2 + 30);
    }

    /**
     * Complete the current level and move to the next
     */
    completeLevel() {
        // Sync player stats with playerData before leaving
        if (this.player && this.game.playerData) {
            this.game.playerData.health = this.player.health;
            this.game.playerData.money = this.player.money;
            this.game.playerData.score = this.player.score;
            this.game.playerData.shield = this.player.shield;
            this.game.playerData.unlockedWeapons = this.player.unlockedWeapons;

            // Save to localStorage
            try {
                localStorage.setItem('raptor_manus_save', JSON.stringify(this.game.playerData));
                logger.info('Player data saved after level completion:', this.game.playerData);
            } catch (error) {
                logger.error('Error saving player data after level completion:', error);
            }
        }

        this.game.changeState('hangar');
    }

    /**
     * Restart the current level (debug function)
     */
    async restartLevel() {
        logger.info(`Restarting level ${this.level}...`);

        // Reset level completion state
        this.levelComplete = false;
        this.levelCompleteTime = 0;

        // Clear all entities except the player
        this.game.collision.clearAll();
        this.game.entityManager.clear();

        // Re-add the player
        this.game.entityManager.add(this.player);
        this.game.collision.addToGroup(this.player, 'player');

        // Reset player position to starting position
        this.player.x = this.game.width / 2 - 32;
        this.player.y = this.game.height - 100;

        // Reset player health and shields (optional - comment out if you want to keep current health)
        // this.player.health = this.player.maxHealth;
        // this.player.shields = this.player.maxShields;

        // Reinitialize the current level
        await this.initializeLevel();

        logger.info(`Level ${this.level} restarted successfully`);
    }

    /**
     * Cycles to the next level for debugging purposes.
     * If the current level is the last one, it loops back to the first level.
     */
    async cycleLevel() {
        logger.info("Cycling level...");
        this.level++;
        // Assuming you have a maximum number of levels, e.g., 2
        const maxLevels = 2; // Adjust this based on your actual number of levels
        if (this.level > maxLevels) {
            this.level = 1;
        }

        // Reset level completion state
        this.levelComplete = false;
        this.levelCompleteTime = 0;

        // Clear all entities except the player
        this.game.collision.clearAll();
        this.game.entityManager.clear();

        // Re-add the player
        this.game.entityManager.add(this.player);
        this.game.collision.addToGroup(this.player, 'player');

        // Reset player position to starting position
        this.player.x = this.game.width / 2 - 32;
        this.player.y = this.game.height - 100;

        // Reinitialize the current level
        await this.initializeLevel();

        logger.info(`Cycled to level ${this.level}`);
    }

    /**
     * Exit the game state
     */
    exit() {
        logger.info('Exiting Game State');

        // Clear effect manager
        this.effectManager.clear();

        // Full cleanup when leaving the game
        if (this.currentLevel && typeof this.currentLevel.cleanup === 'function') {
            this.currentLevel.cleanup();
        }

        // Clear references
        this.game.player = null;
        this.currentLevel = null;
    }
}

export { GameState };
</file>

<file path="js/states/hangar.js">
/**
 * HangarState class
 * Represents the hangar screen between missions
 */
import { logger } from '../utils/logger.js';
class HangarState {
    constructor(game) {
        this.game = game;
        this.background = null;
        this.menuOptions = [
            { text: 'Choose Mission', action: () => this.chooseNextMission() },
            { text: 'Shop (Upgrades & Repairs)', action: () => this.openShop() },
            { text: 'Save Game', action: () => this.saveGame() },
            { text: 'Exit to Main Menu', action: () => this.exitToMenu() }
        ];
        this.selectedOption = 0;
        this.playerMoney = 0;
    }

    /**
     * Enter the hangar state
     */
    enter() {
        this.playerMoney = this.game.playerData.money;
        document.getElementById('hangar-screen').style.display = 'flex';
        
        // Get background from assets
        this.background = this.game.assets.getImage('hangarBackground');
        
        this.setupHangarScreen();
    }

    setupHangarScreen() {
        const hangarScreen = document.getElementById('hangar-screen');
        hangarScreen.innerHTML = '';

        // Main container
        const mainContainer = document.createElement('div');
        mainContainer.style.display = 'flex';
        mainContainer.style.flexDirection = 'column';
        mainContainer.style.alignItems = 'center';
        mainContainer.style.justifyContent = 'center';
        mainContainer.style.width = '100%';
        mainContainer.style.height = '100%';
        mainContainer.style.position = 'relative';
        mainContainer.style.overflow = 'hidden';

        // Add background image if available
        if (this.background) {
            const bgImg = document.createElement('img');
            bgImg.src = this.background.src;
            bgImg.style.width = '100%';
            bgImg.style.height = '100%';
            bgImg.style.objectFit = 'cover';
            bgImg.style.position = 'absolute';
            bgImg.style.top = '0';
            bgImg.style.left = '0';
            bgImg.style.zIndex = '1';
            mainContainer.appendChild(bgImg);
        }

        // Create overlay for better text readability
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '2';
        mainContainer.appendChild(overlay);

        // Create content container
        const contentContainer = document.createElement('div');
        contentContainer.style.display = 'flex';
        contentContainer.style.flexDirection = 'column';
        contentContainer.style.alignItems = 'center';
        contentContainer.style.justifyContent = 'center';
        contentContainer.style.position = 'absolute';
        contentContainer.style.top = '0';
        contentContainer.style.left = '0';
        contentContainer.style.width = '100%';
        contentContainer.style.height = '100%';
        contentContainer.style.zIndex = '3';

        // Choose Mission button - left lower third
        const chooseMissionBtn = document.createElement('div');
        chooseMissionBtn.textContent = 'Choose Mission';
        chooseMissionBtn.style.color = 'white';
        chooseMissionBtn.style.fontSize = '32px';
        chooseMissionBtn.style.padding = '15px 30px';
        chooseMissionBtn.style.cursor = 'pointer';
        chooseMissionBtn.style.borderRadius = '8px';
        chooseMissionBtn.style.transition = 'all 0.2s';
        chooseMissionBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        chooseMissionBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        chooseMissionBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        chooseMissionBtn.style.position = 'absolute';
        chooseMissionBtn.style.bottom = '33%';
        chooseMissionBtn.style.left = '20%';
        chooseMissionBtn.style.transform = 'translateX(-50%)';
        chooseMissionBtn.style.zIndex = '3';

        chooseMissionBtn.addEventListener('mouseover', () => {
            chooseMissionBtn.style.color = '#ffcc00';
            chooseMissionBtn.style.textShadow = '0 0 15px #ffcc00';
            chooseMissionBtn.style.borderColor = '#ffcc00';
        });
        
        chooseMissionBtn.addEventListener('mouseout', () => {
            chooseMissionBtn.style.color = 'white';
            chooseMissionBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            chooseMissionBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        chooseMissionBtn.addEventListener('click', () => this.chooseNextMission());
        contentContainer.appendChild(chooseMissionBtn);

        // Shop button - right lower third
        const shopBtn = document.createElement('div');
        shopBtn.textContent = 'Shop';
        shopBtn.style.color = 'white';
        shopBtn.style.fontSize = '32px';
        shopBtn.style.padding = '15px 30px';
        shopBtn.style.cursor = 'pointer';
        shopBtn.style.borderRadius = '8px';
        shopBtn.style.transition = 'all 0.2s';
        shopBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        shopBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        shopBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        shopBtn.style.position = 'absolute';
        shopBtn.style.bottom = '33%';
        shopBtn.style.right = '20%';
        shopBtn.style.transform = 'translateX(50%)';
        shopBtn.style.zIndex = '3';

        shopBtn.addEventListener('mouseover', () => {
            shopBtn.style.color = '#ffcc00';
            shopBtn.style.textShadow = '0 0 15px #ffcc00';
            shopBtn.style.borderColor = '#ffcc00';
        });
        
        shopBtn.addEventListener('mouseout', () => {
            shopBtn.style.color = 'white';
            shopBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            shopBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        shopBtn.addEventListener('click', () => this.openShop());
        contentContainer.appendChild(shopBtn);

        // Save Game button - right upper third
        const saveGameBtn = document.createElement('div');
        saveGameBtn.textContent = 'Save Game';
        saveGameBtn.style.color = 'white';
        saveGameBtn.style.fontSize = '32px';
        saveGameBtn.style.padding = '15px 30px';
        saveGameBtn.style.cursor = 'pointer';
        saveGameBtn.style.borderRadius = '8px';
        saveGameBtn.style.transition = 'all 0.2s';
        saveGameBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        saveGameBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        saveGameBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        saveGameBtn.style.position = 'absolute';
        saveGameBtn.style.top = '33%';
        saveGameBtn.style.right = '20%';
        saveGameBtn.style.transform = 'translateX(50%)';
        saveGameBtn.style.zIndex = '3';

        saveGameBtn.addEventListener('mouseover', () => {
            saveGameBtn.style.color = '#ffcc00';
            saveGameBtn.style.textShadow = '0 0 15px #ffcc00';
            saveGameBtn.style.borderColor = '#ffcc00';
        });
        
        saveGameBtn.addEventListener('mouseout', () => {
            saveGameBtn.style.color = 'white';
            saveGameBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            saveGameBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        saveGameBtn.addEventListener('click', () => this.saveGame());
        contentContainer.appendChild(saveGameBtn);

        // Exit to Main Menu button - moved down slightly
        const exitBtn = document.createElement('div');
        exitBtn.textContent = 'Exit to Main Menu';
        exitBtn.style.color = 'white';
        exitBtn.style.fontSize = '32px';
        exitBtn.style.padding = '15px 30px';
        exitBtn.style.cursor = 'pointer';
        exitBtn.style.borderRadius = '8px';
        exitBtn.style.transition = 'all 0.2s';
        exitBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        exitBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        exitBtn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        exitBtn.style.position = 'absolute';
        exitBtn.style.bottom = '15%';
        exitBtn.style.left = '50%';
        exitBtn.style.transform = 'translateX(-50%)';
        exitBtn.style.zIndex = '3';

        exitBtn.addEventListener('mouseover', () => {
            exitBtn.style.color = '#ffcc00';
            exitBtn.style.textShadow = '0 0 15px #ffcc00';
            exitBtn.style.borderColor = '#ffcc00';
        });
        
        exitBtn.addEventListener('mouseout', () => {
            exitBtn.style.color = 'white';
            exitBtn.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            exitBtn.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        });
        
        exitBtn.addEventListener('click', () => this.exitToMenu());
        contentContainer.appendChild(exitBtn);

        // Instructions
        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.bottom = '20px';
        instructions.style.right = '20px';
        instructions.style.color = '#aaa';
        instructions.style.fontSize = '16px';
        instructions.style.textAlign = 'right';
        instructions.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        instructions.style.padding = '10px';
        instructions.style.borderRadius = '5px';
        instructions.style.border = '1px solid #333';
        instructions.style.zIndex = '4';
        instructions.innerHTML = 'Click buttons to navigate';
        mainContainer.appendChild(instructions);

        // Add contentContainer to mainContainer
        mainContainer.appendChild(contentContainer);
        hangarScreen.appendChild(mainContainer);
    }

    /**
     * Update the hangar state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Keyboard shortcuts for direct navigation
        if (this.game.input.wasKeyJustPressed('1') || this.game.input.wasKeyJustPressed('m')) {
            this.chooseNextMission();
        }
        if (this.game.input.wasKeyJustPressed('2') || this.game.input.wasKeyJustPressed('s')) {
            this.openShop();
        }
        if (this.game.input.wasKeyJustPressed('3')) {
            this.saveGame();
        }
        if (this.game.input.wasKeyJustPressed('4') || this.game.input.wasKeyJustPressed('e')) {
            this.exitToMenu();
        }
    }

    /**
     * Render the hangar screen
     * @param {Object} contexts - Object containing all canvas contexts
     */
    render(contexts) {
        // Hangar is rendered using HTML/CSS in the hangar-screen element
    }

    chooseNextMission() {
        document.getElementById('hangar-screen').style.display = 'none';
        this.game.changeState('game');
    }

    openShop() {
        document.getElementById('hangar-screen').style.display = 'none';
        this.game.changeState('shop');
    }

    saveGame() {
        alert('Game saved! (Stub)');
    }

    exitToMenu() {
        document.getElementById('hangar-screen').style.display = 'none';
        this.game.changeState('menu');
    }

    exit() {
        document.getElementById('hangar-screen').style.display = 'none';
        logger.info('Exiting Hangar State');
    }
}

export { HangarState };
</file>

<file path="js/levels/level1.js">
/**
 * Level1 class
 * Implements the first level of the game with data-driven configuration
 */
import { EnemyFactory } from '../entities/enemyFactory.js';
import { EnvironmentFactory } from '../entities/environmentFactory.js';
import { BackgroundManager } from '../environment/BackgroundManager.js';
import { Tilemap } from '../environment/tilemap.js';
import { logger } from '../utils/logger.js';

class Level1 {
    constructor(game) {
        this.game = game;
        this.background = null;
        this.logicalGrid = null; // Renamed from tilemap
        this.enemyFactory = null;
        this.waveIndex = 0;
        this.levelTime = 0;
        this.waveStartTime = 0;
        this.bossSpawned = false;
        this.bossDefeated = false;
        this.levelComplete = false;
        this.showBossWarning = false;
        this.bossWarningTimer = 0;
        this.bossWarningDuration = 3000;
        this.bossHealthBarFill = 0;
        this.transitioning = false;
        this.environmentFactory = null;
    }

    /**
     * Initialize the level - this is the async constructor equivalent
     */
    async init() {
        try {
            const response = await fetch('js/levels/level1.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            this.levelData = await response.json();
            logger.info(`Successfully loaded level data: ${this.levelData.levelName}`);

            // 1. Create scrolling background
            const bgImage = this.game.assets.getImage('backgroundLevel1');
            this.background = new BackgroundManager(this.game, bgImage, 50); // Use your desired scroll speed

            // 2. Create the logical grid (the old tilemap)
            this.logicalGrid = new Tilemap(this.game, this.levelData.tilemap, 50); // Must use same scroll speed!

            // Create enemy factory
            this.enemyFactory = new EnemyFactory(this.game);

            // Create environment factory
            this.environmentFactory = new EnvironmentFactory(this.game);

            // Reset level state
            this.waveIndex = 0;
            this.levelTime = 0;
            this.waveStartTime = 0;
            this.bossSpawned = false;
            this.bossDefeated = false;
            this.levelComplete = false;
            this.showBossWarning = false;
            this.bossWarningTimer = 0;
            this.bossHealthBarFill = 0;
            this.transitioning = false;

            // Play level music
            this.game.audio.playMusic('gameMusic1');

        } catch (error) {
            logger.error("Failed to load level1.json:", error);
            throw error;
        }
        return this; // Return the instance for chaining
    }

    /**
     * Update the level
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        if (!this.levelData) return;
        if (this.game.input.skipWavePressed) {
            this.forceNextWave();
            this.game.input.skipWavePressed = false;
        }
        this.levelTime += deltaTime;
        this.background.update(deltaTime);
        this.logicalGrid.update(deltaTime);
        if (this.showBossWarning) {
            this.bossWarningTimer += deltaTime;
            this.bossHealthBarFill = Math.min(1, this.bossWarningTimer / this.bossWarningDuration);
            if (this.bossWarningTimer >= this.bossWarningDuration) {
                this.showBossWarning = false;
                this.spawnBoss();
            }
        } else if (!this.bossSpawned) {
            this.updateWave(deltaTime);
        }
        if (this.bossDefeated && !this.transitioning) {
            this.transitioning = true;
            this.levelComplete = true;
            logger.info("Boss defeated! Transitioning to Hangar in 3 seconds...");
            setTimeout(() => {
                this.game.changeState('hangar');
            }, 3000);
        }
    }

    /**
     * Update the current wave
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateWave(deltaTime) {
        if (this.waveIndex >= this.levelData.waves.length) {
            return;
        }
        const currentWave = this.levelData.waves[this.waveIndex];
        currentWave.enemies = currentWave.enemies || [];
        currentWave.environment_objects = currentWave.environment_objects || [];
        const waveTime = this.levelTime - this.waveStartTime;
        currentWave.enemies.forEach(enemyData => {
            if (enemyData.delay <= waveTime && !enemyData.spawned) {
                this.spawnEnemy(enemyData);
                enemyData.spawned = true;
            }
        });
        currentWave.environment_objects.forEach(envData => {
            if (envData.delay <= waveTime && !envData.spawned) {
                this.spawnEnvironmentObject(envData);
                envData.spawned = true;
            }
        });
        const allEnemiesSpawned = currentWave.enemies.every(e => e.spawned);
        const allEnemiesCleared = this.game.collision.collisionGroups.enemies.length === 0;
        if (allEnemiesSpawned && allEnemiesCleared && waveTime > 1000) {
            const nextWave = this.levelData.waves[this.waveIndex + 1];
            if (nextWave && nextWave.isBossWave) {
                this.triggerBossWarning();
            } else {
                this.advanceToNextWave();
            }
        }
    }

    /**
     * Spawn an enemy
     * @param {Object} enemyData - Enemy data object
     */
    spawnEnemy(enemyData) {
        this.enemyFactory.createEnemy(enemyData, this);
    }

    // --- NEW: Spawn Environment Object Method ---
    spawnEnvironmentObject(envData) {
        // Use the environment factory to create destructible objects
        this.environmentFactory.createEnvironmentObject(envData);
    }
    // --- END NEW ---

    advanceToNextWave() {
        if (this.waveIndex < this.levelData.waves.length - 1) {
            this.waveIndex++;
            this.waveStartTime = this.levelTime;
            const nextWaveName = this.levelData.waves[this.waveIndex].name || `Wave ${this.waveIndex + 1}`;
            logger.info(`Starting ${nextWaveName}`);
        }
    }

    forceNextWave() {
        if (!this.levelData) return;
        logger.debug("DEBUG: Forcing next wave.");
        const enemies = this.game.collision.collisionGroups.enemies;
        enemies.forEach(enemy => {
            if (enemy.active) {
                enemy.destroy();
            }
        });
        this.advanceToNextWave();
    }

    triggerBossWarning() {
        if (this.bossSpawned) return;
        this.showBossWarning = true;
        this.bossWarningTimer = 0;
        logger.info("BOSS APPROACHING!");
    }

    spawnBoss() {
        const bossWave = this.levelData.waves.find(w => w.isBossWave);
        if (bossWave && bossWave.enemies.length > 0) {
            const bossData = bossWave.enemies[0];
            this.spawnEnemy(bossData);
            this.bossSpawned = true;
        }
    }

    // --- CONSTANTS FOR PLAYABLE AREA ---
    static PLAYABLE_WIDTH = 960;
    static PLAYABLE_HEIGHT = 720;

    getPlayableOffset() {
        // Center the playable area in the window
        const offsetX = (this.game.width - Level1.PLAYABLE_WIDTH) / 2;
        const offsetY = (this.game.height - Level1.PLAYABLE_HEIGHT) / 2;
        return { offsetX, offsetY };
    }

    getPlayableBounds() {
        const { offsetX, offsetY } = this.getPlayableOffset();
        return {
            left: offsetX,
            top: offsetY,
            right: offsetX + Level1.PLAYABLE_WIDTH,
            bottom: offsetY + Level1.PLAYABLE_HEIGHT
        };
    }

    render(contexts) {
        const { offsetX, offsetY } = this.getPlayableOffset();
        // Render the scrolling background centered
        this.background.render(contexts.background, offsetX, offsetY, Level1.PLAYABLE_WIDTH, Level1.PLAYABLE_HEIGHT);
        // Draw a border around the gameplay area
        const ctx = contexts.background;
        ctx.save();
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#ffcc00';
        ctx.strokeRect(offsetX, offsetY, Level1.PLAYABLE_WIDTH, Level1.PLAYABLE_HEIGHT);
        ctx.restore();
        if (this.showBossWarning) {
            const ctxUI = contexts.ui;
            ctxUI.save();
            ctxUI.font = 'bold 48px Arial';
            ctxUI.fillStyle = 'yellow';
            ctxUI.textAlign = 'center';
            ctxUI.fillText('BOSS APPROACHING', this.game.width / 2, offsetY + 180);
            const barWidth = 400; const barHeight = 20;
            const barX = (this.game.width - barWidth) / 2; const barY = offsetY + 40;
            ctxUI.fillStyle = 'rgba(0,0,0,0.7)';
            ctxUI.fillRect(barX, barY, barWidth, barHeight);
            ctxUI.fillStyle = 'red';
            ctxUI.fillRect(barX, barY, barWidth * this.bossHealthBarFill, barHeight);
            ctxUI.strokeStyle = 'white';
            ctxUI.lineWidth = 2;
            ctxUI.strokeRect(barX, barY, barWidth, barHeight);
            ctxUI.restore();
        }
    }
    /**
     * Check if the level is complete
     * @returns {boolean} True if level is complete, false otherwise
     */
    isComplete() {
        return this.levelComplete;
    }

    /**
     * Cleanup the level when exiting
     */
    cleanup() {
        logger.info('Cleaning up Level1');
        this.levelData = null;
        this.background = null;
        this.logicalGrid = null;
        this.enemyFactory = null;
        this.environmentFactory = null;
        this.waveIndex = 0;
        this.levelTime = 0;
        this.waveStartTime = 0;
        this.bossSpawned = false;
        this.bossDefeated = false;
        this.levelComplete = false;
        this.showBossWarning = false;
        this.bossWarningTimer = 0;
        this.bossHealthBarFill = 0;
        this.transitioning = false;
    }

    resize() {
        if (this.background && typeof this.background.resize === 'function') {
            this.background.resize();
        }
        if (this.logicalGrid && typeof this.logicalGrid.resize === 'function') {
            this.logicalGrid.resize();
        }
    }
}

export { Level1 };
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raptor: Call of the Shadows Reimagined</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="game-container">
        <canvas id="background-layer" class="game-layer"></canvas>
        <canvas id="environment-layer" class="game-layer"></canvas>
        <canvas id="enemy-layer" class="game-layer"></canvas>
        <canvas id="projectile-layer" class="game-layer"></canvas>
        <canvas id="player-layer" class="game-layer"></canvas>
        <canvas id="explosion-layer" class="game-layer"></canvas>
        <canvas id="ui-layer" class="game-layer"></canvas>
        
        <div id="loading-screen" class="screen">Loading...</div>
        <div id="menu-screen" class="screen"></div>
        <div id="game-over-screen" class="screen"></div>
        <div id="hangar-screen" class="screen"></div>
        <div id="character-select-screen" class="screen"></div>
        <div id="shop-screen" class="screen"></div>
    </div>
    
    <script type="module" src="js/main.js"></script>

</body>
</html>
</file>

<file path="js/entities/enemyBehaviors.js">
/**
 * Enemy Behavior Library
 * Contains reusable movement and firing pattern functions for enemies
 */
import { Projectile } from './projectile.js';
import { Missile } from './missile.js';
import { logger } from '../utils/logger.js';

export const movementPatterns = {
    // Enemy just moves based on its default velocity (usually straight down)
    default: function(enemy, deltaTime) {
        // This function is intentionally empty.
        // The base velocity is applied by the parent Entity's update loop.
    },

    // Enemy moves down in a gentle sine wave
    sine_wave_slow: function(enemy, deltaTime) {
        // Initialize pattern state on the enemy if it doesn't exist
        if (enemy.patternState === undefined) {
            enemy.patternState = { initialX: enemy.x, angle: 0 };
        }
        enemy.patternState.angle += 0.02; // Controls speed of oscillation
        enemy.x = enemy.patternState.initialX + Math.sin(enemy.patternState.angle) * 50; // Controls width of oscillation
    },

    // A faster sine wave for more agile enemies.
    sine_wave_fast: function(enemy, deltaTime) {
        // Initialize pattern state on the enemy if it doesn't exist
        if (enemy.patternState === undefined) {
            enemy.patternState = { initialX: enemy.x, angle: 0 };
        }
        // Increase angle faster for more rapid oscillation
        enemy.patternState.angle += 0.05; 
        // Increase amplitude for wider weaving
        enemy.x = enemy.patternState.initialX + Math.sin(enemy.patternState.angle) * 80; 
    },

    // A customizable sine wave pattern with configurable frequency and amplitude
    sine_wave_custom: function(enemy, deltaTime) {
        // Initialize pattern state on the enemy if it doesn't exist
        if (enemy.patternState === undefined) {
            enemy.patternState = { initialX: enemy.x, angle: 0 };
        }
        // Get customizable parameters from overrides, with sensible defaults
        const frequency = enemy.overrides.sine_frequency || 0.03; // Controls oscillation speed
        const amplitude = enemy.overrides.sine_amplitude || 60;   // Controls width of oscillation
        
        enemy.patternState.angle += frequency;
        enemy.x = enemy.patternState.initialX + Math.sin(enemy.patternState.angle) * amplitude;
    },

    // Enemy starts from the left and swoops towards the center, then straightens out.
    swoop_from_left: function(enemy, deltaTime) {
        // Set a high constant downward speed (use override if provided)
        enemy.velocityY = enemy.velocityY || 400;

        // On the first frame, set an initial horizontal speed
        if (enemy.patternState === undefined) {
            enemy.patternState = { initialDx: 250 };
            enemy.velocityX = enemy.patternState.initialDx;
            logger.debug(`Swoop from left initialized: ${enemy.x}, ${enemy.y}, ${enemy.velocityX}, ${enemy.velocityY}`);
        }

        // As the enemy moves down the first 300 pixels of the screen, gradually reduce its horizontal speed to 0.
        // This creates the "swooping in" effect.
        if (enemy.y < 300) {
            // This calculation smoothly reduces velocity from 100% to 0% over 300px.
            const decayFactor = Math.max(0, (300 - enemy.y) / 300);
            enemy.velocityX = enemy.patternState.initialDx * decayFactor;
        } else {
            enemy.velocityX = 0; // Straighten out after the swoop
        }
    },

    // Enemy starts from the right and swoops towards the center.
    swoop_from_right: function(enemy, deltaTime) {
        // Set a high constant downward speed (use override if provided)
        enemy.velocityY = enemy.velocityY || 400;

        // On the first frame, set an initial horizontal speed (negative to move left)
        if (enemy.patternState === undefined) {
            enemy.patternState = { initialDx: -250 };
            enemy.velocityX = enemy.patternState.initialDx;
            logger.debug(`Swoop from right initialized: ${enemy.x}, ${enemy.y}, ${enemy.velocityX}, ${enemy.velocityY}`);
        }

        // As the enemy moves down the first 300 pixels of the screen, gradually reduce its horizontal speed to 0.
        if (enemy.y < 300) {
            const decayFactor = Math.max(0, (300 - enemy.y) / 300);
            enemy.velocityX = enemy.patternState.initialDx * decayFactor;
        } else {
            enemy.velocityX = 0; // Straighten out after the swoop
        }
    },

    /**
     * A more aggressive version of the swoop pattern.
     * The enemy enters from the side in an arc, then dramatically
     * accelerates downwards, "dashing" past the player.
     */
    swoop_and_dash: function(enemy, deltaTime) {
        // Ensure behaviorState exists
        if (!enemy.behaviorState) {
            enemy.behaviorState = {};
        }
        // --- Initial Swoop Phase ---
        // This part is the same as the original swoop.
        // It runs as long as the enemy is in its initial arcing movement.
        if (!enemy.behaviorState.swoop_finished) {
            if (enemy.behaviorState.initialX === undefined) {
                enemy.behaviorState.initialX = enemy.x;
                enemy.behaviorState.initialY = enemy.y;
                // Set the arc distance and initial speed
                enemy.behaviorState.swoopArcDistance = 250; // How far it moves horizontally
                enemy.behaviorState.time = 0;
                enemy.speed = enemy.speed || 100; // Use default speed if none is set
            }

            const state = enemy.behaviorState;
            const elapsedTime = (state.time += deltaTime / 1000);

            // Calculate horizontal movement (arc)
            const arcProgress = Math.sin(elapsedTime * (Math.PI / 2));
            if (state.initialX < enemy.game.width / 2) { // Coming from left
                enemy.x = state.initialX + arcProgress * state.swoopArcDistance;
            } else { // Coming from right
                enemy.x = state.initialX - arcProgress * state.swoopArcDistance;
            }

            // Standard downward movement during the arc
            enemy.y += enemy.speed * (deltaTime / 1000);

            // Check if the arc is complete (when arcProgress reaches its peak)
            if (arcProgress >= 1.0) {
                state.swoop_finished = true;
            }
        }
        // --- Dash Phase ---
        // Once the swoop is finished, we override the velocity.
        else {
            // SET THE NEW, FASTER SPEED HERE!
            // This makes the enemy "roar past the player".
            // A value of 800 is 4x the default speed.
            enemy.velocityY = 800;

            // Apply the new velocity
            enemy.y += enemy.velocityY * (deltaTime / 1000);

            // We don't need to update velocityX, so it continues straight down.
            enemy.velocityX = 0;
        }
    },

    // Enemy moves straight down using its base velocity
    move_straight_down: function(enemy, deltaTime) {
        // The base velocityY from the entity's stats will handle the movement.
    },

    // Enemy moves to a specific point, holds position, then descends
    move_to_point_and_hold: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'approaching', // Phases: approaching, holding, descending
                target: enemy.overrides.formation_point || { x: enemy.x, y: 150 },
                holdTimer: enemy.overrides.hold_duration_ms || 4000
            };
        }

        const state = enemy.patternState;
        const speed = enemy.speed || 150;

        switch (state.phase) {
            case 'approaching':
                const dx = state.target.x - enemy.x;
                const dy = state.target.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5) {
                    state.phase = 'holding';
                    enemy.velocityX = 0;
                    enemy.velocityY = 0;
                } else {
                    enemy.velocityX = (dx / distance) * speed;
                    enemy.velocityY = (dy / distance) * speed;
                }
                break;
            case 'holding':
                state.holdTimer -= deltaTime;
                if (state.holdTimer <= 0) {
                    state.phase = 'descending';
                }
                break;
            case 'descending':
                enemy.velocityX = 0;
                enemy.velocityY = speed * 0.75;
                break;
        }
    },

    // Enemy moves from side to side in a wide sweep as it moves down.
    sweep: function(enemy, deltaTime) {
        // Initialize pattern state on the enemy if it doesn't exist
        if (enemy.patternState === undefined) {
            const direction = (enemy.x < enemy.game.width / 2) ? 1 : -1; // 1 for right, -1 for left
            enemy.patternState = {
                direction: direction,
                speedX: enemy.overrides.speedX || 75
            };
            enemy.velocityX = enemy.patternState.speedX * enemy.patternState.direction;
            enemy.velocityY = enemy.speed || 80; // Standard downward speed
        }

        // Reverse horizontal direction if the enemy hits the screen edges
        if (enemy.x <= 0 || enemy.x + enemy.width >= enemy.game.width) {
            enemy.patternState.direction *= -1;
            enemy.velocityX = enemy.patternState.speedX * enemy.patternState.direction;
        }
    },

    // A complex pattern where the enemy flies to a patrol altitude, moves
    // back and forth, and can even retreat upwards slightly before exiting.
    patrol_and_strafe: function(enemy, deltaTime) {
        // Initialize the state for this pattern on the enemy object
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'entering', // Phases: entering, patrolling, exiting
                patrol_y: enemy.overrides.patrol_y || 150,
                patrol_duration: enemy.overrides.patrol_duration_ms || 8000,
                direction: (enemy.x < enemy.game.width / 2) ? 1 : -1
            };
        }

        const state = enemy.patternState;
        const speed = enemy.speed || 100;

        switch (state.phase) {
            case 'entering':
                // Move down to the patrol altitude
                enemy.velocityY = speed;
                enemy.velocityX = 0;
                if (enemy.y >= state.patrol_y) {
                    state.phase = 'patrolling';
                }
                break;

            case 'patrolling':
                // Move back and forth and count down the patrol timer
                enemy.velocityY = 0;
                enemy.velocityX = speed * state.direction;
                state.patrol_duration -= deltaTime;

                // Reverse direction at screen edges
                if (enemy.x <= 0 || enemy.x + enemy.width >= enemy.game.width) {
                    state.direction *= -1;
                }

                if (state.patrol_duration <= 0) {
                    state.phase = 'exiting';
                }
                break;

            case 'exiting':
                // Briefly move up and back before flying down off-screen
                enemy.velocityX = -speed * state.direction; // Move backward horizontally
                enemy.velocityY = -speed * 0.5; // Move up slowly
                
                // After a short time, just fly down
                setTimeout(() => {
                    if (enemy.active) {
                        enemy.movementUpdate = movementPatterns['move_straight_down'];
                        enemy.speed = 200; // Exit quickly
                    }
                }, 1000);
                break;
        }
    },

    // Enemy moves straight down, performs a quick horizontal strafe, then continues down.
    strafe_and_descend: function(enemy, deltaTime) {
        // Initialize the state for this pattern
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'descending1', // Phases: descending1, strafing, descending2
                strafe_y_trigger: enemy.overrides.strafe_y || 200,
                strafe_duration: enemy.overrides.strafe_duration_ms || 1000,
                strafe_direction: Math.random() < 0.5 ? 1 : -1 // Randomly choose to strafe left or right
            };
            enemy.velocityY = enemy.speed || 120; // Initial descent speed
            enemy.velocityX = 0;
        }

        const state = enemy.patternState;
        const speed = enemy.speed || 120;

        switch (state.phase) {
            case 'descending1':
                // Move down until the trigger Y-coordinate is reached
                if (enemy.y >= state.strafe_y_trigger) {
                    state.phase = 'strafing';
                    enemy.velocityY = 0; // Stop vertical movement
                    enemy.velocityX = speed * 2 * state.strafe_direction; // Strafe quickly
                }
                break;

            case 'strafing':
                // Strafe for a set duration
                state.strafe_duration -= deltaTime;
                if (state.strafe_duration <= 0) {
                    state.phase = 'descending2';
                }
                break;

            case 'descending2':
                // Resume downward movement off the screen
                enemy.velocityX = 0;
                enemy.velocityY = speed;
                break;
        }
    },

    // Enemy moves straight down for a period, then angles towards the center of the screen.
    descend_and_converge: function(enemy, deltaTime) {
        // Initialize the state for this pattern
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'descending', // Phases: descending, converging
                descend_duration: enemy.overrides.descend_duration_ms || 2000 // Descend for 2 seconds
            };
            enemy.velocityY = enemy.speed || 80;
            enemy.velocityX = 0;
        }

        const state = enemy.patternState;

        if (state.phase === 'descending') {
            state.descend_duration -= deltaTime;
            if (state.descend_duration <= 0) {
                state.phase = 'converging';
            }
        }
        
        if (state.phase === 'converging') {
            // Once converging, it maintains its downward speed but adds horizontal speed
            // towards the center of the screen.
            const targetX = enemy.game.width / 2;
            const dx = targetX - enemy.x;
            const convergeSpeed = enemy.overrides.converge_speed || 40;
            
            enemy.velocityX = Math.sign(dx) * convergeSpeed;
            enemy.velocityY = enemy.speed || 80;
        }
    },

    // Enemy moves straight down to a certain point, then veers towards the center.
    descend_and_veer: function(enemy, deltaTime) {
        // Initialize the state for this pattern
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'descending', // Phases: descending, veering
                veer_y_trigger: enemy.overrides.veer_y || 450, // 3/4 down a 600px screen
                initial_direction: (enemy.x < enemy.game.width / 2) ? 1 : -1 // 1 for right, -1 for left
            };
            enemy.velocityY = enemy.speed || 250; // Descend quickly
            enemy.velocityX = 0;
        }

        const state = enemy.patternState;

        // When the enemy reaches the "veer point", change its phase.
        if (state.phase === 'descending' && enemy.y >= state.veer_y_trigger) {
            state.phase = 'veering';
            const convergeSpeed = enemy.overrides.converge_speed || 100;
            // Set horizontal velocity to move towards the center
            enemy.velocityX = convergeSpeed * state.initial_direction;
        }
    },

    // Enemy moves straight down to a Y position, then hard right.
    descend_and_strafe_right: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = { phase: 'descending', trigger_y: enemy.overrides.trigger_y || 350 };
            enemy.velocityY = enemy.speed || 150;
            enemy.velocityX = 0;
        }
        if (enemy.patternState.phase === 'descending' && enemy.y >= enemy.patternState.trigger_y) {
            enemy.patternState.phase = 'strafing';
            enemy.velocityY = 0;
            enemy.velocityX = (enemy.speed || 150) * 1.5; // Strafe faster
        }
    },

    // Enemy moves straight down to a Y position, then hard left.
    descend_and_strafe_left: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = { phase: 'descending', trigger_y: enemy.overrides.trigger_y || 350 };
            enemy.velocityY = enemy.speed || 150;
            enemy.velocityX = 0;
        }
        if (enemy.patternState.phase === 'descending' && enemy.y >= enemy.patternState.trigger_y) {
            enemy.patternState.phase = 'strafing';
            enemy.velocityY = 0;
            enemy.velocityX = -(enemy.speed || 150) * 1.5; // Strafe faster
        }
    },

    // Enemy moves in a constant diagonal line.
    move_diagonal: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = { initialized: true };
            const direction = (enemy.x < enemy.game.width / 2) ? 1 : -1; // Determine direction based on start side
            enemy.velocityX = (enemy.speed || 200) * direction;
            enemy.velocityY = (enemy.speed || 200) * 0.75; // Make it move down slightly slower than sideways
        }
    },

    // Enemy slowly homes in on the player with drag applied
    slow_homing: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                // Initialize angle to point mostly downwards, with a slight random spread.
                currentAngle: Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 4)
            };
        }

        const player = enemy.game.player;

        if (player) {
            const speed = enemy.speed || 50;
            const turnSpeed = enemy.overrides.turn_speed || 1.0;

            // 1. Calculate the direct angle to the player
            let targetAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

            // 2. Constrain the target angle to prevent upward movement
            // If the player is above the mine, the target angle will be negative.
            // In this case, we prevent the mine from turning upwards.
            if (targetAngle < 0) {
                // Instead, steer hard left or right to get under the player again.
                // The angle is clamped to be slightly more than 0 or slightly less than PI
                // to ensure there's always some downward velocity.
                targetAngle = (player.x > enemy.x) ? 0.1 : Math.PI - 0.1;
            }
            
            // 3. Use the persistent angle from the state
            let currentAngle = enemy.patternState.currentAngle;

            // 4. Find the shortest turning path
            let angleDifference = targetAngle - currentAngle;
            while (angleDifference < -Math.PI) angleDifference += 2 * Math.PI;
            while (angleDifference > Math.PI) angleDifference -= 2 * Math.PI;

            // 5. Apply the turn
            const turnAmount = turnSpeed * (deltaTime / 1000);
            currentAngle += Math.sign(angleDifference) * Math.min(Math.abs(angleDifference), turnAmount);

            // 6. Save the new angle back to the state
            enemy.patternState.currentAngle = currentAngle;

            // 7. Recalculate velocity based on the new angle
            enemy.velocityX = Math.cos(currentAngle) * speed;
            enemy.velocityY = Math.sin(currentAngle) * speed;
        }
    },

    // A classic zigzag pattern.
    zigzag: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                direction: Math.random() < 0.5 ? 1 : -1
            };
            enemy.velocityY = enemy.speed || 100;
        }
        const state = enemy.patternState;
        const speedX = enemy.overrides.horizontal_speed || 150;

        enemy.velocityX = speedX * state.direction;

        // Reverse direction at screen edges
        if (enemy.x <= 0 && state.direction === -1) {
            state.direction = 1;
        } else if (enemy.x + enemy.width >= enemy.game.width && state.direction === 1) {
            state.direction = -1;
        }
    },

    // Enemy descends while strafing to a target X coordinate, then continues straight down.
    strafe_to_x_position: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'strafing', // Phases: strafing, descending
                target_x: enemy.overrides.target_x || (enemy.game.width / 2)
            };
            enemy.velocityY = enemy.speed || 180;
        }

        const state = enemy.patternState;
        const speedX = enemy.overrides.strafe_speed || 100;

        if (state.phase === 'strafing') {
            const dx = state.target_x - enemy.x;
            
            // If close enough to the target X, stop strafing.
            if (Math.abs(dx) < 5) {
                state.phase = 'descending';
                enemy.velocityX = 0;
            } else {
                enemy.velocityX = Math.sign(dx) * speedX;
            }
        }
    },

    // Enemy strafes from the center to the edge, then back to the center, then descends.
    strafe_out_and_in: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'strafing_out', // Phases: strafing_out, strafing_in, descending
                direction: Math.random() < 0.5 ? 1 : -1, // Randomly pick initial side
                speedX: enemy.overrides.speedX || 120
            };
            enemy.velocityY = enemy.speed || 60; // Slow descent while strafing
        }

        const state = enemy.patternState;
        enemy.velocityX = state.speedX * state.direction;

        switch (state.phase) {
            case 'strafing_out':
                if (enemy.x <= 0 || enemy.x + enemy.width >= enemy.game.width) {
                    state.phase = 'strafing_in';
                    state.direction *= -1; // Reverse direction
                }
                break;
            case 'strafing_in':
                // Check if it has returned to the center
                if ((state.direction === 1 && enemy.x >= enemy.game.width / 2) || (state.direction === -1 && enemy.x <= enemy.game.width / 2)) {
                    state.phase = 'descending';
                }
                break;
            case 'descending':
                enemy.velocityX = 0;
                enemy.velocityY = (enemy.speed || 60) * 2; // Descend faster to exit
                break;
        }
    },

    // For a V-formation leader. The back two enemies will use this pattern.
    // It moves straight down, then "splits" off towards the side of the screen.
    split_and_descend: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'descending', // Phases: descending, splitting
                split_y_trigger: enemy.overrides.split_y || 150,
                // The direction of the split is passed in the overrides
                split_direction: enemy.overrides.split_direction || 1 
            };
            enemy.velocityY = enemy.speed || 100;
            enemy.velocityX = 0;
        }

        const state = enemy.patternState;
        if (state.phase === 'descending' && enemy.y >= state.split_y_trigger) {
            state.phase = 'splitting';
            // Keep downward velocity, but add a strong horizontal velocity
            enemy.velocityX = (enemy.speed || 100) * 1.5 * state.split_direction;
        }
    },

    // Enemy moves straight down, then angles away from the center of the screen.
    descend_and_diverge: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'descending',
                diverge_y_trigger: enemy.overrides.diverge_y || 250
            };
            enemy.velocityY = enemy.speed || 90;
            enemy.velocityX = 0;
        }

        const state = enemy.patternState;
        if (state.phase === 'descending' && enemy.y >= state.diverge_y_trigger) {
            state.phase = 'diverging';
            // Determine direction based on which side of the screen it's on
            const direction = (enemy.x < enemy.game.width / 2) ? -1 : 1;
            enemy.velocityX = (enemy.speed || 90) * direction;
        }
    },

    // Enemy flies diagonally towards a target point, then continues on that path. Used for crossing patterns.
    criss_cross: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = { initialized: true };
            // Target the opposite side of the screen at a lower point
            const targetX = enemy.game.width - enemy.x; 
            const targetY = enemy.game.height * 0.6;
            
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const speed = enemy.speed || 200;
            enemy.velocityX = (dx / distance) * speed;
            enemy.velocityY = (dy / distance) * speed;
        }
        // No phase changes, it just moves in a straight diagonal line.
    },

    // A multi-phase pattern for a final boss.
    boss_movement: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                phase: 'entering', // entering, patrolling, repositioning
                phaseTimer: 3000, // Time until next phase change
                targetX: enemy.game.width / 2,
                targetY: 100
            };
        }
        const state = enemy.patternState;
        const speed = enemy.speed || 60;
        state.phaseTimer -= deltaTime;

        // --- Phase Changing Logic ---
        if (state.phaseTimer <= 0) {
            if (state.phase === 'entering' || state.phase === 'repositioning') {
                state.phase = 'patrolling';
                state.phaseTimer = 5000 + Math.random() * 3000; // Patrol for 5-8 seconds
            } else if (state.phase === 'patrolling') {
                state.phase = 'repositioning';
                state.phaseTimer = 2000; // Time to move to new spot
                // Pick a new spot in the upper-middle of the screen
                state.targetX = (enemy.game.width / 2) + (Math.random() - 0.5) * 300;
                state.targetY = 100 + Math.random() * 150;
            }
        }
        
        // --- Movement Execution Logic ---
        const dx = state.targetX - enemy.x;
        const dy = state.targetY - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 5) {
            enemy.velocityX = (dx / distance) * speed;
            enemy.velocityY = (dy / distance) * speed;
        } else {
            enemy.velocityX = 0;
            enemy.velocityY = 0;
        }
    },

    // A multi-phase pattern for a final boss, moving between waypoints.
    boss_patrol: function(enemy, deltaTime) {
        if (!enemy.patternState) {
            enemy.patternState = {
                // Define 3 patrol points in the upper half of the screen
                waypoints: [
                    { x: enemy.game.width * 0.2, y: 120 },
                    { x: enemy.game.width * 0.8, y: 120 },
                    { x: enemy.game.width * 0.5, y: 180 }
                ],
                currentWaypointIndex: 0,
                initialMove: true
            };
             // Initial movement onto the screen
            enemy.velocityY = (enemy.speed || 60);
        }

        const state = enemy.patternState;
        const speed = enemy.speed || 60;
        
        if (state.initialMove) {
            if (enemy.y >= 80) { // Stop initial descent at y=80
                state.initialMove = false;
            }
            return;
        }

        let target = state.waypoints[state.currentWaypointIndex];
        const dx = target.x - enemy.x;
        const dy = target.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 5) {
            // Arrived at waypoint, pick the next one
            state.currentWaypointIndex = (state.currentWaypointIndex + 1) % state.waypoints.length;
        } else {
            // Move towards the target waypoint
            enemy.velocityX = (dx / distance) * speed;
            enemy.velocityY = (dy / distance) * speed;
        }
    }
};

// Helper to determine projectile sprite for enemy
function getEnemyProjectileSprite(enemy) {
    // Reaper and Cyclone use enemyMissile.png
    if (enemy.type === 'reaper' || enemy.type === 'cyclone') {
        return 'enemyMissile';
    }
    // All others use enemy_projectile.png
    return 'enemyBullet';
}

export const firingPatterns = {
    // Enemy does not fire
    none: function(enemy, player, deltaTime) {
        // Intentionally empty.
    },

    // Enemy fires a single bullet aimed at the player's position when it fired
    single_aimed_shot: function(enemy, player, deltaTime) {
        // Initialize fire timer on the enemy if it doesn't exist
        if (enemy.fireTimer === undefined) {
            enemy.fireTimer = 500; // Start shooting almost immediately (was 2000)
        }

        enemy.fireTimer -= deltaTime;

        if (enemy.fireTimer <= 0) {
            if (player) {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const velocityX = (dx / distance) * 250; // Increased by 25% (was 200)
                const velocityY = (dy / distance) * 250; // Increased by 25% (was 200)
                const spriteName = getEnemyProjectileSprite(enemy);
                const sprite = enemy.game.assets.getImage(spriteName);
                const projectile = enemy.game.projectilePool.get();
                projectile.activate(enemy.x, enemy.y, velocityX, velocityY, 10, 'enemy', sprite);
                enemy.game.entityManager.add(projectile);
                enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
            }
            enemy.fireTimer = enemy.fireRate || 1500; // Faster default rate (was 2000)
        }
    },

    // Fires a single bullet straight down.
    single_straight_shot: function(enemy, player, deltaTime) {
        if (enemy.fireTimer === undefined) {
            enemy.fireTimer = 300; // Start shooting almost immediately (was 3000)
        }
        enemy.fireTimer -= deltaTime;

        if (enemy.fireTimer <= 0) {
            const velocityX = 0;
            const velocityY = 188; // Increased by 25% (was 150)
            const spriteName = getEnemyProjectileSprite(enemy);
            const sprite = enemy.game.assets.getImage(spriteName);
            const projectile = enemy.game.projectilePool.get();
            projectile.activate(enemy.x, enemy.y, velocityX, velocityY, 10, 'enemy', sprite);
            enemy.game.entityManager.add(projectile);
            enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
            enemy.fireTimer = enemy.fireRate || 1200; // Faster default rate (was 3000)
        }
    },

    // Fires three bullets in a fan pattern.
    three_round_spread: function(enemy, player, deltaTime) {
        if (enemy.fireTimer === undefined) {
            enemy.fireTimer = 800; // Start shooting almost immediately (was 4000)
        }
        enemy.fireTimer -= deltaTime;

        if (enemy.fireTimer <= 0) {
            const projectileSpeed = 188; // Increased by 25% (was 150)
            const spriteName = getEnemyProjectileSprite(enemy);
            const sprite = enemy.game.assets.getImage(spriteName);
            
            // Center bullet
            const centerVelocityX = 0;
            const centerVelocityY = projectileSpeed;
            // Left bullet (angled left by ~15 degrees)
            const leftVelocityX = -projectileSpeed * 0.26;
            const leftVelocityY = projectileSpeed * 0.96;
            // Right bullet (angled right by ~15 degrees)
            const rightVelocityX = projectileSpeed * 0.26;
            const rightVelocityY = projectileSpeed * 0.96;
            
            const centerProjectile = enemy.game.projectilePool.get();
            centerProjectile.activate(enemy.x, enemy.y, centerVelocityX, centerVelocityY, 10, 'enemy', sprite);
            const leftProjectile = enemy.game.projectilePool.get();
            leftProjectile.activate(enemy.x, enemy.y, leftVelocityX, leftVelocityY, 10, 'enemy', sprite);
            const rightProjectile = enemy.game.projectilePool.get();
            rightProjectile.activate(enemy.x, enemy.y, rightVelocityX, rightVelocityY, 10, 'enemy', sprite);
            
            enemy.game.entityManager.add(centerProjectile);
            enemy.game.entityManager.add(leftProjectile);
            enemy.game.entityManager.add(rightProjectile);
            
            enemy.game.collision.addToGroup(centerProjectile, 'enemyProjectiles');
            enemy.game.collision.addToGroup(leftProjectile, 'enemyProjectiles');
            enemy.game.collision.addToGroup(rightProjectile, 'enemyProjectiles');
            
            enemy.fireTimer = enemy.fireRate || 2000; // Faster default rate (was 4000)
        }
    },

    // Fires a missile straight down with constant high speed
    fire_straight_missile: function(enemy, player, deltaTime) {
        if (enemy.fireTimer === undefined) {
            enemy.fireTimer = 1000; // Start shooting almost immediately (was 5000)
        }
        enemy.fireTimer -= deltaTime;

        if (enemy.fireTimer <= 0) {
            const missileDamage = 40;
            // Enemy missiles get a high, constant velocity and do not accelerate.
            const missileVelocity = { x: 0, y: 375 }; // Increased by 25% (was 300)
            const missile = new Missile(enemy.game, enemy.x, enemy.y, missileDamage, 'enemy', missileVelocity);
            enemy.game.entityManager.add(missile);
            enemy.game.collision.addToGroup(missile, 'enemyProjectiles');
            enemy.fireTimer = enemy.fireRate || 2500; // Faster default rate (was 5000)
        }
    },

    // Fires a quick burst of 3 projectiles.
    burst_fire: function(enemy, player, deltaTime) {
        // Initialize pattern state if it doesn't exist
        if (enemy.fireState === undefined) {
            enemy.fireState = {
                mainTimer: 600, // Start shooting almost immediately (was 4000)
                isBursting: false,
                burstShotsFired: 0,
                burstShotDelay: 80 // Faster burst shots (was 100)
            };
        }
        
        const state = enemy.fireState;
        state.mainTimer -= deltaTime;

        // If not currently bursting and the main timer is ready, start a burst.
        if (!state.isBursting && state.mainTimer <= 0) {
            state.isBursting = true;
            state.burstShotsFired = 0;
            state.interShotTimer = 0;
        }

        // If currently bursting, handle the firing of individual shots.
        if (state.isBursting) {
            state.interShotTimer -= deltaTime;
            if (state.interShotTimer <= 0 && state.burstShotsFired < 3) {
                // Fire a single aimed shot
                if (player) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const velocity = { x: (dx / distance) * 375, y: (dy / distance) * 375 }; // Increased by 25% (was 300)
                    const spriteName = getEnemyProjectileSprite(enemy);
                    const sprite = enemy.game.assets.getImage(spriteName);
                    const projectile = enemy.game.projectilePool.get();
                    projectile.activate(enemy.x, enemy.y, velocity.x, velocity.y, 5, 'enemy', sprite);
                    enemy.game.entityManager.add(projectile);
                    enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
                }
                state.burstShotsFired++;
                state.interShotTimer = state.burstShotDelay; // Reset inter-shot timer
            }

            // If burst is finished, reset for the next main cooldown period.
            if (state.burstShotsFired >= 3) {
                state.isBursting = false;
                state.mainTimer = enemy.fireRate || 2000; // Faster default rate (was 4000)
            }
        }
    },

    // Fires two projectiles simultaneously in a wide V-shape (approx. 90 degrees).
    wide_v_shot: function(enemy, player, deltaTime) {
        if (enemy.fireTimer === undefined) {
            enemy.fireTimer = 400; // Start shooting almost immediately (was 3000)
        }
        enemy.fireTimer -= deltaTime;

        if (enemy.fireTimer <= 0) {
            const projectileSpeed = 275; // Increased by 25% (was 220)
            const damage = 20;

            // Create the left-moving projectile (down and left at 45 degrees)
            const leftVelocity = { x: -projectileSpeed * 0.707, y: projectileSpeed * 0.707 };
            const spriteName = getEnemyProjectileSprite(enemy);
            const sprite = enemy.game.assets.getImage(spriteName);
            const leftProjectile = enemy.game.projectilePool.get();
            leftProjectile.activate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, leftVelocity.x, leftVelocity.y, damage, 'enemy', sprite);
            enemy.game.entityManager.add(leftProjectile);
            enemy.game.collision.addToGroup(leftProjectile, 'enemyProjectiles');
            
            // Create the right-moving projectile (down and right at 45 degrees)
            const rightVelocity = { x: projectileSpeed * 0.707, y: projectileSpeed * 0.707 };
            const rightProjectile = enemy.game.projectilePool.get();
            rightProjectile.activate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, rightVelocity.x, rightVelocity.y, damage, 'enemy', sprite);
            enemy.game.entityManager.add(rightProjectile);
            enemy.game.collision.addToGroup(rightProjectile, 'enemyProjectiles');

            enemy.fireTimer = enemy.fireRate || 1500; // Faster default rate (was 3000)
        }
    },

    // A complex pattern that controls two separate weapon systems.
    boss_multi_weapon_fire: function(enemy, player, deltaTime) {
        if (!enemy.fireState) {
            enemy.fireState = {
                straightShotTimer: (enemy.overrides.straightFireRate || 2000) / 3,
                aimedShotTimer: (enemy.overrides.aimedFireRate || 3200) / 3,
                aimedBurstPause: false,
                aimedBurstShots: 0,
                aimedBurstDelay: 0,
                repositionPause: false,
                repositionTimer: 0,
                desperationTriggered: false,
                desperationTimer: 0
            };
        }
        const state = enemy.fireState;
        // Desperation attack trigger
        if (!state.desperationTriggered && enemy.health / enemy.maxHealth <= 0.25) {
            state.desperationTriggered = true;
            state.desperationTimer = 0;
        }
        // Desperation attack (massive spread)
        if (state.desperationTriggered && state.desperationTimer <= 0) {
            // Fire a ring of projectiles
            for (let i = 0; i < 16; i++) {
                const angle = (Math.PI * 2 * i) / 16;
                const velocityX = Math.cos(angle) * 313; // Increased by 25% (was 250)
                const velocityY = Math.sin(angle) * 313; // Increased by 25% (was 250)
                const sprite = enemy.game.assets.getImage('enemyBullet');
                const projectile = enemy.game.projectilePool.get();
                projectile.activate(enemy.x + enemy.width/2, enemy.y + enemy.height/2, velocityX, velocityY, 15, 'enemy', sprite);
                enemy.game.entityManager.add(projectile);
                enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
            }
            state.desperationTimer = 3500; // 3.5s between desperation attacks
        }
        if (state.desperationTriggered) {
            state.desperationTimer -= deltaTime;
        }
        // Reposition pause logic
        if (state.repositionPause) {
            state.repositionTimer -= deltaTime;
            if (state.repositionTimer <= 0) {
                state.repositionPause = false;
            } else {
                return; // Paused, don't fire
            }
        }
        // --- Firing Straight Shooters ---
        state.straightShotTimer -= deltaTime;
        if (state.straightShotTimer <= 0) {
            const sprite = enemy.game.assets.getImage('enemyMissile');
            const missile = new Missile(enemy.game, enemy.x + 20, enemy.y + enemy.height - 20, 20, 'enemy', { x: 0, y: 438 });
            missile.sprite = sprite;
            enemy.game.entityManager.add(missile);
            enemy.game.collision.addToGroup(missile, 'enemyProjectiles');
            state.straightShotTimer = ((enemy.overrides.straightFireRate || 2000) / 3);
            // After every 4 straight shots, pause to reposition
            state.straightShotsFired = (state.straightShotsFired || 0) + 1;
            if (state.straightShotsFired % 4 === 0) {
                state.repositionPause = true;
                state.repositionTimer = 1200; // 1.2s pause
            }
        }
        // --- Firing Aimed Burst ---
        state.aimedShotTimer -= deltaTime;
        if (!state.aimedBurstPause && state.aimedShotTimer <= 0) {
            state.aimedBurstPause = true;
            state.aimedBurstShots = 0;
            state.aimedBurstDelay = 0;
        }
        if (state.aimedBurstPause) {
            state.aimedBurstDelay -= deltaTime;
            if (state.aimedBurstShots < 3 && state.aimedBurstDelay <= 0) {
                if (player) {
                    const sprite = enemy.game.assets.getImage('enemyBullet');
                    const dx = player.x - (enemy.x + enemy.width / 2);
                    const dy = player.y - (enemy.y + enemy.height / 2);
                    const angle = Math.atan2(dy, dx);
                    const velocityX = Math.cos(angle) * 375; // Increased by 25% (was 300)
                    const velocityY = Math.sin(angle) * 375; // Increased by 25% (was 300)
                    const projectile = enemy.game.projectilePool.get();
                    projectile.activate(enemy.x + enemy.width/2, enemy.y + enemy.height/2, velocityX, velocityY, 15, 'enemy', sprite);
                    enemy.game.entityManager.add(projectile);
                    enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
                }
                state.aimedBurstShots++;
                state.aimedBurstDelay = 120; // 120ms between burst shots
            }
            if (state.aimedBurstShots >= 3) {
                state.aimedBurstPause = false;
                state.aimedShotTimer = ((enemy.overrides.aimedFireRate || 3200) / 3) + 500; // Add a small delay after burst
            }
        }
    },

    // --- BOSS MIXED ARMAMENT ---
    boss_mixed_armament: function(enemy, player, deltaTime) {
        if (!enemy.fireState) {
            enemy.fireState = {
                cannonTimer: enemy.overrides.cannonFireRate || 1200,
                missileTimer: enemy.overrides.missileFireRate || 4000
            };
        }
        const state = enemy.fireState;
        state.cannonTimer -= deltaTime;
        state.missileTimer -= deltaTime;

        // Firing Cannons (spread shot aimed at player)
        if (state.cannonTimer <= 0) {
            if (player) {
                const sprite = enemy.game.assets.getImage('enemyBullet');
                for (let i = -1; i <= 1; i++) {
                    const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    const angle = angleToPlayer + (i * 0.2); // 0.2 radians spread
                    const velocityX = Math.cos(angle) * 375; // Increased by 25% (was 300)
                    const velocityY = Math.sin(angle) * 375; // Increased by 25% (was 300)
                    const projectile = enemy.game.projectilePool.get();
                    projectile.activate(enemy.x + enemy.width/2, enemy.y + enemy.height/2, velocityX, velocityY, 10, 'enemy', sprite);
                    enemy.game.entityManager.add(projectile);
                    enemy.game.collision.addToGroup(projectile, 'enemyProjectiles');
                }
            }
            state.cannonTimer = enemy.overrides.cannonFireRate || 1200;
        }

        // Firing Missiles (straight forward)
        if (state.missileTimer <= 0) {
            const sprite = enemy.game.assets.getImage('enemyMissile');
            const missile = new Missile(enemy.game, enemy.x + enemy.width/2, enemy.y + enemy.height, 40, 'enemy', { x: 0, y: 375 });
            missile.sprite = sprite;
            enemy.game.entityManager.add(missile);
            enemy.game.collision.addToGroup(missile, 'enemyProjectiles'); // CRUCIAL STEP
            state.missileTimer = enemy.overrides.missileFireRate || 4000;
        }
    }
};
</file>

<file path="js/entities/player.js">
/**
 * Player class
 * Represents the player's ship
 */
import { Entity } from '../engine/entity.js';
import { Explosion } from './explosion.js';
import { Projectile } from './projectile.js';
import { Missile } from './missile.js';
import { logger } from '../utils/logger.js';

class Player extends Entity {
    constructor(game, x, y) {
        super(game, x, y, 64, 64);
        this.layer = 'player'; // Define the rendering layer

        // Player stats - will be synced with playerData if available
        this.speed = 575; // Increased from 500 by 15%
        this.health = 75; // Default starting health
        this.maxHealth = 100;
        this.shield = 0; // Shield for shop system
        this.money = 0;
        this.score = 0;
        this.collisionDamage = 20;

        // Weapon system
        this.weaponOrder = ['MISSILE']; // Only missiles in the cycle
        this.currentWeaponIndex = 0;
        this.currentWeapon = this.weaponOrder[this.currentWeaponIndex];
        this.weapons = {
            'CANNON': { name: 'Autocannon', fireRate: 110, lastFired: 0, level: 1 }, // Slower fire rate
            'MISSILE': { name: 'Missiles', fireRate: 715, lastFired: 0 } // 30% slower than before
        };

        // Unlocked weapons for shop system
        this.unlockedWeapons = ['MISSILE']; // Start with basic missiles unlocked

        // Special weapons
        this.megabombs = 3;
        this.lastMegabombTime = 0;
        this.megabombCooldown = 1000; // 1 second cooldown

        // Animation properties
        this.sprite = null;
        this.thrustSprite = null;
        this.turnLeftSprite = null;
        this.turnRightSprite = null;
        this.frameX = 0;
        this.frameY = 0;
        this.maxFrames = 2;
        this.frameTimer = 0;
        this.frameInterval = 100;

        // Movement properties
        this.turnThreshold = 0.3; // Threshold for showing turn sprites
        this.currentDirection = 0; // -1 for left, 0 for straight, 1 for right

        // Invulnerability after taking damage
        this.invulnerable = false;
        this.invulnerabilityTime = 0;
        this.invulnerabilityDuration = 1000; // 1 second
        this.blinkInterval = 100;
        this.visible = true;

        // Missile auto-fire toggle
        this.missileAutoFire = true;

        // Sync with playerData if available
        this.syncWithPlayerData();
    }

    /**
     * Sync player stats with playerData
     */
    syncWithPlayerData() {
        if (this.game.playerData) {
            this.health = this.game.playerData.health || 75;
            this.money = this.game.playerData.money || 0;
            this.score = this.game.playerData.score || 0;
            this.shield = this.game.playerData.shield || 0;
            this.unlockedWeapons = this.game.playerData.unlockedWeapons || ['MISSILE'];
            logger.debug(`Player synced with playerData: health=${this.health}, money=${this.money}`);
        }
    }

    /**
     * Load player sprites
     */
    loadSprites() {
        this.sprites = {
            base: this.game.assets.getImage('playerShipBase'),
            left: this.game.assets.getImage('playerShipLeft'),
            right: this.game.assets.getImage('playerShipRight'),
            thrust: this.game.assets.getImage('playerShipThrust')
        };

        // Check if all required sprites were successfully loaded.
        if (this.sprites.base && this.sprites.left && this.sprites.right) {
            this.isReady = true; // <-- Set the flag to true only if assets are loaded
        } else {
            logger.error("Failed to load one or more player sprites. Player will not be rendered.");
        }
    }

    /**
     * Update player state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // Handle movement
        this.handleMovement();

        // Handle weapons
        this.handleWeapons();

        // Update invulnerability
        if (this.invulnerable) {
            this.invulnerabilityTime += deltaTime;

            // Blink effect
            if (this.invulnerabilityTime % this.blinkInterval < this.blinkInterval / 2) {
                this.visible = true;
            } else {
                this.visible = false;
            }

            // End invulnerability
            if (this.invulnerabilityTime >= this.invulnerabilityDuration) {
                this.invulnerable = false;
                this.visible = true;
            }
        }

        // Update animation
        this.updateAnimation(deltaTime);

        super.update(deltaTime);
    }

    /**
     * Handle player movement based on input
     */
    handleMovement() {
        // Get mouse position
        const mousePos = this.game.input.getMousePosition();

        // Calculate direction to mouse
        const targetX = mousePos.x - this.width / 2;
        const targetY = mousePos.y - this.height / 2;

        // Calculate distance to target
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Update turn direction
        if (Math.abs(dx) > this.turnThreshold * this.width) {
            this.currentDirection = dx > 0 ? 1 : -1;
        } else {
            this.currentDirection = 0;
        }

        // Only move if we're not at the target position
        if (distance > 2) { // Reduced threshold for more precise movement
            // Calculate movement speed based on distance
            const moveSpeed = Math.min(this.speed * 1.75, distance * 3.5); // Increased responsiveness

            // Calculate normalized direction
            const dirX = dx / distance;
            const dirY = dy / distance;

            // Set velocity based on direction and speed
            this.velocityX = dirX * moveSpeed;
            this.velocityY = dirY * moveSpeed;
        } else {
            // Stop moving when close to target
            this.velocityX = 0;
            this.velocityY = 0;
        }

        // Keep player within game boundaries
        let bounds = { left: 0, top: 0, right: this.game.width, bottom: this.game.height };
        if (this.game.currentState && typeof this.game.currentState.getPlayableBounds === 'function') {
            bounds = this.game.currentState.getPlayableBounds();
        }
        if (this.x < bounds.left) this.x = bounds.left;
        if (this.x + this.width > bounds.right) this.x = bounds.right - this.width;
        if (this.y < bounds.top) this.y = bounds.top;
        if (this.y + this.height > bounds.bottom) this.y = bounds.bottom - this.height;
    }

    /**
     * Handle player weapons based on input
     */
    handleWeapons() {
        const now = Date.now();

        // Primary weapon firing (machine gun) - left mouse button
        if (this.game.input.isMouseButtonPressed('left')) { // Left mouse button
            const cannon = this.weapons['CANNON'];
            if (now - cannon.lastFired >= cannon.fireRate) {
                this.fireCannon();
                cannon.lastFired = now;
            }

            // Auto-fire missiles while holding left mouse button (only if enabled)
            if (this.missileAutoFire) {
                const missile = this.weapons['MISSILE'];
                if (now - missile.lastFired >= missile.fireRate) {
                    this.fireMissile();
                    missile.lastFired = now;
                }
            }
        }

        // Right mouse button toggles missile auto-fire mode
        if (this.game.input.wasMouseButtonJustPressed('right')) { // Right mouse button
            this.missileAutoFire = !this.missileAutoFire;
            logger.debug(`Missile auto-fire mode: ${this.missileAutoFire ? 'ON' : 'OFF'}`);
        }

        // Megabomb
        if (this.game.input.isKeyPressed('b')) {
            if (this.megabombs > 0 && now - this.lastMegabombTime > this.megabombCooldown) {
                this.lastMegabombTime = now;
                this.fireMegabomb();
            }
        }
    }

    /**
     * Update player animation
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateAnimation(deltaTime) {
        this.frameTimer += deltaTime;
        if (this.frameTimer > this.frameInterval) {
            this.frameTimer = 0;
            this.frameX = (this.frameX + 1) % this.maxFrames;
        }
    }

    /**
   * Render the player
   * @param {CanvasRenderingContext2D} context - The canvas context to render to
   */
    render(context) {
        if (!this.visible || !this.isReady) return;

        // Draw the appropriate sprite based on movement direction
        if (this.currentDirection === -1 && this.sprites.left) {
            context.globalCompositeOperation = 'source-over';
            context.drawImage(
                this.sprites.left,
                this.x,
                this.y,
                this.width,
                this.height
            );
        } else if (this.currentDirection === 1 && this.sprites.right) {
            context.globalCompositeOperation = 'source-over';
            context.drawImage(
                this.sprites.right,
                this.x,
                this.y,
                this.width,
                this.height
            );
        } else if (this.sprites.base) {
            context.globalCompositeOperation = 'source-over';
            context.drawImage(
                this.sprites.base,
                this.x,
                this.y,
                this.width,
                this.height
            );
        }
    }

    /**
     * Fire the primary weapon (machine gun)
     */
    fireCannon() {
        // Keep all your existing constants for balance
        const bulletSpacing = 10;
        const bulletVelocityY = -1200;
        const bulletDamage = 3;

        // Fire Left Bullet
        const leftBullet = this.game.projectilePool.get();
        if (leftBullet) {
            // Activate the bullet from the pool with its properties.
            // Pass `null` for the sprite to make it draw the tiny rectangle (white pixel bullet).
            leftBullet.activate(this.x + this.width / 2 - bulletSpacing, this.y, 0, bulletVelocityY, bulletDamage, 'player', null);
            this.game.entityManager.add(leftBullet);
            this.game.collision.addToGroup(leftBullet, 'playerProjectiles');
        }

        // Fire Right Bullet
        const rightBullet = this.game.projectilePool.get();
        if (rightBullet) {
            // Pass `null` for the sprite as well.
            rightBullet.activate(this.x + this.width / 2 + bulletSpacing, this.y, 0, bulletVelocityY, bulletDamage, 'player', null);
            this.game.entityManager.add(rightBullet);
            this.game.collision.addToGroup(rightBullet, 'playerProjectiles');
        }
    }

    /**
     * Fire the secondary weapon (missiles)
     */
    fireMissile() {
        const missileSpacing = 12;
        const missileDamage = 60;
        const initialVelocity = { x: 0, y: -50 };
        const missileSprite = this.game.assets.getImage('MISSILE'); // Use the correct key

        // Fire Left Missile from the pool
        const leftMissile = this.game.missilePool.get();
        if (leftMissile) {
            leftMissile.activate(this.x + this.width / 2 - missileSpacing, this.y, missileDamage, 'player', initialVelocity, missileSprite);
            this.game.entityManager.add(leftMissile);
            this.game.collision.addToGroup(leftMissile, 'playerProjectiles');
        }

        // Fire Right Missile from the pool
        const rightMissile = this.game.missilePool.get();
        if (rightMissile) {
            rightMissile.activate(this.x + this.width / 2 + missileSpacing, this.y, missileDamage, 'player', initialVelocity, missileSprite);
            this.game.entityManager.add(rightMissile);
            this.game.collision.addToGroup(rightMissile, 'playerProjectiles');
        }
    }

    /**
     * Fire a megabomb
     */
    fireMegabomb() {
        if (this.megabombs > 0) {
            this.megabombs--;

            // Create explosion effect
            const explosion = new Explosion(
                this.game,
                this.game.width / 2 - 128,
                this.game.height / 2 - 128,
                256,
                256
            );
            this.game.entityManager.add(explosion);

            // Clear all enemies and enemy projectiles
            const enemies = this.game.collision.collisionGroups.enemies;
            const enemyProjectiles = this.game.collision.collisionGroups.enemyProjectiles;

            // Damage all enemies
            enemies.forEach(enemy => {
                enemy.takeDamage(100); // Megabomb does massive damage
            });

            // Destroy all enemy projectiles
            enemyProjectiles.forEach(projectile => {
                projectile.destroy();
            });

            // Clear enemy projectiles group
            this.game.collision.collisionGroups.enemyProjectiles = [];

            // Play sound effect
            this.game.audio.playSound('megabomb');
        }
    }

    /**
     * Take damage
     * @param {number} amount - Amount of damage to take
     */
    takeDamage(amount) {
        // Skip damage if invulnerable
        if (this.invulnerable) return;

        // Apply damage directly to health
        this.health -= amount;

        // Sync with playerData
        if (this.game.playerData) {
            this.game.playerData.health = this.health;
        }

        if (this.health <= 0) {
            this.health = 0;
            this.destroy();

            // Create explosion
            const explosion = new Explosion(
                this.game,
                this.x + this.width / 2 - 32,
                this.y + this.height / 2 - 32,
                64,
                64
            );
            this.game.entityManager.add(explosion);

            // Game over
            this.game.changeState('gameover');
        } else {
            // Start invulnerability period
            this.invulnerable = true;
            this.invulnerabilityTime = 0;
        }

        // Play damage sound
        this.game.audio.playSound('playerDamage');
    }

    /**
     * Add health
     * @param {number} amount - Amount of health to add
     */
        /**
     * Add health
     * @param {number} amount - Amount of health to add
     */
    addHealth(amount) {
        this.health = Math.min(this.health + amount, this.maxHealth);
        // Sync with playerData
        if (this.game.playerData) {
            this.game.playerData.health = this.health;
        }
    }

    /**
     * Collect a health pickup.
     * @param {number} amount - The amount of health in the pickup.
     */
    collectHealthPickup(amount) {
        this.addHealth(amount);
    }

    /**
     * Add money to the player
     * @param {number} amount - Amount of money to add
     */
    addMoney(amount) {
        this.money += amount;
        // Sync with playerData
        if (this.game.playerData) {
            this.game.playerData.money = this.money;
        }
    }

    /**
     * Add score to the player
     * @param {number} amount - Amount of score to add
     */
    addScore(amount) {
        this.score += amount;
        this.game.playerData.score = this.score;
    }

    /**
     * Add megabomb
     */
    addMegabomb() {
        this.megabombs++;
    }

    /**
     * Upgrade primary weapon
     */
    upgradePrimaryWeapon() {
        const weapon = this.weapons['CANNON'];
        if (weapon && weapon.level < 5) {
            weapon.level++;

            // Adjust fireRate based on level
            weapon.fireRate = Math.max(100, 150 - (weapon.level - 1) * 25);
        }
    }
}

export { Player };
</file>

<file path="js/states/menu.js">
/**
 * MenuState class
 * Handles the main menu of the game
 */
import { logger } from '../utils/logger.js';
class MenuState {
    constructor(game) {
        this.game = game;
        this.background = null;
        this.menuOptions = [
            { text: 'Start New Game', action: () => this.startNewGame() },
            { text: 'Load Game', action: () => this.loadGame() },
            { text: 'Readme', action: () => this.showReadme() },
            { text: 'Options', action: () => this.showOptionsMenu() }, // <-- Added Options button
            { text: 'Credits', action: () => this.showCredits() }
        ];
        this.selectedOption = 0;
        this.keyDelay = 200;
        this.lastKeyTime = 0;
    }
    
    /**
     * Enter the menu state
     */
    enter() {
        logger.info('Entering Menu State');
        
        try {
            // Show menu screen, hide others
            const menuScreen = document.getElementById('menu-screen');
            const loadingScreen = document.getElementById('loading-screen');
            const gameOverScreen = document.getElementById('game-over-screen');
            
            if (menuScreen) menuScreen.style.display = 'flex';
            if (loadingScreen) loadingScreen.style.display = 'none';
            if (gameOverScreen) gameOverScreen.style.display = 'none';
            
            logger.debug('Menu screen elements updated');
            
            // Get background from assets
            this.background = this.game.assets.getImage('menuBackground');
            logger.debug('Menu background loaded:', !!this.background);
            
            // Assets are now loaded upfront in LoadingState, so no need for callbacks
            
            // Play menu music
            // this.game.audio.playMusic('menuMusic'); // Commented out - no audio assets defined yet
            
            // Set up menu screen
            this.setupMenuScreen();
            logger.info('Menu screen setup complete');
        } catch (error) {
            logger.error('Error in MenuState.enter():', error);
        }
    }
    
    /**
     * Set up the menu screen
     */
    setupMenuScreen() {
        const menuScreen = document.getElementById('menu-screen');
        menuScreen.innerHTML = '';
        
        // Create main container
        const mainContainer = document.createElement('div');
        mainContainer.style.display = 'flex';
        mainContainer.style.flexDirection = 'column';
        mainContainer.style.alignItems = 'center';
        mainContainer.style.justifyContent = 'center';
        mainContainer.style.width = '100%';
        mainContainer.style.height = '100%';
        mainContainer.style.position = 'relative';
        mainContainer.style.overflow = 'hidden';
        
        // Add background image if available
        if (this.background) {
            const bgImg = document.createElement('img');
            bgImg.src = this.background.src;
            bgImg.style.width = '100%';
            bgImg.style.height = '100%';
            bgImg.style.objectFit = 'cover';
            bgImg.style.position = 'absolute';
            bgImg.style.top = '0';
            bgImg.style.left = '0';
            bgImg.style.zIndex = '1';
            mainContainer.appendChild(bgImg);
        }
        
        // Create overlay for better text readability
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
        overlay.style.zIndex = '2';
        mainContainer.appendChild(overlay);
        
        // Create menu container - positioned on top of background
        const menuContainer = document.createElement('div');
        menuContainer.style.display = 'flex';
        menuContainer.style.flexDirection = 'column';
        menuContainer.style.alignItems = 'center';
        menuContainer.style.justifyContent = 'center';
        menuContainer.style.position = 'absolute';
        menuContainer.style.bottom = '20%';
        menuContainer.style.left = '50%';
        menuContainer.style.transform = 'translateX(-50%)';
        menuContainer.style.zIndex = '3';
        
        // Add menu options with improved styling
        this.menuOptions.forEach((option, index) => {
            const optionElement = document.createElement('div');
            
            optionElement.textContent = option.text;
            optionElement.style.color = 'white';
            optionElement.style.cursor = 'pointer';
            
            optionElement.style.fontSize = '28px';
            optionElement.style.margin = '8px';
            optionElement.style.padding = '8px 20px';
            optionElement.style.transition = 'all 0.2s ease';
            optionElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            optionElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            optionElement.style.border = '1px solid rgba(255, 255, 255, 0.3)';
            optionElement.style.borderRadius = '6px';
            
            // Add hover effect
            optionElement.addEventListener('mouseover', () => {
                optionElement.style.color = '#ffcc00';
                optionElement.style.textShadow = '0 0 15px #ffcc00';
            });
            
            optionElement.addEventListener('mouseout', () => {
                optionElement.style.color = 'white';
                optionElement.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            });
            
            // Add click handler
            optionElement.addEventListener('click', option.action);
            
            menuContainer.appendChild(optionElement);
        });
        
        // Add instructions - positioned at top right
        const instructions = document.createElement('div');
        instructions.style.position = 'absolute';
        instructions.style.top = '20px';
        instructions.style.right = '20px';
        instructions.style.color = '#aaa';
        instructions.style.fontSize = '14px';
        instructions.style.textAlign = 'right';
        instructions.style.maxWidth = '200px';
        instructions.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        instructions.style.padding = '10px';
        instructions.style.borderRadius = '5px';
        instructions.style.border = '1px solid #333';
        instructions.style.zIndex = '4';
        instructions.innerHTML = 'Use Arrow Keys to navigate<br>Enter to select';
        mainContainer.appendChild(instructions);
        
        // Assemble the layout
        mainContainer.appendChild(menuContainer);
        menuScreen.appendChild(mainContainer);
    }
    
    /**
     * Start a new game
     */
    startNewGame() {
        logger.info('Starting new game - all assets loaded');
        this.game.changeState('characterSelect');
    }
    
    /**
     * Load a saved game
     */
    loadGame() {
        logger.info('Loading saved game');
        // TODO: Implement save/load functionality
        this.showLoadGameScreen();
    }
    
    /**
     * Show load game screen
     */
    showLoadGameScreen() {
        const menuScreen = document.getElementById('menu-screen');
        menuScreen.innerHTML = '';
        
        const loadContainer = document.createElement('div');
        loadContainer.style.display = 'flex';
        loadContainer.style.flexDirection = 'column';
        loadContainer.style.alignItems = 'center';
        loadContainer.style.justifyContent = 'center';
        loadContainer.style.width = '80%';
        loadContainer.style.height = '80%';
        loadContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        loadContainer.style.padding = '20px';
        loadContainer.style.borderRadius = '10px';
        loadContainer.style.border = '2px solid #ffcc00';
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = 'Load Game';
        title.style.color = '#ffcc00';
        title.style.marginBottom = '20px';
        loadContainer.appendChild(title);
        
        // Check for saved game data
        const savedData = localStorage.getItem('raptor_manus_save');
        let playerData = null;
        let hasValidSave = false;
        
        if (savedData) {
            try {
                playerData = JSON.parse(savedData);
                // Validate that we have the required fields
                if (playerData && playerData.name && playerData.callsign) {
                    hasValidSave = true;
                }
            } catch (error) {
                logger.error('Error parsing saved data:', error);
                hasValidSave = false;
            }
        }
        
        if (hasValidSave && playerData) {
            // Add saved pilot info
            const pilotInfo = document.createElement('div');
            pilotInfo.style.color = 'white';
            pilotInfo.style.fontSize = '18px';
            pilotInfo.style.textAlign = 'center';
            pilotInfo.style.marginBottom = '20px';
            pilotInfo.innerHTML = `
                <strong>Saved Pilot:</strong><br>
                ${playerData.name} (${playerData.callsign})<br>
                Level: ${playerData.level || 1} | Credits: $${playerData.money || 0}<br>
                Score: ${playerData.score || 0}
            `;
            loadContainer.appendChild(pilotInfo);
            
            // Add load button
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load Saved Game';
            loadButton.style.padding = '15px 30px';
            loadButton.style.backgroundColor = '#4CAF50';
            loadButton.style.color = 'white';
            loadButton.style.border = 'none';
            loadButton.style.borderRadius = '5px';
            loadButton.style.cursor = 'pointer';
            loadButton.style.fontSize = '18px';
            loadButton.style.marginBottom = '20px';
            loadButton.addEventListener('click', () => {
                this.game.playerData = playerData;
                this.game.changeState('hangar');
            });
            loadContainer.appendChild(loadButton);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete Save';
            deleteButton.style.padding = '10px 20px';
            deleteButton.style.backgroundColor = '#f44336';
            deleteButton.style.color = 'white';
            deleteButton.style.border = 'none';
            deleteButton.style.borderRadius = '5px';
            deleteButton.style.cursor = 'pointer';
            deleteButton.style.fontSize = '16px';
            deleteButton.style.marginBottom = '20px';
            deleteButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to delete your saved game?')) {
                    localStorage.removeItem('raptor_manus_save');
                    this.showLoadGameScreen(); // Refresh the screen
                }
            });
            loadContainer.appendChild(deleteButton);
            
        } else {
            // Add message for no save
            const message = document.createElement('div');
            message.style.color = 'white';
            message.style.fontSize = '18px';
            message.style.textAlign = 'center';
            message.style.marginBottom = '30px';
            message.innerHTML = '<strong>No Pilots Saved</strong><br><br>Use "Start New Game" to create a new pilot.';
            loadContainer.appendChild(message);
            
            // Add disabled load button with tooltip
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load Saved Game';
            loadButton.style.padding = '15px 30px';
            loadButton.style.backgroundColor = '#666';
            loadButton.style.color = '#999';
            loadButton.style.border = 'none';
            loadButton.style.borderRadius = '5px';
            loadButton.style.cursor = 'not-allowed';
            loadButton.style.fontSize = '18px';
            loadButton.style.marginBottom = '20px';
            loadButton.title = 'No saved pilot found';
            loadButton.disabled = true;
            loadContainer.appendChild(loadButton);
            
            // Add disabled delete button with tooltip
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete Save';
            deleteButton.style.padding = '10px 20px';
            deleteButton.style.backgroundColor = '#666';
            deleteButton.style.color = '#999';
            deleteButton.style.border = 'none';
            deleteButton.style.borderRadius = '5px';
            deleteButton.style.cursor = 'not-allowed';
            deleteButton.style.fontSize = '16px';
            deleteButton.style.marginBottom = '20px';
            deleteButton.title = 'No saved pilot to delete';
            deleteButton.disabled = true;
            loadContainer.appendChild(deleteButton);
        }
        
        // Add back button
        const backButton = document.createElement('button');
        backButton.textContent = 'Back to Menu';
        backButton.style.padding = '10px 20px';
        backButton.style.backgroundColor = '#333';
        backButton.style.color = 'white';
        backButton.style.border = 'none';
        backButton.style.borderRadius = '5px';
        backButton.style.cursor = 'pointer';
        backButton.style.fontSize = '16px';
        backButton.addEventListener('click', () => {
            this.setupMenuScreen();
        });
        loadContainer.appendChild(backButton);
        
        menuScreen.appendChild(loadContainer);
    }
    
    /**
     * Show game readme
     */
    showReadme() {
        const menuScreen = document.getElementById('menu-screen');
        menuScreen.innerHTML = '';
        
        const readmeContainer = document.createElement('div');
        readmeContainer.style.display = 'flex';
        readmeContainer.style.flexDirection = 'column';
        readmeContainer.style.alignItems = 'center';
        readmeContainer.style.justifyContent = 'center';
        readmeContainer.style.width = '80%';
        readmeContainer.style.height = '80%';
        readmeContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        readmeContainer.style.padding = '20px';
        readmeContainer.style.borderRadius = '10px';
        readmeContainer.style.border = '2px solid #ffcc00';
        readmeContainer.style.overflowY = 'auto';
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = 'Raptor: Call of the Shadows - Readme';
        title.style.color = '#ffcc00';
        title.style.marginBottom = '20px';
        title.style.textAlign = 'center';
        readmeContainer.appendChild(title);
        
        // Add readme content
        const content = document.createElement('div');
        content.style.color = 'white';
        content.style.fontSize = '16px';
        content.style.lineHeight = '1.6';
        content.style.textAlign = 'left';
        content.style.marginBottom = '30px';
        content.innerHTML = `
            <h3 style="color: #ffcc00;">About This Game</h3>
            <p>This is a reimagined version of the classic 1994 vertical shooter "Raptor: Call of the Shadows" by Cygnus Studios. 
            This fan project was created as a tribute to the original game using modern web technologies.</p>
            
            <h3 style="color: #ffcc00;">Controls</h3>
            <p><strong>Movement:</strong> Arrow Keys or WASD</p>
            <p><strong>Fire Primary Weapon:</strong> Space or Ctrl</p>
            <p><strong>Fire Special Weapon:</strong> Shift</p>
            <p><strong>Cycle Special Weapons:</strong> Alt</p>
            <p><strong>Megabomb:</strong> B</p>
            <p><strong>Pause:</strong> P or Esc</p>
            
            <h3 style="color: #ffcc00;">Gameplay</h3>
            <p>Navigate through enemy formations, collect power-ups, and defeat bosses to progress through the game. 
            Your ship has both health and shield systems - manage them carefully!</p>
            
            <h3 style="color: #ffcc00;">Features</h3>
            <ul>
                <li>Classic 4:3 aspect ratio gameplay</li>
                <li>Multiple enemy types with unique behaviors</li>
                <li>Power-up collection system</li>
                <li>Boss battles</li>
                <li>Progressive difficulty</li>
                <li>Score tracking</li>
            </ul>
            
            <h3 style="color: #ffcc00;">Technical Notes</h3>
            <p>This game is built using vanilla JavaScript and HTML5 Canvas. All assets have been recreated for this project. 
            The game runs entirely in your browser - no downloads required!</p>
        `;
        readmeContainer.appendChild(content);
        
        // Add back button
        const backButton = document.createElement('button');
        backButton.textContent = 'Back to Menu';
        backButton.style.padding = '10px 20px';
        backButton.style.backgroundColor = '#333';
        backButton.style.color = 'white';
        backButton.style.border = 'none';
        backButton.style.borderRadius = '5px';
        backButton.style.cursor = 'pointer';
        backButton.style.fontSize = '16px';
        backButton.addEventListener('click', () => {
            this.setupMenuScreen();
        });
        readmeContainer.appendChild(backButton);
        
        menuScreen.appendChild(readmeContainer);
    }
    
    /**
     * Show loading message when trying to start game before assets are ready
     */
    showLoadingMessage() {
        // Create a temporary loading message
        const menuScreen = document.getElementById('menu-screen');
        const loadingMsg = document.createElement('div');
        loadingMsg.style.position = 'fixed';
        loadingMsg.style.top = '50%';
        loadingMsg.style.left = '50%';
        loadingMsg.style.transform = 'translate(-50%, -50%)';
        loadingMsg.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        loadingMsg.style.color = 'white';
        loadingMsg.style.padding = '20px';
        loadingMsg.style.borderRadius = '10px';
        loadingMsg.style.zIndex = '1000';
        loadingMsg.textContent = 'Loading game assets... Please wait.';
        
        menuScreen.appendChild(loadingMsg);
        
        // Remove message after 2 seconds
        setTimeout(() => {
            if (loadingMsg.parentNode) {
                loadingMsg.parentNode.removeChild(loadingMsg);
            }
        }, 2000);
    }
    
    /**
     * Show credits
     */
    showCredits() {
        // Create credits screen
        const menuScreen = document.getElementById('menu-screen');
        menuScreen.innerHTML = '';
        
        const creditsContainer = document.createElement('div');
        creditsContainer.style.display = 'flex';
        creditsContainer.style.flexDirection = 'column';
        creditsContainer.style.alignItems = 'center';
        creditsContainer.style.justifyContent = 'center';
        creditsContainer.style.width = '80%';
        creditsContainer.style.height = '80%';
        creditsContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        creditsContainer.style.padding = '20px';
        creditsContainer.style.borderRadius = '10px';
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = 'Credits';
        title.style.color = '#ffcc00';
        title.style.marginBottom = '20px';
        creditsContainer.appendChild(title);
        
        // Add credits text
        const credits = document.createElement('div');
        credits.style.color = 'white';
        credits.style.fontSize = '18px';
        credits.style.lineHeight = '1.5';
        credits.style.textAlign = 'center';
        credits.style.marginBottom = '30px';
        credits.innerHTML = `
            <p><strong>Raptor: Call of the Shadows Reimagined</strong></p>
            <p>A fan project created as a tribute to the original game</p>
            <p>Original game by Cygnus Studios / Apogee Software (1994)</p>
            <p>This reimagining created by Manus AI (2025)</p>
            <p>All assets and code created for educational purposes</p>
        `;
        creditsContainer.appendChild(credits);
        
        // Add back button
        const backButton = document.createElement('button');
        backButton.textContent = 'Back to Menu';
        backButton.style.padding = '10px 20px';
        backButton.style.backgroundColor = '#333';
        backButton.style.color = 'white';
        backButton.style.border = 'none';
        backButton.style.borderRadius = '5px';
        backButton.style.cursor = 'pointer';
        backButton.addEventListener('click', () => {
            this.setupMenuScreen();
        });
        creditsContainer.appendChild(backButton);
        
        menuScreen.appendChild(creditsContainer);
    }
    
    /**
     * Update menu when gameplay assets finish loading
     */
    updateMenuForLoadedAssets() {
        // Update loading indicator if it exists
        const loadingIndicator = document.getElementById('background-loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.textContent = 'Game assets loaded!';
            loadingIndicator.style.color = '#4CAF50';
            
            // Remove indicator after 2 seconds
            setTimeout(() => {
                if (loadingIndicator.parentNode) {
                    loadingIndicator.parentNode.removeChild(loadingIndicator);
                }
            }, 2000);
        }
        
        // Update the Start Game option to be clickable
        const menuScreen = document.getElementById('menu-screen');
        const menuContainer = menuScreen.querySelector('div > div > div');
        if (menuContainer) {
            const options = menuContainer.querySelectorAll('div');
            options.forEach((option, index) => {
                if (option.textContent.includes('Start New Game')) {
                    option.textContent = 'Start New Game';
                    option.style.color = 'white';
                    option.style.cursor = 'pointer';
                }
            });
        }
    }
    
    /**
     * Update the menu state
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        // We no longer need the time-based delay check, because wasKeyJustPressed handles it.
        
        if (this.game.input.wasKeyJustPressed('ArrowUp') || this.game.input.wasKeyJustPressed('w')) {
            this.selectedOption = (this.selectedOption - 1 + this.menuOptions.length) % this.menuOptions.length;
            this.highlightSelectedOption();
        }
        
        if (this.game.input.wasKeyJustPressed('ArrowDown') || this.game.input.wasKeyJustPressed('s')) {
            this.selectedOption = (this.selectedOption + 1) % this.menuOptions.length;
            this.highlightSelectedOption();
        }
        
        if (this.game.input.wasKeyJustPressed('Enter') || this.game.input.wasKeyJustPressed(' ')) {
            this.menuOptions[this.selectedOption].action();
        }
    }
    
    /**
     * Highlight the currently selected option for keyboard navigation
     */
    highlightSelectedOption() {
        const menuScreen = document.getElementById('menu-screen');
        const menuContainer = menuScreen.querySelector('div > div > div');
        if (!menuContainer) return;
        
        const options = menuContainer.querySelectorAll('div');
        
        options.forEach((option, index) => {
            if (option.textContent.includes('(')) return; // Skip loading text
            
            if (index === this.selectedOption) {
                option.style.color = '#ffcc00';
                option.style.textShadow = '0 0 15px #ffcc00';
            } else {
                option.style.color = 'white';
                option.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
            }
        });
    }
    
    /**
     * Render the menu state
     */
    render() {
        // Menu is rendered using HTML/CSS in the menu-screen element
    }
    
    /**
     * Exit the menu state
     */
    exit() {
        logger.info('Exiting Menu State');
        
        // Hide menu screen
        document.getElementById('menu-screen').style.display = 'none';
        
        // Stop menu music
        // this.game.audio.stopMusic(); // Commented out - no audio assets defined yet
    }

    // Add this method at the end of the class, before the closing }
    showOptionsMenu() {
        const menuScreen = document.getElementById('menu-screen');
        menuScreen.innerHTML = '';

        // Create overlay container
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        overlay.style.zIndex = '10';

        // Title
        const title = document.createElement('h2');
        title.textContent = 'Select Resolution';
        title.style.color = '#ffcc00';
        title.style.marginBottom = '30px';
        overlay.appendChild(title);

        // Resolution options
        const resolutions = [
            { label: '960 x 540', width: 960, height: 540 },
            { label: '1280 x 720', width: 1280, height: 720 },
            { label: '1440 x 810', width: 1440, height: 810 }
        ];
        const currentWidth = this.game.width;
        const currentHeight = this.game.height;
        resolutions.forEach(res => {
            const btn = document.createElement('button');
            btn.textContent = res.label;
            btn.style.margin = '10px';
            btn.style.padding = '16px 40px';
            btn.style.fontSize = '22px';
            btn.style.backgroundColor = '#222';
            btn.style.color = '#ffcc00';
            btn.style.border = '2px solid #ffcc00';
            btn.style.borderRadius = '8px';
            btn.style.cursor = 'pointer';
            btn.style.transition = 'background 0.2s, color 0.2s';
            // Highlight the currently selected resolution
            if (res.width === currentWidth && res.height === currentHeight) {
                btn.style.backgroundColor = '#ffcc00';
                btn.style.color = '#222';
                btn.style.fontWeight = 'bold';
                btn.style.boxShadow = '0 0 12px #ffcc00';
            }
            btn.addEventListener('mouseover', () => {
                btn.style.backgroundColor = '#ffcc00';
                btn.style.color = '#222';
            });
            btn.addEventListener('mouseout', () => {
                if (res.width === this.game.width && res.height === this.game.height) {
                    btn.style.backgroundColor = '#ffcc00';
                    btn.style.color = '#222';
                } else {
                    btn.style.backgroundColor = '#222';
                    btn.style.color = '#ffcc00';
                }
            });
            btn.addEventListener('click', () => {
                this.setGameResolution(res.width, res.height);
                this.showOptionsMenu(); // Stay on options menu and update highlight
            });
            overlay.appendChild(btn);
        });

        // Back button
        const backBtn = document.createElement('button');
        backBtn.textContent = 'Back';
        backBtn.style.marginTop = '40px';
        backBtn.style.padding = '12px 32px';
        backBtn.style.fontSize = '18px';
        backBtn.style.backgroundColor = '#333';
        backBtn.style.color = 'white';
        backBtn.style.border = '1px solid #ffcc00';
        backBtn.style.borderRadius = '6px';
        backBtn.style.cursor = 'pointer';
        backBtn.addEventListener('click', () => {
            this.setupMenuScreen();
        });
        overlay.appendChild(backBtn);

        // Pop Out button
        const popOutBtn = document.createElement('button');
        popOutBtn.textContent = 'Pop Out';
        popOutBtn.style.marginTop = '20px';
        popOutBtn.style.padding = '12px 32px';
        popOutBtn.style.fontSize = '18px';
        popOutBtn.style.backgroundColor = '#222';
        popOutBtn.style.color = '#ffcc00';
        popOutBtn.style.border = '2px solid #ffcc00';
        popOutBtn.style.borderRadius = '6px';
        popOutBtn.style.cursor = 'pointer';
        popOutBtn.addEventListener('click', () => {
            const width = this.game.width;
            const height = this.game.height;
            const features = `width=${width},height=${height},resizable=no,scrollbars=no,status=no,toolbar=no,menubar=no,location=no`;
            const popup = window.open(window.location.pathname, 'RaptorGamePopup', features);
            if (!popup || popup.closed || typeof popup.closed === 'undefined') {
                alert('Popup was blocked! Please allow popups for this site.');
            }
        });
        overlay.appendChild(popOutBtn);

        menuScreen.appendChild(overlay);
    }

    setGameResolution(width, height) {
        this.game.width = width;
        this.game.height = height;
        for (const key in this.game.layers) {
            const canvas = this.game.layers[key];
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        // Re-center canvases
        for (const key in this.game.layers) {
            const canvas = this.game.layers[key];
            canvas.style.position = 'absolute';
            canvas.style.left = '50%';
            canvas.style.top = '50%';
            canvas.style.transform = 'translate(-50%, -50%)';
        }
        // Redraw current state if needed
        if (this.game.currentState && typeof this.game.currentState.resize === 'function') {
            this.game.currentState.resize();
        }
    }
}

export { MenuState };
</file>

<file path="js/engine/game.js">
/**
 * Game class
 * The main engine that runs the entire game, manages the canvas layers,
 * the game loop, and the state machine.
 */
import { InputHandler } from './input.js';
import { AssetManager } from './assets.js';
import { AudioManager } from './audio.js';
import { CollisionSystem } from './collision.js';
import { EntityManager } from './entity.js';
import { SaveManager } from './saveManager.js';
import { ObjectPool } from './ObjectPool.js';
import { Projectile } from '../entities/projectile.js';
import { Missile } from '../entities/missile.js';
import { BootState } from '../states/boot.js';
import { LoadingState } from '../states/LoadingState.js';
import { IntroCutsceneState } from '../states/introCutscene.js';
import { MenuState } from '../states/menu.js';
import { GameState } from '../states/gameState.js';
import { PauseState } from '../states/pause.js';
import { GameOverState } from '../states/gameover.js';
import { HangarState } from '../states/hangar.js';
import { SupplyState } from '../states/supply.js';
import ShopState from '../states/shop.js';
import { CharacterSelectState } from '../states/characterSelect.js';
import { logger } from '../utils/logger.js';

class Game {
    constructor() {
        // --- TIMING & FPS LOCK ---
        this.lastTime = 0;
        this.accumulator = 0;
        this.timeStep = 1000 / 60;
        this.currentFPS = 0;
        this.debugMode = false; // Enable debug logging for the game loop

        // --- BIND THE GAME LOOP'S CONTEXT ---
        this.gameLoop = this.gameLoop.bind(this);

        // Find all the canvas layers from the HTML
        this.layers = {
            background: document.getElementById('background-layer'),
            enemy: document.getElementById('enemy-layer'),
            projectile: document.getElementById('projectile-layer'),
            player: document.getElementById('player-layer'),
            explosion: document.getElementById('explosion-layer'),
            ui: document.getElementById('ui-layer')
        };

        // Get the 2D rendering contexts for each layer
        this.contexts = {};
        for (const key in this.layers) {
            const canvas = this.layers[key];
            const ctx = canvas.getContext('2d', { alpha: true });

            ctx.globalCompositeOperation = 'source-over';
            ctx.imageSmoothingEnabled = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.contexts[key] = ctx;
        }

        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.playerData = { score: 0, money: 0 };

        // --- Core Engine Components ---
        this.input = new InputHandler();
        // --- NEW: The AssetManager now correctly receives the game instance ---
        this.assets = new AssetManager(this);
        // --- NEW: The AudioManager is now initialized with assets ---
        this.audio = new AudioManager(this.assets);

        this.collision = new CollisionSystem(this);
        this.entityManager = new EntityManager(this);
        this.saveManager = new SaveManager(this);
        this.projectilePool = new ObjectPool(() => new Projectile(this), 50); // Creates a pool of 50 projectiles
        this.missilePool = new ObjectPool(() => new Missile(this), 20); // Creates a pool of 20 missiles

        // --- State Management ---
        this.states = {
            boot: new BootState(this),
            loading: new LoadingState(this),
            introCutscene: new IntroCutsceneState(this),
            menu: new MenuState(this),
            game: new GameState(this),
            pause: new PauseState(this),
            gameover: new GameOverState(this),
            hangar: new HangarState(this),
            supply: new SupplyState(this),
            shop: new ShopState(this),
            characterSelect: new CharacterSelectState(this)
        };
        this.currentState = null;

        // --- Start the Game ---
        (async () => {
            await this.changeState('boot');
        })();

        // Start the main game loop
        requestAnimationFrame(this.gameLoop);
    }

    /**
     * Resize all canvas layers to match window size
     */
    resize() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        this.width = windowWidth;
        this.height = windowHeight;

        for (const key in this.layers) {
            const canvas = this.layers[key];
            canvas.width = windowWidth;
            canvas.height = windowHeight;
            canvas.style.width = windowWidth + 'px';
            canvas.style.height = windowHeight + 'px';
            canvas.style.position = 'absolute';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.transform = '';
        }

        if (this.currentState && typeof this.currentState.resize === 'function') {
            this.currentState.resize();
        }
    }

    /**
     * Update the game logic with a fixed timestep
     * @param {number} deltaTime - Fixed time step in milliseconds
     */
    update(deltaTime) {
        if (this.currentState) {
            this.currentState.update(deltaTime);
        }
        this.input.update();

        // Handle debug inputs
        if (this.input.skipWavePressed) {
            logger.debug("DEBUG: Skip Wave Pressed!");
            if (this.currentState && typeof this.currentState.skipWave === 'function') {
                this.currentState.skipWave();
            }
        }

        if (this.input.restartLevelPressed) {
            logger.debug("DEBUG: Restart Level Pressed!");
            if (this.currentState && typeof this.currentState.restartLevel === 'function') {
                this.currentState.restartLevel();
            }
        }

        if (this.input.cycleLevelPressed) {
            logger.debug("DEBUG: Cycle Level Pressed!");
            this.cycleLevel();
        }
    }

    /**
     * Render the game as fast as possible
     */
    render() {
        // --- SYSTEMIC STATE RESET ---
        for (const key in this.contexts) {
            const ctx = this.contexts[key];
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, this.width, this.height);
        }
        // Now that all layers are clean and reset, proceed with rendering the current state.
        if (this.currentState) {
            this.currentState.render(this.contexts);
        }
    }

    /**
     * The main game loop, called for every frame
     * @param {number} timestamp - The current time provided by the browser
     */
    gameLoop(timestamp) {
        // Fallback for the first frame to prevent a large deltaTime
        if (!this.lastTime) {
            this.lastTime = timestamp;
        }

        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        // For the debug overlay
        this.currentFPS = Math.round(1000 / deltaTime);

        this.accumulator += deltaTime;

        // Run the fixed-step update loop for game logic
        while (this.accumulator >= this.timeStep) {
            this.update(this.timeStep);
            this.accumulator -= this.timeStep;
        }

        // Render graphics as fast as possible
        this.render();

        // Request the next frame
        requestAnimationFrame(this.gameLoop);
    }

    /**
     * Cycles through game levels for debugging purposes.
     * This method is intended for development and testing.
     */
    cycleLevel() {
        logger.debug("Attempting to cycle level...");
        // Implement level cycling logic here
        // For example, if you have a GameState that manages levels:
        if (this.currentState instanceof GameState) {
            this.currentState.cycleLevel();
        } else {
            logger.debug("Cannot cycle level: Not in GameState.");
        }
    }

    /**
     * Change the current game state
     * @param {string} stateName - The name of the state to switch to
     */
    async changeState(stateName) {
        logger.info(`Changing state from ${this.currentState ? this.currentState.constructor.name : 'null'} to ${stateName}`);

        if (this.currentState && typeof this.currentState.exit === 'function') {
            logger.info(`Exiting current state: ${this.currentState.constructor.name}`);
            this.currentState.exit();
        }

        const newState = this.states[stateName];
        if (newState) {
            logger.info(`Found new state: ${stateName}, entering...`);
            this.currentState = newState;
            if (typeof this.currentState.enter === 'function') {
                const result = this.currentState.enter();
                if (result && typeof result.then === 'function') {
                    await result;
                }
            }
            logger.info(`Successfully entered state: ${stateName}`);
        } else {
            logger.error(`State "${stateName}" not found!`);
        }
    }
}

export { Game };
</file>

<file path="js/entities/enemy.js">
import { Entity } from '../engine/entity.js';
import { Explosion } from './explosion.js';
import { Collectible } from './collectible.js';
import { logger } from '../utils/logger.js';

class Enemy extends Entity {
    constructor(game, x, y, type, spriteKey, health, scoreValue, collisionDamage) {
        const stats = Enemy.stats[type] || {};
        const width = stats.width || 48;
        const height = stats.height || 48;

        super(game, x, y, width, height);
        this.layer = 'enemy';
        this.game = game;

        // Assign properties, prioritizing data passed from the level spawner over defaults
        this.type = type;
        this.health = health !== undefined ? health : (stats.health || 20);
        this.maxHealth = this.health;
        this.scoreValue = scoreValue !== undefined ? scoreValue : (stats.points || 100);
        this.moneyValue = stats.moneyValue || 25;
        this.collisionDamage = collisionDamage !== undefined ? collisionDamage : (stats.collisionDamage || 20);

        // Load sprite and set ready state
        this.sprite = this.game.assets.getImage(spriteKey);
        if (this.sprite) {
            this.isReady = true;
        } else {
            logger.error(`Failed to load sprite with key "${spriteKey}" for enemy type "${this.type}".`);
            this.isReady = false;
        }

        // Default movement and weapon properties
        this.velocityY = 100; // A base value, can be overridden by patterns
        this.pattern = 'straight';
        this.patternParams = {};
        this.canFire = false;
        this.fireRate = 0;
        this.lastFired = 0;

        // Visual effect properties
        this.hitTime = 0;
        this.hitDuration = 100; // ms
        this.hit = false;
        this.hasEnteredPlayableArea = false;
    }

    /**
     * Reduces enemy health when it takes damage. Called by the collision system.
     * @param {number} damage - The amount of damage to inflict.
     */
    takeDamage(damage) {
        this.health -= damage;
        this.hit = true;
        this.hitTime = 0;
    }

    /**
     * The main update loop for the enemy, called every frame by the EntityManager.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    update(deltaTime) {
        // 1. Handle death sequence if health is at or below zero.
        if (this.health <= 0 && this.active) {
            this.active = false; // Deactivate immediately to prevent duplicate death sequences.

            // --- NEW LOOT DROP LOGIC ---
            // Check if there's a specific loot drop defined in the overrides.
            if (this.overrides && this.overrides.loot) {
                const loot = this.overrides.loot;
                // Create a collectible with the specified type and value
                const collectible = new Collectible(this.game, this.x, this.y, 30, 30, loot.type, loot.value);
                this.game.entityManager.add(collectible);
                this.game.collision.addToGroup(collectible, 'collectibles');
            } else {
                // Fallback to the old random loot drop system if no specific loot is defined.
                this.dropLoot();
            }
            // --- END NEW LOGIC ---

            // Grant score and money to the player.
            if (this.game && this.game.player) {
                this.game.player.addScore(this.scoreValue);
                this.game.player.addMoney(this.moneyValue);
            }

            // Create an explosion at the enemy's location.
            this.game.entityManager.add(new Explosion(this.game, this.x, this.y, this.width, this.height));

            // If this enemy is a boss, notify the level that it has been defeated.
            if (this.isBoss && this.level) {
                this.level.bossDefeated = true;
            }

            // Stop any further processing for this (now dead) enemy.
            return;
        }

        // 2. Execute movement logic.
        if (this.updateBehavior) {
            // If a custom behavior is attached (e.g., for mines), run it instead of standard movement.
            this.updateBehavior(this.game.player, deltaTime);
        } else {
            // Otherwise, perform the default movement pattern.
            this.updateMovement(deltaTime);
        }
        
        // 3. Execute firing logic if the enemy is able to shoot.
        if (this.canFire) {
            this.updateFiring(deltaTime);
        }

        // 4. Update the visual "hit" flash effect.
        if (this.hit) {
            this.hitTime += deltaTime;
            if (this.hitTime >= this.hitDuration) {
                this.hit = false;
                this.hitTime = 0;
            }
        }

        // 5. Remove the enemy if it goes too far off-screen (bottom or sides of the screen)
        let bounds = { left: 0, top: 0, right: this.game.width, bottom: this.game.height };
        if (this.game.currentState && typeof this.game.currentState.getPlayableBounds === 'function') {
            bounds = this.game.currentState.getPlayableBounds();
        }
        // Mark as entered if any part is inside the playable area
        if (
            this.x + this.width > bounds.left &&
            this.x < bounds.right &&
            this.y + this.height > bounds.top &&
            this.y < bounds.bottom
        ) {
            this.hasEnteredPlayableArea = true;
        }
        // Despawn only if it has entered and is now fully outside
        if (
            this.hasEnteredPlayableArea &&
            (this.x + this.width < bounds.left ||
             this.x > bounds.right ||
             this.y + this.height < bounds.top ||
             this.y > bounds.bottom)
        ) {
            this.destroy();
            return;
        }
        // 6. Call the base Entity's update method to apply physics (dx, dy).
        super.update(deltaTime);
    }

    render(context) {
        let bounds = { left: 0, top: 0, right: this.game.width, bottom: this.game.height };
        if (this.game.currentState && typeof this.game.currentState.getPlayableBounds === 'function') {
            bounds = this.game.currentState.getPlayableBounds();
        }
        // Only render if at least partially inside the playable area
        if (
            this.x + this.width < bounds.left ||
            this.x > bounds.right ||
            this.y + this.height < bounds.top ||
            this.y > bounds.bottom
        ) {
            return;
        }
        super.render(context);
    }

    /**
     * Handles the enemy's standard movement based on its assigned pattern.
     * This method is intended to be expanded with different patterns (e.g., straight, zigzag).
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    updateMovement(deltaTime) {
        // Call the assigned movement behavior function if it exists
        if (this.movementUpdate) {
            this.movementUpdate(this, deltaTime);
        }
    }

    /**
     * Handles the enemy's weapon firing logic.
     * This method is intended to be expanded.
     * @param {number} deltaTime - The time elapsed since the last frame.
     */
    updateFiring(deltaTime) {
        // Call the assigned firing behavior function if it exists
        if (this.firingUpdate) {
            this.firingUpdate(this, this.game.player, deltaTime);
        }
    }

    /**
     * Handles random loot drops when no specific loot is defined.
     * This is the fallback system for enemies without specific loot overrides.
     */
    dropLoot() {
        // Simple random loot drop system
        const dropChance = 0.1; // 10% chance to drop loot
        if (Math.random() < dropChance) {
            const lootTypes = ['health', 'megabomb'];
            const randomType = lootTypes[Math.floor(Math.random() * lootTypes.length)];
            const value = randomType === 'health' ? 25 : 1;
            
            const collectible = new Collectible(this.game, this.x, this.y, 30, 30, randomType, value);
            this.game.entityManager.add(collectible);
            this.game.collision.addToGroup(collectible, 'collectibles');
        }
    }
}


// --- Static Enemy Database ---
// Defines the default stats for each enemy type. This allows for easy balancing.
Enemy.stats = {
    fighter: {
        health: 20,
        points: 100,
        collisionDamage: 20,
        width: 48,
        height: 48
    },
    striker: {
        health: 60,
        points: 100,
        moneyValue: 50,
        collisionDamage: 20,
        width: 64,
        height: 64
    },
    cyclone: {
        health: 60,
        points: 250,
        moneyValue: 100,
        collisionDamage: 30,
        width: 64,
        height: 64
    },
    gnat: {
        health: 30,
        points: 50,
        moneyValue: 25,
        collisionDamage: 10,
        width: 64,
        height: 64
    },
    reaper: {
        health: 90,
        points: 150,
        moneyValue: 75,
        collisionDamage: 25,
        width: 64,
        height: 64
    },
    dart: {
        health: 60,
        points: 125,
        moneyValue: 60,
        collisionDamage: 15,
        width: 64,
        height: 64
    },
    goliath: {
        health: 180,
        points: 500,
        moneyValue: 200,
        collisionDamage: 50,
        width: 96,
        height: 96
    },
    cutter: {
        health: 60,
        points: 200,
        moneyValue: 500,
        collisionDamage: 35,
        width: 64,
        height: 64
    },
    mine: {
        health: 20,
        points: 75,
        moneyValue: 10,
        collisionDamage: 40,
        width: 32,
        height: 32
    }
};

export { Enemy };
</file>

<file path="js/engine/assets.js">
/**
 * AssetManager class
 * Handles loading and managing game assets (images, audio, data)
 */
import { logger } from '../utils/logger.js';
class AssetManager {
    constructor() {
        this.images = {};
        this.audio = {}; // This will now be managed by AudioManager
        this.data = {};
        this.totalAssets = 0;
        this.loadedAssets = 0;
        this.onProgress = null;
        this.onComplete = null;
        this.gameplayAssetsLoaded = false; // Track gameplay assets loading status
        this.onGameplayAssetsLoaded = null; // Callback when gameplay assets finish loading
        this.assetList = {}; // New property to store the full asset list
    }
    
    /**
     * Load an image asset
     * @param {string} key - The key to store the image under
     * @param {string} src - The source URL of the image
     * @returns {Promise} A promise that resolves when the image is loaded
     */
    loadImage(key, src) {
        // Check if image is already loaded
        if (this.images[key]) {
            logger.debug(`Image ${key} already loaded, skipping`);
            return Promise.resolve(this.images[key]);
        }
        
        this.totalAssets++;
        logger.debug(`Loading image: ${key} from ${src}`);
        
        return new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            
            image.onload = () => {
                logger.debug(`Image loaded: ${key}, size: ${image.width}x${image.height}`);
                
                // Store the image directly without processing
                this.images[key] = image;
                this.loadedAssets++;
                this.notifyProgress();
                resolve(image);
            };
            
            image.onerror = (error) => {
                logger.error(`Failed to load image: ${src}`, error);
                reject(new Error(`Failed to load image: ${src}`));
            };
            
            image.src = src;
        });
    }
    
    /**
     * Load a JSON data asset
     * @param {string} key - The key to store the data under
     * @param {string} src - The source URL of the JSON data
     * @returns {Promise} A promise that resolves when the data is loaded
     */
    loadJSON(key, src) {
        this.totalAssets++;
        
        return fetch(src)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Failed to load JSON: ${src}`);
                }
                return response.json();
            })
            .then(data => {
                this.data[key] = data;
                this.loadedAssets++;
                this.notifyProgress();
                return data;
            })
            .catch(error => {
                logger.error(`Failed to load JSON: ${src}`, error);
                throw error;
            });
    }
    
    /**
     * Load multiple assets at once
     * @param {Object} assets - Object containing assets to load
     * @returns {Promise} A promise that resolves when all assets are loaded
     */
    async loadAssets(assets) {
        this.assetList = assets; // Store the full asset list
        const promises = [];
        
        if (assets.images) {
            Object.entries(assets.images).forEach(([key, src]) => {
                promises.push(this.loadImage(key, src));
            });
        }
        
        if (assets.data) {
            Object.entries(assets.data).forEach(([key, src]) => {
                promises.push(this.loadJSON(key, src));
            });
        }
        return Promise.all(promises);
    }
    
    /**
     * Get an image asset
     * @param {string} key - The key of the image to get
     * @returns {Image} The image asset
     */
    getImage(key) {
        return this.images[key];
    }
    
    /**
     * Get a data asset
     * @param {string} key - The key of the data to get
     * @returns {Object} The data asset
     */
    getData(key) {
        return this.data[key];
    }
    
    /**
     * Check if all assets are loaded
     * @returns {boolean} True if all assets are loaded
     */
    isLoadingComplete() {
        return this.loadedAssets === this.totalAssets && this.totalAssets > 0;
    }
    
    /**
     * Get the loading progress as a percentage
     * @returns {number} The loading progress (0-100)
     */
    getLoadingProgress() {
        return this.totalAssets > 0 ? (this.loadedAssets / this.totalAssets) * 100 : 0;
    }
    
    /**
     * Notify progress callback if set
     */
    notifyProgress() {
        if (this.onProgress) {
            this.onProgress(this.getLoadingProgress());
        }
        
        if (this.loadedAssets === this.totalAssets && this.onComplete) {
            this.onComplete();
        }
    }
    
    /**
     * Set a callback for loading progress
     * @param {Function} callback - The callback function
     */
    setProgressCallback(callback) {
        this.onProgress = callback;
    }
    
    /**
     * Set a callback for when all assets are loaded
     * @param {Function} callback - The callback function
     */
    setCompleteCallback(callback) {
        this.onComplete = callback;
    }
    
    /**
     * Set a callback for when gameplay assets finish loading
     * @param {Function} callback - The callback function
     */
    setGameplayAssetsLoadedCallback(callback) {
        this.onGameplayAssetsLoaded = callback;
    }
    
    /**
     * Load gameplay assets in the background
     * This method loads all the heavy assets needed for actual gameplay
     */
    async loadGameplayAssets() {
        logger.info("Starting background load of gameplay assets...");
        this.gameplayAssetsLoaded = false;
        
        // Define all gameplay assets
        const gameplayAssets = {
            images: {
                // Player assets
                'playerShipBase': 'assets/images/player/player_ship_base.png',
                'playerShipLeft': 'assets/images/player/player_ship_left.png',
                'playerShipRight': 'assets/images/player/player_ship_right.png',
                'playerShipThrust': 'assets/images/player/player_ship_thrust.png',
                
                // Enemy assets
                'enemyFighter': 'assets/images/enemies/enemy_turret.png',
                'enemyStriker': 'assets/images/enemies/striker.png',
                'enemyCyclone': 'assets/images/enemies/cyclone.png',
                'enemyGnat': 'assets/images/enemies/gnat.png',
                'enemyReaper': 'assets/images/enemies/reaper.png',
                'enemyDart': 'assets/images/enemies/dart.png',
                'enemyGoliath': 'assets/images/enemies/goliath.png',
                'enemyCutter': 'assets/images/enemies/cutter.png',
                'enemyMine': 'assets/images/enemies/mine.png',
                'enemyTurret': 'assets/images/enemies/enemy_turret.png',
                'bossLevel1': 'assets/images/enemies/boss_level1.png',
                
                // Projectile assets
                'playerBullet': 'assets/images/projectiles/enemy_bullet.png',
                'enemyBullet': 'assets/images/projectiles/ENEMY_BULLET.png',
                'enemyMissile': 'assets/images/projectiles/ENEMY_MISSILE.png',
                'missile': 'assets/images/projectiles/MISSILE.png',
                
                // Environment assets
                'backgroundLevel1': 'assets/images/environment/background_level1.png',
                'backgroundLevel2': 'assets/images/environment/background_level2.png',
                'tileset_level1': 'assets/images/environment/tileset.png',
                
                // Destructible environment assets
                'fuelTank': 'assets/images/environment/FUEL_TANK.png',
                'bunker': 'assets/images/environment/BUNKER.png',
                'radarDish': 'assets/images/environment/RADAR_DISH.png',
                
                // Effects
                'explosion1': 'assets/images/explosions/explosion_2.png',
                'explosion2': 'assets/images/explosions/explosion_2.png',
                'impactEffect': 'assets/images/effects/impact_effect.png',
                
                // Collectibles
                'healthPickup': 'assets/images/collectibles/shield_pickup.png',
                'shieldPickup': 'assets/images/collectibles/shield_pickup.png',
                'megabombPickup': 'assets/images/collectibles/megabomb_pickup.png',
                
                // UI assets
                'healthBar': 'assets/images/ui/health_bar.png',
                'shieldBar': 'assets/images/ui/shield_bar.png'
            }
        };
        
        try {
            await this.loadAssets(gameplayAssets);
            this.gameplayAssetsLoaded = true;
            logger.info("Gameplay assets have been successfully loaded in the background.");
            
            // Notify callback if set
            if (this.onGameplayAssetsLoaded) {
                this.onGameplayAssetsLoaded();
            }
        } catch (error) {
            logger.error("Failed to load gameplay assets:", error);
            // Don't throw error - let the game continue with partial assets
        }
    }
}

export { AssetManager };
</file>

<file path="js/entities/enemyFactory.js">
/**
 * EnemyFactory class 2
 * Factory for creating different types of enemies.
 */
import { Enemy } from './enemy.js';
import { Boss1 } from './boss1.js';
import { DestructibleObject } from './destructibleObject.js';
import { movementPatterns, firingPatterns } from './enemyBehaviors.js';
import { logger } from '../utils/logger.js';

class EnemyFactory {
    constructor(game) {
        this.game = game;
    }

    /**
     * Creates an enemy of a specified type, adds it to the game's core systems,
     * and then returns the created instance.
     * @param {Object} enemyInfo - Object containing enemy type, position, and overrides
     * @returns {Enemy|null} The created enemy instance, or null if the type is unknown.
     */
    createEnemy(enemyInfo, level) {
        let enemy = null;
        const { type, spawn_x, spawn_y, overrides = {} } = enemyInfo;

        // Diagnostic log before switch
        logger.debug(`FACTORY INPUT: Received request to create type: "${type}"`);

        // --- Ensure enemy spawns outside the playable area ---
        let bounds = { left: 0, top: 0, right: this.game.width, bottom: this.game.height };
        if (level && typeof level.getPlayableBounds === 'function') {
            bounds = level.getPlayableBounds();
        }
        let spawnX = spawn_x;
        let spawnY = spawn_y;
        // Determine intended entry direction from movementPattern or type
        const pattern = overrides.movementPattern || type;
        if (pattern && (pattern.includes('left') || pattern === 'swoop_from_left')) {
            // Entering from left
            spawnX = bounds.left - (Enemy.stats[type]?.width || 48);
            spawnY = spawn_y;
        } else if (pattern && (pattern.includes('right') || pattern === 'swoop_from_right')) {
            // Entering from right
            spawnX = bounds.right;
            spawnY = spawn_y;
        } else if (pattern && pattern.includes('bottom')) {
            // Entering from bottom
            spawnX = spawn_x;
            spawnY = bounds.bottom;
        } else {
            // Default: entering from top
            spawnX = spawn_x;
            spawnY = bounds.top - (Enemy.stats[type]?.height || 48);
        }

        switch (type) {
            case 'fighter':
                enemy = new Enemy(this.game, spawnX, spawnY, 'fighter', 'enemyFighter', overrides.health, overrides.scoreValue);
                break;

            case 'turret':
                enemy = new Enemy(this.game, spawnX, spawnY, 'turret', 'enemyTurret', overrides.health, overrides.scoreValue);
                break;

            case 'bomber':
                enemy = new Enemy(this.game, spawnX, spawnY, 'bomber', 'enemyBomber', overrides.health, overrides.scoreValue);
                break;

            case 'boss1':
                // We create the Boss1 instance. Its stats will be applied by the "Overrides" section.
                enemy = new Boss1(this.game, spawnX, spawnY, 'bossLevel1');
                break;

            case 'striker':
                enemy = new Enemy(this.game, spawnX, spawnY, 'striker', 'enemyStriker', overrides.health, overrides.scoreValue);
                break;

            case 'cyclone':
                enemy = new Enemy(this.game, spawnX, spawnY, 'cyclone', 'enemyCyclone', overrides.health, overrides.scoreValue);
                break;

            case 'gnat':
                enemy = new Enemy(this.game, spawnX, spawnY, 'gnat', 'enemyGnat', overrides.health, overrides.scoreValue);
                break;

            case 'reaper':
                enemy = new Enemy(this.game, spawnX, spawnY, 'reaper', 'enemyReaper', overrides.health, overrides.scoreValue);
                break;

            case 'dart':
                enemy = new Enemy(this.game, spawnX, spawnY, 'dart', 'enemyDart', overrides.health, overrides.scoreValue);
                
                // Set default swooping behavior for all dart enemies
                if (!overrides.movementPattern) {
                    // Randomly choose between left and right swooping
                    const swoopDirection = Math.random() < 0.5 ? 'swoop_from_left' : 'swoop_from_right';
                    enemy.movementUpdate = movementPatterns[swoopDirection];
                    enemy.velocityY = 400; // High speed by default
                    logger.debug(`Dart assigned ${swoopDirection} pattern`);
                }
                break;

            case 'goliath':
                enemy = new Enemy(this.game, spawnX, spawnY, 'goliath', 'enemyGoliath', overrides.health, overrides.scoreValue);
                break;

            case 'cutter':
                enemy = new Enemy(this.game, spawnX, spawnY, 'cutter', 'enemyCutter', overrides.health, overrides.scoreValue);
                break;

            case 'mine':
                enemy = new Enemy(this.game, spawnX, spawnY, 'mine', 'enemyMine', overrides.health, overrides.scoreValue);
                break;

            case 'FUEL_TANK':
                enemy = new DestructibleObject(this.game, spawnX, spawnY, 'FUEL_TANK', 'fuelTank');
                break;

            case 'BUNKER':
                enemy = new DestructibleObject(this.game, spawnX, spawnY, 'BUNKER', 'bunker');
                break;

            case 'RADAR_DISH':
                enemy = new DestructibleObject(this.game, spawnX, spawnY, 'RADAR_DISH', 'radarDish');
                break;

            default:
                logger.error(`Unknown enemy type requested: "${type}"`);
                return null;
        }

        // Diagnostic log after switch
        if (enemy) { logger.debug(`FACTORY OUTPUT: Successfully created object with constructor: ${enemy.constructor.name}`); }

        // --- Apply Overrides ---
        if (enemy) {
            enemy.overrides = overrides;
            // Apply simple stat overrides
            if (overrides.health) {
                enemy.health = overrides.health;
                if (enemy.isBoss) enemy.maxHealth = overrides.health; // Keep boss healthbar in sync
            }
            if (overrides.fireRate) enemy.fireRate = overrides.fireRate;
            if (overrides.velocityX) enemy.velocityX = overrides.velocityX;
            if (overrides.velocityY) enemy.velocityY = overrides.velocityY;
            if (overrides.scoreValue) enemy.scoreValue = overrides.scoreValue;

            // Assign behavior functions from the library
            enemy.movementUpdate = movementPatterns[overrides.movementPattern] || movementPatterns['default'];
            enemy.firingUpdate = firingPatterns[overrides.firingPattern] || firingPatterns['none'];
            // If the enemy has been assigned a real firing pattern, enable its ability to fire.
            if (overrides.firingPattern && overrides.firingPattern !== 'none') {
                enemy.canFire = true;
            }
        }

        // This is the critical step: Register the new enemy with the game's systems.
        if (enemy) {
            this.game.entityManager.add(enemy);
            this.game.collision.addToGroup(enemy, 'enemies');
        }
        // This block ensures the enemy knows which level it belongs to.
        if (enemy) {
            enemy.level = level;
        }
        return enemy;
    }
}
export { EnemyFactory };
</file>

</files>
